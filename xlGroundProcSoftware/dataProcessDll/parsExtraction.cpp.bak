#include "stdafx.h"
#include "parsExtraction.h"
#include <fstream>
#include <time.h>
#include <Windows.h>
#include <math.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#pragma comment(lib,"ws2_32.lib")

/*******************************************************************/

		/// ****************** 格式转换 ************************
		fmtConvCl::fmtConvCl(UINT8 * arGet)
		{
			ar=arGet;
		}

		fmtConvCl::~fmtConvCl()
		{
		}

		UINT16 fmtConvCl::byteToUint16(int start)
		{
				 for(int i=0;i<2;i++)
				{
					UInt16Un.u[i]=ar[start+i];
				}
				return UInt16Un.s;
		}

		__int16 fmtConvCl::byteToInt16(int start)
			 {
				 for(int i=0;i<2;i++)
				{
					Int16Un.u[i]=ar[start+i];
				}
				return Int16Un.s;
			 }
		//大端
		UINT16 fmtConvCl::b2U16BigEndian(int start)
		  {
			  UInt16Un.u[0]=ar[start+1];
			  UInt16Un.u[1]=ar[start];
			  return UInt16Un.s;
		  }
		  
		__int16 fmtConvCl::b216BigEndian(int start)
		  {
				
			    Int16Un.u[1]=ar[start];
				Int16Un.u[0]=ar[start+1];

				return Int16Un.s;
		  }

		UINT32 fmtConvCl::byteToUint32(int start)
			{
				for(int i=0;i<4;i++)
				{
					UInt32Un.u[i]=ar[start+i];
				}
				return UInt32Un.s;
			}

		__int32 fmtConvCl::byteToInt32(int start)
			{
				for(int i=0;i<4;i++)
				{
					Int32Un.u[i]=ar[start+i];
				}
				return Int32Un.s;
			}

		UINT32 fmtConvCl::b2U32BigEndian(int start)
		{
			UInt32Un.u[3]=ar[start];
			UInt32Un.u[2]=ar[start+1];
			UInt32Un.u[1]=ar[start+2];
			UInt32Un.u[0]=ar[start+3];

			return UInt32Un.s;
		}

		double fmtConvCl::byteToDouble(int start)
			 {
				 for(int i=0;i<8;i++)
				 {
					 db64Un.u[i]=ar[start+i];
				 }

				 return db64Un.s;
			 }

		float fmtConvCl::byteToFloat(int start)
			 {
				   for(int i=0;i<4;i++)
				 {
					 ft32Un.u[i]=ar[start+i];
				 }

				 return ft32Un.s;
			 }

		int   fmtConvCl::byteTo16Bcd(int start)
		{
			int retRes=0;

			//retRes+=ar[start+1]&0x0f;

			//retRes+=10*(ar[start+1]>>4);

			//retRes+=100*(ar[start]&0x0f);

			//retRes+=1000*(ar[start]>>4);

			retRes+=(ar[start+1]>>4);

			retRes+=10*(ar[start+1]&0x0f);

			retRes+=1000*(ar[start]&0x0f);

			retRes+=100*(ar[start]>>4);


			return retRes;
		}

		int   fmtConvCl::byteTo8Bcd(int start)
		{
			int retRes=0;

			retRes+=(ar[start]&0x0f);

			retRes+=10*(ar[start]>>4);

			return retRes;
		}

		//由于目前返回类型的宽度都小于double，把所有的返回类型double
		double fmtConvCl::getResult(stParInFrame fmFrame)
		{
			double res=0;

			numTypeEnum type=fmFrame.numType;
			int st=fmFrame.startPosion;
			double unt=fmFrame.unit;

			if(type==uInt8Enm)
			{
				res=ar[st]*unt;
			}
			else if(type==uInt16Enm)
			{
				res=byteToUint16(st)*unt;
			}
			else if(type==int16Enm)
			{
				res=byteToInt16(st)*unt;
			}
			else if(type==uInt32Enm)
			{
				res=byteToUint32(st)*unt;
			}
			else if(type==int32Enm)
			{
				res=byteToInt32(st)*unt;
			}
			else if(type==fl32Enm)
			{
				res=byteToFloat(st)*unt;
			}
			else if(type==db64Enm)
			{
				res=byteToDouble(st)*unt;
			}
			else if(type==Bcd1Enm)
			{
				res=byteTo8Bcd(st)*unt;
			}
			else if(type==Bcd2Enm)
			{
				res=byteTo16Bcd(st)*unt;
			}
			return res;
	}

		double fmtConvCl::getBigEndianResult(stParInFrame fmFrame)
		{
			double res=0;

			numTypeEnum type=fmFrame.numType;
			int st=fmFrame.startPosion;
			double unt=fmFrame.unit;
			
			if(type==uInt8Enm)
			{
				res=ar[st]*unt;
			}
			else if(type==uInt16Enm)
			{
				res=b2U16BigEndian(st)*unt;
			}
			else if(type==int16Enm)
			{
				res=b216BigEndian(st)*unt;
			}
			else if(type==uInt32Enm)
			{
				res=b2U32BigEndian(st)*unt;
			}
			return res;
		}

		//*** 初始化参数提取的位置 ***
		stParInFrame::stParInFrame()
		{
			startPosion=4*0x60;//偏移量(字节)
			unit=1;//(单位)默认为1
			numType=uInt8Enm; 
		}

		void taskInfoPosition::initial()
		{
			//stParInFrame missionCodes,planeType,planeNum,transType,imgCompRate
			missionCodes.startPosion=4*0x60+51;
			missionCodes.numType=Bcd2Enm;

			planeType.startPosion=4*0x60+53;
			planeType.numType=uInt8Enm;

			planeNum.startPosion=4*0x60+54;
			planeNum.numType=Bcd1Enm;

			//传输类型，图像压缩比
			transType.startPosion=4*0x73;
			transType.numType=uInt8Enm;

			imgCompRate.startPosion=4*0x73+1;
			imgCompRate.numType=uInt16Enm;

			powerOnCnt.startPosion=4*0x11+2;
			powerOnCnt.numType=uInt8Enm;
		}

		void muInfoPosition::initial()
		{
			aAngle.startPosion=4*0x08;
			aAngle.numType=int16Enm;
			aAngle.unit=0.01;

			rAngle.startPosion=4*0x08+2;
			rAngle.numType=int16Enm;
			rAngle.unit=0.01;

			date_year.startPosion=4*0x60+55;
			date_year.numType=uInt8Enm;

			date_month.startPosion=4*0x60+56;
			date_month.numType=uInt8Enm;

			date_day.startPosion=4*0x60+57;
			date_day.numType=uInt8Enm;

			time_hour.startPosion=4*0x60+58;
			time_hour.numType=uInt8Enm;

			time_minutes.startPosion=4*0x60+59;
			time_minutes.numType=uInt8Enm;

			time_second.startPosion=4*0x60+60;
			time_second.numType=uInt8Enm;

			time_m_second.startPosion=4*0x60+61;
			time_m_second.numType=uInt8Enm;
			time_m_second.unit=5;

			 //经度，纬度，飞机高度，
			plane_longitude.startPosion=4*0x60+23;
			plane_longitude.numType=int32Enm;
			plane_longitude.unit=(1.0/double(2147483648.0))*SC_D; //luo

			plane_latitude.startPosion=4*0x60+27;
			plane_latitude.numType=int32Enm;
			plane_latitude.unit=(1.0/double(2147483648.0))*SC_D; //luo

			plane_height.startPosion=4*0x60+21;
			plane_height.numType=int16Enm;
			plane_height.unit=2.5*FT_M;

			//目标高度
			aim_height.startPosion=4*0x12+2;
			aim_height.numType=int16Enm;
			aim_height.unit=2.5*FT_M;

			//飞机东速度，飞机北速度，飞机天速度，东向加速，北向加速，天向加速
			plane_east_v.startPosion=4*0x60+33;
			plane_east_v.numType=int16Enm;
			plane_east_v.unit=-0.125*FT_M;
			//飞机北速度
			plane_north_v.startPosion=4*0x60+31;
			plane_north_v.numType=int16Enm;
			plane_north_v.unit=0.125*FT_M;
			//飞机天速度
			plane_up_v.startPosion=4*0x60+35;
			plane_up_v.numType=int16Enm;
			plane_up_v.unit=0.125*FT_M;
			//东向加速
			plane_east_a.startPosion=4*0x60+39;
			plane_east_a.numType=int16Enm;
			plane_east_a.unit=-0.015625*FT_M;
			//北向加速
			plane_north_a.startPosion=4*0x60+37;
			plane_north_a.numType=int16Enm;
			plane_north_a.unit=0.015625*FT_M;

			//天向加速
			plane_up_a.startPosion=4*0x60+41;
			plane_up_a.numType=int16Enm;
			plane_up_a.unit=0.015625*FT_M;

			//飞机航向角 飞机横滚角 飞机俯仰角 飞机偏航角
			plane_direction_angle.startPosion=4*0x60+43;
			plane_direction_angle.numType=int16Enm;
			plane_direction_angle.unit=(1.00/double(32768.00))*SC_D;

			//飞机横滚角
			plane_hor_angle.startPosion=4*0x60+45;
			plane_hor_angle.numType=int16Enm;
			plane_hor_angle.unit=(1.00/32768.00)*SC_D;

			//飞机俯仰角
			plane_dive_angle.startPosion=4*0x60+47;
			plane_dive_angle.numType=int16Enm;
			plane_dive_angle.unit=(1.00/double(32768.00))*SC_D;

			//飞机偏航角
			plane_departure_angle.startPosion=4*0x60+49;
			plane_departure_angle.numType=int16Enm;
			plane_departure_angle.unit=(1.00/double(32768.00))*SC_D;

			plane_ground_v.startPosion=4*0x71;
			plane_ground_v.numType=uInt32Enm;
			plane_ground_v.unit=0.001;

			//scanCode,date_year,date_month,date_day,time_hour,time_minutes,time_second,time_m_second,
			//飞机目标相对高度，飞机俯仰角，俯仰角速度，俯仰角加速度
			//plane_dive_angle_V,
			//飞机横滚角，横滚速度，横滚加速度，
			//plane_dive_angle_a,plane_hor_angle,plane_hor_angle_v,plane_hor_angle_a,
			//飞机偏流角，飞机偏航角速度，飞机偏航角加速度，地速，真空速度，指示速度
			//plane_de_flow_angle,plane_departure_v,plane_departure_a,plane_ground_v,plane_noair_v,plane_point_v,
	
		}

		void sarImageInfoPosition::initial()
		{
			loop_num.startPosion=4*0x72+2;
			loop_num.numType=uInt16Enm;

			band.startPosion=4*0x0A;
			band.numType=uInt32Enm;

			img_center_height.startPosion=4*0x12;
			img_center_height.numType=int16Enm;
			img_center_height.unit=2.5*FT_M;
			//sAngle.startPosion=4*0x08;
			work_mode.startPosion=4*0x04+1;
			//距离向预定角
			rsAngle.startPosion=4*0x08+2;
			rsAngle.numType=int16Enm;
			rsAngle.unit=0.01;

			//方位向预定角
			beam_FW_Angle.startPosion=4*0x08;
			beam_FW_Angle.numType=int16Enm;
			beam_FW_Angle.unit=0.01;
			
			//分辨率
			sarRes.startPosion=4*0x0F;
			sarRes.numType=uInt32Enm;
			
			dopler_center.startPosion=4*0x70;
			dopler_center.numType=int32Enm;
			//波束水平宽度
			beam_horz_width.startPosion=4*0x10;
			beam_horz_width.numType=uInt32Enm;

			prf.startPosion=4*0x09;
			prf.numType=uInt32Enm;
			
		    prfCount.startPosion=4;
			prfCount.numType=uInt32Enm;
			prfCount.unit=1;

			//采样起始 脉冲宽度 
			sampleStart.startPosion=0x05*4;
			sampleStart.unit=(10.0E-9);
			sampleStart.numType=uInt32Enm;
			//
			Tp.startPosion=0x0C*4;
			Tp.unit=(10.0E-9);
			Tp.numType=uInt32Enm;
			//采样点数
			samples.startPosion=0x0B*4;
			samples.numType=uInt32Enm;
			//
			a_point_size.startPosion=4*0x71;
			a_point_size.numType=uInt32Enm;

			////飞机高度，为计算场景中心高度
			//scene_center_height.startPosion=4*0x60+21;
			//scene_center_height.numType=int16Enm;
			//scene_center_height.unit=2.5*FT_M;

			plane_height.startPosion=4*0x60+21;
			plane_height.numType=int16Enm;
			plane_height.unit=2.5*FT_M;

			//目标高度
			aim_height.startPosion=4*0x12+2;
			aim_height.numType=int16Enm;
			aim_height.unit=2.5*FT_M;

			//采样起始_最近斜距
			slope_nearest.startPosion=4*0x05;
			slope_nearest.numType=uInt32Enm;
			slope_nearest.unit=1.5;

			sampoints.startPosion=4*0x0B;
			sampoints.numType=uInt32Enm;
			//工作模式
			work_mode.startPosion=4*0x04;
			work_mode.numType=uInt32Enm;

			multipleView.startPosion=4*0x22;
			multipleView.numType=uInt32Enm;

			//经度，纬度，飞机高度，
			plane_longitude.startPosion=4*0x60+23;
			plane_longitude.numType=int32Enm;
			plane_longitude.unit=(1.0/double(2147483648.0))*SC_D; //luo

			plane_latitude.startPosion=4*0x60+27;
			plane_latitude.numType=int32Enm;
			plane_latitude.unit=(1.0/double(2147483648.0))*SC_D; //luo
		}

		void sarGMTIAimInfoPosition::initial()
		{
			//目标个数
			aimsNum.startPosion=512;
			aimsNum.numType=uInt16Enm;
			//一景图像方位向点数
			scAzPoints.startPosion=514;
			scAzPoints.numType=uInt16Enm;

			//aimRangePoints.startPosion=1024;
			//aimRangePoints.numType=uInt16Enm;

			//aimAzimuthPoints.startPosion=1026;
			//aimAzimuthPoints.numType=int32Enm;
			//	
			//aimV.startPosion=1030;
			//aimV.numType=int16Enm;
			//aimV.unit=1.0/256.0;

			//aimStrength.startPosion=1032;
			//aimStrength.numType=uInt16Enm;
		}

		void GYAimInfoPosition::initial()
		{
			aimsNum.startPosion=512;
			aimsNum.numType=uInt16Enm;
			//aimsNum.numType=uInt32Enm;

			////驻留脉冲数
			//pulseResident.startPosion=0x04*4;
			//pulseResident.numType=uInt16Enm;
		}
				
		void NewGYAimInfoPosition::initial()
		{
			aimsNum.startPosion=512;
			aimsNum.numType=uInt16Enm;
			//aimsNum.numType=uInt32Enm;

			////驻留脉冲数
			pulseResident.startPosion=0x04*4;
			pulseResident.numType=uInt16Enm;

			////
			////相位中值
			//phaseMidStart.startPosion=1024;
			//phaseMidStart.numType=int16Enm;
			////phaseMidStart.unit=1/();
			////目标信息
			//aimParsStart.startPosion=1536;
			//aimParsStart.numType=uInt16Enm;
		}

		//6所文件
		dat6CommonInfoPosition::dat6CommonInfoPosition()
		{
			int psStartNum=4;

			
			infoMark.startPosion=psStartNum;//4
			infoMark.numType=uInt32Enm;

			
			psStartNum+=4;
			datLen.startPosion=psStartNum;//8
			datLen.numType=uInt32Enm;
				
			psStartNum+=4;
            missionCodes.startPosion=psStartNum;//12
			missionCodes.numType=uInt16Enm;

			psStartNum+=2;
			planeType.startPosion=psStartNum;//14;
			planeType.numType=uInt8Enm;

			psStartNum+=1;
			planeBatNum.startPosion=psStartNum;//15
			planeBatNum.numType=uInt8Enm;

			psStartNum+=1;
			planeNum.startPosion=psStartNum;//16;
			planeNum.numType=uInt16Enm;

			psStartNum+=2;
            imgCompRate.startPosion=psStartNum;//18;
			imgCompRate.numType=uInt8Enm;
				
			psStartNum+=1;
			transType.startPosion=psStartNum;//19;
			transType.numType=uInt8Enm;
			
			psStartNum+=1;
			equipType.startPosion=psStartNum;//20;
			equipType.numType=uInt8Enm;

			psStartNum+=1;
			equipCode.startPosion=psStartNum;//21;
			equipCode.numType=uInt32Enm;

			psStartNum+=4;
			powerOnCnt.startPosion=psStartNum;//25;
			powerOnCnt.numType=uInt16Enm;

			psStartNum+=2;
			muNum.startPosion=psStartNum;//27;
			muNum.numType=uInt32Enm;

			psStartNum+=4;
			date_year.startPosion=psStartNum;//31;
			date_year.numType=uInt16Enm;

			psStartNum+=2;
			date_month.startPosion=psStartNum;//33;
			date_month.numType=uInt8Enm;

			psStartNum+=1;
			date_day.startPosion=psStartNum;//34;
			date_day.numType=uInt8Enm;

			psStartNum+=1;
			time_hour.startPosion=psStartNum;//35;
			time_hour.numType=uInt8Enm;

			psStartNum+=1;
			time_minutes.startPosion=psStartNum;//36;
			time_minutes.numType=uInt8Enm;

			psStartNum+=1;
			time_second.startPosion=psStartNum;//37;
			time_second.numType=uInt8Enm;

			psStartNum+=1;
			time_m_second.startPosion=psStartNum;//38;
			time_m_second.numType=uInt16Enm;

		//经度，纬度，飞机高度，飞机目标相对高度，飞机俯仰角，俯仰角速度，俯仰角加速度
			psStartNum+=2;
			plane_longitude.startPosion=psStartNum;//40;
			plane_longitude.numType=db64Enm;

			psStartNum+=8;
			plane_latitude.startPosion=psStartNum;//48;
			plane_latitude.numType=db64Enm;

			psStartNum+=8;
			plane_height.startPosion=psStartNum;//56;
			plane_height.numType=fl32Enm;

			psStartNum+=4;
			aim_height.startPosion=psStartNum;//60;
			aim_height.numType=fl32Enm;

			psStartNum+=4;
			plane_direction_angle.startPosion=psStartNum;//64;
			plane_direction_angle.numType=fl32Enm;

			
			psStartNum+=4;
			plane_direction_angle_V.startPosion=psStartNum;//68;
			plane_direction_angle_V.numType=fl32Enm;

			psStartNum+=4;
			plane_direction_angle_A.startPosion=psStartNum;//72;
			plane_direction_angle_A.numType=fl32Enm;

			psStartNum+=4;
			plane_div_angle.startPosion=psStartNum;//76;
			plane_div_angle.numType=fl32Enm;

			psStartNum+=4;
			plane_div_angle_V.startPosion=psStartNum;//80;
			plane_div_angle_V.numType=fl32Enm;

			psStartNum+=4;
			plane_div_angle_A.startPosion=psStartNum;//84;
			plane_div_angle_A.numType=fl32Enm;

			psStartNum+=4;
			plane_hr_angle.startPosion=psStartNum;//88;
			plane_hr_angle.numType=fl32Enm;

			psStartNum+=4;
			plane_hr_angle_V.startPosion=psStartNum;//92;
			plane_hr_angle_V.numType=fl32Enm;

			psStartNum+=4;
			plane_hr_angle_A.startPosion=psStartNum;//96;
			plane_hr_angle_A.numType=fl32Enm;

			psStartNum+=4;
			plane_dflight_angle.startPosion=psStartNum;//100;
			plane_dflight_angle.numType=fl32Enm;

			psStartNum+=4;
			plane_dflow_angle.startPosion=psStartNum;//104;
			plane_dflow_angle.numType=fl32Enm;
	
			psStartNum+=4;
			plane_ground_v.startPosion=psStartNum;//108;
			plane_ground_v.numType=fl32Enm;

			psStartNum+=4;
			plane_noair_v.startPosion=psStartNum;//112;
			plane_noair_v.numType=fl32Enm;

			psStartNum+=4;
			plane_point_v.startPosion=psStartNum;//116;
			plane_point_v.numType=fl32Enm;

			psStartNum+=4;
			plane_east_v.startPosion=psStartNum;//120;
			plane_east_v.numType=fl32Enm;

			psStartNum+=4;
			plane_north_v.startPosion=psStartNum;//124;
			plane_north_v.numType=fl32Enm;

			psStartNum+=4;
			plane_up_v.startPosion=psStartNum;//128;
			plane_up_v.numType=fl32Enm;

			psStartNum+=4;
			plane_east_a.startPosion=psStartNum;//132;
			plane_east_a.numType=fl32Enm;

			psStartNum+=4;
			plane_north_a.startPosion=psStartNum;//136;
			plane_north_a.numType=fl32Enm;

			psStartNum+=4;
			plane_up_a.startPosion=psStartNum;//140;
			plane_up_a.numType=fl32Enm;


			//
			psStartNum+=4;
			anFrameCode.startPosion=psStartNum;//144;
			anFrameCode.numType=uInt32Enm;

			psStartNum+=4;
			waveNum.startPosion=psStartNum;//148;
			waveNum.numType=uInt16Enm;

			psStartNum+=2;
			waveCode.startPosion=psStartNum;//150;
			waveCode.numType=uInt16Enm;

			psStartNum+=2;
			cFreq.startPosion=psStartNum;//152;
			cFreq.numType=uInt8Enm;

			psStartNum+=1;
			lookSide.startPosion=psStartNum;//153;
			lookSide.numType=uInt8Enm;

			psStartNum+=1;
			workMode.startPosion=psStartNum;//154;
			workMode.numType=uInt8Enm;

			psStartNum+=1;
			workSonMode.startPosion=psStartNum;//155;
			workSonMode.numType=uInt8Enm;

			psStartNum+=1;
			RFar.startPosion=psStartNum;//156;
			RFar.numType=uInt32Enm;

			psStartNum+=4;
			RNear.startPosion=psStartNum;//160;
			RNear.numType=uInt32Enm;

			psStartNum+=4;
			anCenterAngle.startPosion=psStartNum;//164;
			anCenterAngle.numType=fl32Enm;

			psStartNum+=4;
			anScanScope.startPosion=psStartNum;//168;
			anScanScope.numType=fl32Enm;

			psStartNum+=4;
			a_Spot_cAngle.startPosion=psStartNum;//172;
			a_Spot_cAngle.numType=fl32Enm;

			psStartNum+=4;
			a_Spot_Width.startPosion=psStartNum;//176;
			a_Spot_Width.numType=fl32Enm;

			psStartNum+=4;
			a_Scan_step.startPosion=psStartNum;//180;
			a_Scan_step.numType=fl32Enm;

			psStartNum+=4;
			r_Spot_cAngle.startPosion=psStartNum;//184;
			r_Spot_cAngle.numType=fl32Enm;

			psStartNum+=4;
			r_Spot_Width.startPosion=psStartNum;//188;
			r_Spot_Width.numType=fl32Enm;

			psStartNum+=4;
			r_Scan_step.startPosion=psStartNum;//192;
			r_Scan_step.numType=fl32Enm;

			psStartNum+=4;
			resident_pulse.startPosion=psStartNum;//196;
			resident_pulse.numType=uInt16Enm;

			psStartNum+=2;
			resident_time.startPosion=psStartNum;//198;
			resident_time.numType=uInt16Enm;

			psStartNum+=2;
			res.startPosion=psStartNum;//200;
			res.numType=fl32Enm;

			psStartNum+=4;
			prf.startPosion=psStartNum;//204;
			prf.numType=uInt32Enm;

		}

		void GYParsInfoPosition::initial()
		{

			/*frameCodes,waveCodes,scanCenterAngle,scanStep,pulseResident,powerOnTimes,workModeFr,loadCode,loadType,
		         resvAb,spotWid,prf;*/

			//帧编号
			frameCodes.startPosion=0x2a*4+1;
			frameCodes.numType=uInt8Enm;
			//波位号
			waveCodes.startPosion=0x2a*4;
			waveCodes.numType=uInt8Enm;

			//中心扫描角
			scanCenterAngle.startPosion=0x2b*4+2;
			scanCenterAngle.numType=int16Enm;
			scanCenterAngle.unit=0.01;
			//扫描范围
			scanScope.startPosion=0x2b*4;
			scanScope.numType=int16Enm;
			scanScope.unit=0.01;
			//
			scanAngle.startPosion=4*0x08;
			scanAngle.numType=int16Enm;
			scanAngle.unit=0.01;
			//驻留脉冲数
			pulseResident.startPosion=0x04*4;
			pulseResident.numType=uInt16Enm;
			//带宽
			//10 对应50
			//20 对应25
			band.startPosion=4*0x0A;
			band.numType=uInt32Enm;
			//工作模式
			workMode.startPosion=0x04*4;
			workMode.numType=uInt32Enm;

			prf.startPosion=4*0x09;
			prf.numType=uInt32Enm;
			//采样起始 脉冲宽度 
			sampleStart.startPosion=0x05*4;
			sampleStart.unit=(10.0E-9);
			sampleStart.numType=uInt32Enm;
			//
			Tp.startPosion=0x0C*4;
			Tp.unit=(10.0E-9);
			Tp.numType=uInt32Enm;
			//采样点数
			samples.startPosion=0x0B*4;
			samples.numType=uInt32Enm;
			//方位波束预定角
			//azimuthCenterAngle.startPosion=0x19*4+2;
			azimuthCenterAngle.startPosion=0x08*4;
			azimuthCenterAngle.numType=int16Enm;
			azimuthCenterAngle.unit=0.01;

			powerOnTimes.startPosion=4*0x11+2;
			powerOnTimes.numType=uInt8Enm;

			////目标高度
			//aim_height.startPosion=4*0x12;
			//aim_height.numType=int16Enm;
			//aim_height.unit=2.5*FT_M;
			////飞机高度
			//plane_height.startPosion=4*0x60+21;
			//plane_height.numType=int16Enm;
			//plane_height.unit=2.5*FT_M;

			////采样起始_最近斜距
			//slope_nearest.startPosion=4*0x05;
			//slope_nearest.numType=uInt32Enm;
			//slope_nearest.unit=1.5;

		}

		// ***************  读取参数 *******************

		//飞行任务参数获取
		taskInfo::taskInfo(UINT8 *ar)
		{
			taskInfoPosition ps;
			ps.initial();

			fmtConvCl fmtConv(ar);

			missionCodes=fmtConv.getResult(ps.missionCodes);

			planeType=fmtConv.getResult(ps.planeType);

			planeNum=fmtConv.getResult(ps.planeNum);

			transType=fmtConv.getResult(ps.transType);

			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}
			
			imgCompRate=fmtConv.getResult(ps.imgCompRate);
			powerOnCnt=fmtConv.getResult(ps.powerOnCnt);

		}
		
		int taskInfo::output(FILE * FL)
		{	
			fprintf(FL,"任务代号:%04.0f\n",missionCodes);
			fprintf(FL,"飞行器类型:07\n");
			fprintf(FL,"飞行批号:%02.0f\n",planeType);
			fprintf(FL,"飞机号:%04.0f\n",planeNum);
			fprintf(FL,"传输方式(0=地面回读,1=实时传输,2=选择传输):%01.0f\n",transType);
			fprintf(FL,"图像压缩比:%03.0f\n",imgCompRate);
			fprintf(FL,"载荷类型(01-高空CCD,02-长焦倾斜CCD,03-SAR,04-红外行扫仪,05-多光谱):03\n");
			fprintf(FL,"载荷编号:000000\n");
			fprintf(FL,"开机次数:%03.0f\n",powerOnCnt);

			return 0;
		}
		
		taskInfo::~taskInfo()
		{
		}
		
		//惯导参数获取  
		muInfo::muInfo(UINT8 *ar)
		{
			muInfoPosition ps;
			ps.initial();

			fmtConvCl fmtConv(ar);
			
			aAngle=fmtConv.getResult(ps.aAngle);

			rAngle=fmtConv.getResult(ps.rAngle);

			date_year=fmtConv.getResult(ps.date_year)+2000;

			date_month=fmtConv.getResult(ps.date_month);

			date_day=fmtConv.getResult(ps.date_day);

			time_hour=fmtConv.getResult(ps.time_hour);

			time_minutes=fmtConv.getResult(ps.time_minutes);
	
			time_second=fmtConv.getResult(ps.time_second);
		
			time_m_second=fmtConv.getResult(ps.time_m_second);

			//高度,经度，纬度，
			plane_height=fmtConv.getResult(ps.plane_height);
			//
			aimH=fmtConv.getResult(ps.aim_height);
			plane_aim_height=plane_height-fmtConv.getResult(ps.aim_height);

			plane_longitude=fmtConv.getResult(ps.plane_longitude);
			//纬度
			plane_latitude=fmtConv.getResult(ps.plane_latitude);

			//飞机东速度，飞机北速度，飞机天速度，东向加速，北向加速，天向加速
			plane_east_v=fmtConv.getResult(ps.plane_east_v);

			//飞机北速度
			plane_north_v=fmtConv.getResult(ps.plane_north_v);
			//飞机天速度
			plane_up_v=fmtConv.getResult(ps.plane_up_v);
			//东向加速
			plane_east_a=fmtConv.getResult(ps.plane_east_a);

			plane_north_a=fmtConv.getResult(ps.plane_north_a);
			//天向加速
			plane_up_a=fmtConv.getResult(ps.plane_up_a);

			//飞机航向角 飞机横滚角 飞机俯仰角 飞机偏航角
			plane_direction_angle=fmtConv.getResult(ps.plane_direction_angle);

			plane_hor_angle=fmtConv.getResult(ps.plane_hor_angle);

			plane_dive_angle=fmtConv.getResult(ps.plane_dive_angle);

			plane_departure_angle=fmtConv.getResult(ps.plane_departure_angle);

			//plane_ground_v=fmtConv.getResult(ps.plane_ground_v);

			plane_ground_v=sqrt(plane_east_v*plane_east_v+plane_north_v*plane_north_v);
			
		}
		
		muInfo::~muInfo()
		{
		}
		
		int muInfo::output(FILE * FL)
		{
				// test code 
				//static int write_cnt = 0;

				//write_cnt++;
				//fprintf(FL,"[惯导参数列表%:]\n");
			    fprintf(FL,"惯导序号:00000\n");
			    fprintf(FL,"日期(年.月.日):%04.0f.%02.0f.%02.0f\n",date_year,date_month,date_day);
				/*fprintf(FL,"年:%.0f;\n",date_year);
				fprintf(FL,"月:%.0f;\n",date_month);
				fprintf(FL,"日:%.0f;\n",date_day);*/
				fprintf(FL,"时间(时:分:秒:毫秒):%02.0f:%02.0f:%02.0f:%03.0f\n",time_hour,time_minutes,time_second,time_m_second);				
				/*fprintf(FL,"时:%.0f;\n",time_hour);
				fprintf(FL,"分:%.0f;\n",time_minutes);
				fprintf(FL,"秒:%.0f;\n",time_second);
				fprintf(FL,"毫秒:%.0f;\n",time_m_second);*/

				fprintf(FL,"飞机经度(度):%6.7f\n",plane_longitude);
				fprintf(FL,"飞机纬度(度):%.7f\n",plane_latitude);
				fprintf(FL,"飞机海拔高度(米):%.3f\n",plane_height);
				fprintf(FL,"机下点海拔高度(米):%.3f\n",plane_aim_height);

				fprintf(FL,"飞机航向角(度):%.4f\n",plane_direction_angle);
				fprintf(FL,"飞机航向角速率(度/秒):0.00\n");
				fprintf(FL,"飞机航向角加速度(度/平方秒):0.00\n");

				fprintf(FL,"飞机俯仰角(度):%.4f\n",plane_dive_angle);
				fprintf(FL,"飞机俯仰角速度(度/秒):0.00\n");
				fprintf(FL,"飞机俯仰角加速度(度/平方秒)0.00\n");

				fprintf(FL,"飞机横滚角(度):%.4f\n",plane_hor_angle);
				fprintf(FL,"飞机横滚角速度(度/秒):0.00\n");
				fprintf(FL,"飞机横滚角加速度(度/平方秒):0.00\n");

				fprintf(FL,"飞机偏航角(度):%.4f\n",plane_departure_angle);
				fprintf(FL,"飞机偏航角速率(度/秒):%.4f\n",plane_departure_angle);
				fprintf(FL,"飞机偏流角(度):0.00\n");

				fprintf(FL,"地速(米/秒):%f\n",plane_ground_v);
				fprintf(FL,"真空速(米/秒):%f\n",plane_ground_v);
				fprintf(FL,"指示空速(米/秒):%f\n",plane_ground_v);

				fprintf(FL,"飞机东速(米/秒):%.4f\n",plane_east_v);
				fprintf(FL,"飞机北速(米/秒):%.4f\n",plane_north_v);
				fprintf(FL,"飞机天速(米/秒):%.4f\n",plane_up_v);
				fprintf(FL,"东向加速度(米/平方秒):%.4f\n",plane_east_a);
				fprintf(FL,"北向加速度(米/平方秒):%.4f\n",plane_north_a);
				fprintf(FL,"天向加速度(米/平方秒):%.4f\n",plane_up_a);
				
				/*fprintf(FL,"方位角:%6.6f(米/秒)\n",aAngle);
				fprintf(FL,"距离角:%6.6f(米/秒)\n",rAngle);*/

				return 0;
		}
		
		int muInfo::output(FILE * FL,int gdNum)
		{
				//fprintf(FL,"[惯导参数列表%:]\n");
			    fprintf(FL,"惯导序号:%d\n",gdNum);
			    fprintf(FL,"日期(年.月.日):%04.0f.%02.0f.%02.0f\n",date_year,date_month,date_day);
				/*fprintf(FL,"年:%.0f;\n",date_year);
				fprintf(FL,"月:%.0f;\n",date_month);
				fprintf(FL,"日:%.0f;\n",date_day);*/
				fprintf(FL,"时间(时:分:秒:毫秒):%02.0f:%02.0f:%02.0f:%03.0f\n",time_hour,time_minutes,time_second,time_m_second);				
				/*fprintf(FL,"时:%.0f;\n",time_hour);
				fprintf(FL,"分:%.0f;\n",time_minutes);
				fprintf(FL,"秒:%.0f;\n",time_second);
				fprintf(FL,"毫秒:%.0f;\n",time_m_second);*/

				fprintf(FL,"飞机经度(度):%6.7f\n",plane_longitude);
				fprintf(FL,"飞机纬度(度):%.7f\n",plane_latitude);
				fprintf(FL,"飞机海拔高度(米):%.3f\n",plane_height);
				fprintf(FL,"机下点海拔高度(米):%.3f\n",plane_aim_height);

				fprintf(FL,"飞机航向角(度):%.4f\n",plane_direction_angle);
				fprintf(FL,"飞机航向角速率(度/秒):0.00\n");
				fprintf(FL,"飞机航向角加速度(度/平方秒):0.00\n");

				fprintf(FL,"飞机俯仰角(度):%.4f\n",plane_dive_angle);
				fprintf(FL,"飞机俯仰角速度(度/秒):0.00\n");
				fprintf(FL,"飞机俯仰角加速度(度/平方秒)0.00\n");

				fprintf(FL,"飞机横滚角(度):%.4f\n",plane_hor_angle);
				fprintf(FL,"飞机横滚角速度(度/秒):0.00\n");
				fprintf(FL,"飞机横滚角加速度(度/平方秒):0.00\n");

				fprintf(FL,"飞机偏航角(度):%.4f\n",plane_departure_angle);
				fprintf(FL,"飞机偏航角速率(度/秒):%.4f\n",plane_departure_angle);
				fprintf(FL,"飞机偏流角(度):0.00\n");

				fprintf(FL,"地速(米/秒):%f\n",plane_ground_v);
				fprintf(FL,"真空速(米/秒):%f\n",plane_ground_v);
				fprintf(FL,"指示空速(米/秒):%f\n",plane_ground_v);

				fprintf(FL,"飞机东速(米/秒):%.4f\n",plane_east_v);
				fprintf(FL,"飞机北速(米/秒):%.4f\n",plane_north_v);
				fprintf(FL,"飞机天速(米/秒):%.4f\n",plane_up_v);
				fprintf(FL,"东向加速度(米/平方秒):%.4f\n",plane_east_a);
				fprintf(FL,"北向加速度(米/平方秒):%.4f\n",plane_north_a);
				fprintf(FL,"天向加速度(米/平方秒):%.4f\n",plane_up_a);
				
				/*fprintf(FL,"方位角:%6.6f(米/秒)\n",aAngle);
				fprintf(FL,"距离角:%6.6f(米/秒)\n",rAngle);*/

				return 0;
		}
		
		// 图像和载荷参数获取
		sarImageInfo::sarImageInfo(UINT8 *ar)
		{
				sarImageInfoPosition sarImagePs;
			    sarImagePs.initial();
				
				muInfoPosition muPs;
				muPs.initial();

				fmtConvCl fmtConv(ar);

				loop_num=fmtConv.getResult(sarImagePs.loop_num);
				//固定值01
				strip_num=1;
				//图像列数
				commonFuncs cmFuncs;
				img_cols=(double)cmFuncs.getRangePoints(ar);
				//图像行数，固定值；
				img_rows=512;
				//图像位深
				img_deepth=8.0;
				//
				UINT32 bmHorWdTemp1=(UINT32)fmtConv.getResult(sarImagePs.beam_horz_width);
				int bmHorWdTemp2=(bmHorWdTemp1>>24)&0x0F;
				if(bmHorWdTemp2>-1 &&5>bmHorWdTemp2)
				{
				    beam_horz_width=BEAM_WIDTH[bmHorWdTemp2-1];
				}
				else
				{
                   beam_horz_width=BEAM_WIDTH[0];
				}

				//prf值
				double dbTmp=fmtConv.getResult(sarImagePs.prf);
				if(dbTmp!=0.0)
				{
					prf=1.0E8/dbTmp;
				}
				else
				{
				    prf=ERROR_Value;
				}

				prfCount=fmtConv.getResult(sarImagePs.prfCount);
				//乘以prf,除以2^29
				dopler_center=prf*(fmtConv.getResult(sarImagePs.dopler_center))/(536870912.0);
				//距离向预定角
				rsAngle=fmtConv.getResult(sarImagePs.rsAngle);
				//方位向预定角
				beam_FW_Angle=fmtConv.getResult(sarImagePs.beam_FW_Angle);
				//分辨率
				UINT32 sarResIndex1=(UINT32)fmtConv.getResult(sarImagePs.sarRes);

				int sarResIndex2=sarResIndex1>>25 & 0x07;

				if(0<=sarResIndex2<8)
				{
					sarRes=RS_ARRAY[sarResIndex2];
				}
				else
				{
					sarRes=ERROR_Value;
				}
				 
				load_code=0;
				//固定值：03
				load_type=3;

				//带宽 采样频率
				int temp=0;
				temp=(int)fmtConv.getResult(sarImagePs.band);				
				temp=(temp >> 21) & 0x0F;
				if(0<=temp<5)
				{
					
					band=(double)BD_ARRAY[temp];
					fs=(double)FS_ARRAY[temp];
				}
				else
				{
					band=fs=ERROR_Value;
				}
				
				//斜距分辨率
				if(band>0)
				{
				    slope_res=C_LIGHT/(2*band*1.0e6);
				}
				else
				{
					slope_res=ERROR_Value;
				}
				
				////方位向像元尺寸所用地速
				//a_point_size=fmtConv.getResult(sarImagePs.a_point_size);
			double	dbplane_east_v=fmtConv.getResult(muPs.plane_east_v);

			//飞机北速度
			double dbplane_north_v=fmtConv.getResult(muPs.plane_north_v);
			double az_vel = sqrt(dbplane_east_v*dbplane_east_v+dbplane_north_v*dbplane_north_v);
		    
				//方位向像元尺寸
				if(prf!=0)
				{
				   a_point_size=2*az_vel/prf;  // bug
				}
				else
				{
					a_point_size=ERROR_Value;
				}
				//距离向像元尺寸 11/2 加系数1.1
				if(fs!=0)
				{

				   r_point_size=1.1*C_LIGHT/(2*fs*1.0e6);

				}
				else
				{
					r_point_size=ERROR_Value;
				}

				 //图像幅宽
				img_width=r_point_size*img_cols;  // bug
                 //图像长度
				img_length=TIFHEIGHT*a_point_size; // bug

				//地距分辨率
				double ground_res_temp=abs(sin(rsAngle*PI/180));

				if(ground_res_temp!=0)
				{
				   ground_res=slope_res/ground_res_temp;
				}
				else
				{
					ground_res=ERROR_Value;
				}

		    sampleStart=fmtConv.getResult(sarImagePs.sampleStart);
			Tp=fmtConv.getResult(sarImagePs.Tp);

			samples=fmtConv.getResult(sarImagePs.samples);
			
			slope_nearest=(sampleStart-Tp/2)*C_LIGHT/2;
			//RNear=(sampleStart)*C_LIGHT/2;

				//最近斜距
				//slope_nearest=fmtConv.getResult(sarImagePs.slope_nearest);

				sampoints=fmtConv.getResult(sarImagePs.sampoints);

				if(sampoints>0&&fs!=0)
				{
				   slope_far=slope_nearest+(sampoints/(2*fs*1.0e6))* C_LIGHT;
				   // 图像中心斜距
				   slope_sen_center=slope_nearest+(sampoints/(2*2*fs*1.0e6))* C_LIGHT;
				}
				else
				{
					slope_sen_center=slope_far=slope_nearest;					
				}

				double	elevationAngle=fmtConv.getResult(muPs.rAngle)*PI/180;

				if(elevationAngle<0)
				{
				look_Side=-1;
				}
				else
				{
				look_Side=1;
				}

				UINT32 wkMd=(UINT32)fmtConv.getResult(sarImagePs.work_mode);
				
				work_mode=(wkMd>>16) & 0x0F;

				//1：0.3M；2：0.5M；3：1M；4：3M；5：5M；6：10M；7：20M；
				//工作模式(01=条带0.5m,02=条带1m,03=条带3m,04=聚束0.3m,05=SAR/GMTI3m,06=SAR/GMTI5m,07=SAR/GMTI10m,08=广域GMTI,09=广域MMTI)
				

				switch (sarResIndex2)
				{
				case 1:
					work_mode_num=4;//0.3米聚束
					break;
				case 2:
					work_mode_num=1;//0.5米条带
					break;
				case 3:
					work_mode_num=2;//1米条带
					break;
				case 4:            //3米
					if((int)work_mode==0)
					{
						work_mode_num=3;
					}
					else
					{
						work_mode_num=5;
					}
					break;
				case 5:          //5米
					work_mode_num=6;
					break;
				case 6:
					work_mode_num=7;
				case 7:
					work_mode_num=8;
				}

			
				if((int)work_mode==4)
				{
					work_mode_num=8;
				}

				if(work_mode==3) 
				{			
					UINT32 mViewTemp=(UINT32)fmtConv.getResult(sarImagePs.multipleView);
			    	multipleView=mViewTemp>>24;
				}
				else
				{
					multipleView=2;
				}

				/*2015/12/16
				if(work_mode!=3)remove  
				{					
			    	slope_nearest=slope_sen_center-img_cols/2*r_point_size;
					slope_far=slope_sen_center+img_cols/2*r_point_size;
				}
				*/
				
				ground_nearest=slope_nearest*ground_res_temp;
				ground_far=slope_far*ground_res_temp;

				double dbTempVE=fmtConv.getResult(muPs.plane_east_v);
				double dbTempVN=fmtConv.getResult(muPs.plane_north_v);
				double dbTempV=sqrt(dbTempVE*dbTempVE+dbTempVN*dbTempVN);

				syApTime=beam_horz_width*PI*slope_far/(180*dbTempV);

				load_code=0x67;

				load_type=3;

				////波束方位向宽度
				//beam_A_width
				////波束距离向宽度；
				//beam_R_width,
				plane_longitude=fmtConv.getResult(sarImagePs.plane_longitude);
				plane_latitude=fmtConv.getResult(sarImagePs.plane_latitude);
				plane_height=fmtConv.getResult(sarImagePs.plane_height);
				aim_height=fmtConv.getResult(sarImagePs.aim_height);
				plane_east_v=fmtConv.getResult(sarImagePs.plane_east_v);
				plane_north_v=fmtConv.getResult(sarImagePs.plane_north_v);

				int Tar_Num = 4;
				double Tar_info[8]; // 用于存储定位输出结果；（存储顺序：左上角经度，纬度，右上角经度，纬度，左下角经度，纬度，右下角经度，纬度）
				double Rs[2];
				Rs[0] = slope_nearest; // 图像近端斜距；
				Rs[1] = slope_far;  // 图像远端斜距
				float plan_logn[2]; // 图像方位起始和结束位置飞机的经度
				plan_logn[0]=plane_longitude;
				plan_logn[1]=plane_longitude;
				float plan_lati[2]; // 图像方位起始和结束位置飞机的纬度
				plan_lati[0]=plane_latitude;
				plan_lati[1]=plane_latitude;
				float fly_ang=fmtConv.getResult(muPs.plane_direction_angle);// 飞机航向角，度；以正北为参考，顺时针为正，如果没有直接给出，可以用ATAN(e_v/n_v)
						
				float href=fmtConv.getResult(muPs.plane_height)-fmtConv.getResult(muPs.aim_height);// 载机到地面高度，米；
				float look_side=look_Side; // 侧视方向，左侧 1， 右侧为-1；
   
				imgProc imgP;
				imgP.Geo_locating(Tar_info,Rs,plan_logn,plan_lati,fly_ang,href,look_side,Tar_Num);


				left_top_longitude=Tar_info[0];

				left_top_latitude=Tar_info[1];

				right_up_longitude=Tar_info[2];

				right_up_latitude=Tar_info[3];

				left_down_longitude=Tar_info[4];

				left_down_latitude=Tar_info[5];

				right_down_longitude=Tar_info[6];

				right_down_latitude=Tar_info[7];

				img_center_longitude=(left_top_longitude+right_down_longitude)/2;
				img_center_latitude=(left_top_latitude+right_down_latitude)/2;
				scene_center_height=plane_height-aim_height;

				double a_Angle_far=180/PI*acos(scene_center_height/slope_far);
				double a_Angle_near=180/PI*acos(scene_center_height/slope_nearest);

				beam_R_width=a_Angle_far-a_Angle_near;
				beam_A_width=beam_horz_width;

				//(波束方位角 float)((int)(mu.plane_direction_angle-imgPars.look_Side*90+360)%360);

				a_angle_new=((int)(fmtConv.getResult(muPs.plane_direction_angle)-look_Side*90+360)%360);

				R_angle_new=90-abs(rsAngle);

		}	
		
		int sarImageInfo::output(FILE *FL)
		{
			static int cntRecvpLoop=0;
			static int  numToMerge=8;			
			static double par[30];
			
			//fprintf(FL,"[飞行任务参数列表%:]\n");
			fprintf(FL,"周期号:%05.0f\n",loop_num);
			fprintf(FL,"条带号:%02.0f\n",strip_num);
			fprintf(FL,"图像列数(列):%.0f\n",img_cols);
			fprintf(FL,"图像行数(行):%.0f\n",img_rows);
			fprintf(FL,"图像位深(位): %02.0f\n",img_deepth);
			fprintf(FL,"图像中心经度(度):%6.7f\n",img_center_longitude);
			fprintf(FL,"图像中心纬度(度):%6.7f\n",img_center_latitude);
			fprintf(FL,"图像中心高度(米):%.2f\n",aim_height);
			fprintf(FL,"左上角经度(度):%6.7f\n",left_top_longitude);
			fprintf(FL,"左上角纬度(度):%6.7f\n",left_top_latitude);
			fprintf(FL,"右上角经度(度):%6.7f\n",right_up_longitude);
			fprintf(FL,"右上角纬度(度):%6.7f\n",right_up_latitude);
			fprintf(FL,"左下角经度(度):%6.7f\n",left_down_longitude);
			fprintf(FL,"左下角纬度(度):%6.7f\n",left_down_latitude);
			fprintf(FL,"右下角经度(度):%6.7f\n",right_down_longitude);
			fprintf(FL,"右下角纬度(度):%6.7f\n",right_down_latitude);
			int wkMode=(int)work_mode;
			if(0<=wkMode<4)
			{
			fprintf(FL,"工作模式(01=条带0.5m,02=条带1m,03=条带3m,04=聚束0.3m,05=SAR/GMTI3m,06=SAR/GMTI5m,07=SAR/GMTI10m,08=广域GMTI,09=广域MMTI):%2.0f\n",work_mode_num);
			}
			else
			{
            fprintf(FL,"工作模式(01=条带0.5m,02=条带1m,03=条带3m,04=聚束0.3m,05=SAR/GMTI3m,06=SAR/GMTI5m,07=SAR/GMTI10m,08=广域GMTI,09=广域MMTI):数据异常\n");
			}
			fprintf(FL,"工作频段(0=X,1=L,2=P,3=P+L,4=Ku):0\n");

			if(rsAngle>0)
			{
				fprintf(FL,"侧视方式(0=左侧视，1=右侧视):0\n");
			}
			else
			{
				fprintf(FL,"侧视方式(0=左侧视，1=右侧视):1\n");
			}
			fprintf(FL,"方位向像元尺寸(米):%02.2f\n",a_point_size);
			fprintf(FL,"距离向像元尺寸(米):%02.2f\n",r_point_size);

			fprintf(FL,"地距分辨率(米):%02.2f\n",ground_res);
			fprintf(FL,"斜距分辨率(米):%02.2f\n",slope_res);
			
			fprintf(FL,"图像幅宽(米):%06.2f\n",img_width);
			fprintf(FL,"图像长:(米)%06.2f\n",img_length);		

			fprintf(FL,"最近斜距(米):%02.0f\n",slope_nearest);
			fprintf(FL,"最远斜距(米):%02.0f\n",slope_far);
			fprintf(FL,"场景中心斜距(米):%02.0f\n",slope_sen_center);

			fprintf(FL,"最近地距(米):%02.0f\n",ground_nearest);
			fprintf(FL,"最远地距(米):%02.0f\n",ground_far);

			//fprintf(FL,"图像中心高度(米): %05.0f\n",img_center_height);
			fprintf(FL,"场景中心高度(米): %05.0f\n",scene_center_height);
			fprintf(FL,"视数: %.0f\n",multipleView);
			fprintf(FL,"合成孔径时间(秒):%03.2f\n",syApTime);
			fprintf(FL,"重复频率(HZ):%04.0f\n",prf);
			fprintf(FL,"PRF计数:%.0f\n",prfCount);
			fprintf(FL,"多普勒中心频率(HZ):%04.0f\n",dopler_center);
			fprintf(FL,"波束方位向宽度(度):%02.04f\n",beam_horz_width);
			fprintf(FL,"波束俯仰向宽度(度):%02.04f\n",beam_R_width);
			//fprintf(FL,"分辨率(米):%02.04f\n",sarRes);		
		    fprintf(FL,"波束方位角(度):%02.04f\n",a_angle_new);
			fprintf(FL,"波束俯仰角(度):%02.04f\n",R_angle_new);
			//fprintf(FL,"波束水平宽度(度):%03.2f\n",beam_horz_width);
			fprintf(FL,"成像时间(秒):1\n");
			fprintf(FL,"数据量(兆比特/秒):1\n");
			fprintf(FL,"重要目标标识(0-不重要目标,1-重要目标,2-未知):2\n");
			//int wkMode=(int)work_mode;
			/*fprintf(FL,"载荷编号:%05.0f\n",load_code);
			fprintf(FL,"载荷类型:%02.0f\n",load_type);*/

		//周期号,条带号，图像列数，图像行数，图像幅宽，图像长，图像位深，波束水平宽度，图像中心点经度，
	    //double loop_num,strip_num,img_cols,img_rows,img_width,img_length,img_deepth,beam_horz_width,img_center_longitude,
		////图象中心点纬度，图象中心点高度，场景中心高度，左上角经度，左上角纬度，左下角经度
		//img_center_latitude,img_center_height,scene_center_height,left_top_longitude,left_top_latitude,left_down_longitude,
		////左下脚纬度，右上角经度，右上角纬度，右下角经度，右下角纬度
		//left_down_latitude,right_up_longitude,right_up_latitude,right_down_longitude,right_down_latitude,
		////方位像元尺寸，距离像元尺寸，地距分辨率，斜距分辨率，最近斜距，最远斜距，场景中心斜距，最近地距
		//a_point_size,r_point_size,ground_res,slope_res,slope_nearest,slope_far,slope_sen_center,ground_nearest,
		////最远地距，波束指向角，重复频率，多普勒中心频率，开机次数，重要目标识别，工作模式，载荷编号，载荷类型
		//ground_far,spot_dir_angle,prf,dopler_center,time_poweron,import_aim_bool,work_mode,load_code,load_type;
		////采样频率，带宽
		//double band,fs,sAngle;

			
			return 0;
		}

        int sarGMTIAimInfo::Point_Trace2(UINT16 *Tar_Az,UINT32 *Tar_Ra,UINT16 *Tar_Amp, float *Tar_ph,UINT Tar_Num,int win_ra,int win_az)
		{// 点迹凝聚 OK 10/15 CHECK dev by Yunhua-Luo 

			long   m,n,k,Tar_Num_New;
			UINT16   *Tar_Az_temp =new  UINT16[Tar_Num];
			UINT32   *Tar_Ra_temp =new  UINT32[Tar_Num];
			UINT16  *Tar_Amp_temp=new  UINT16[Tar_Num];  
			float  *Tar_Ph_temp =new  float[Tar_Num];  
			k=0;

			for(m=0;m<Tar_Num;m++)
			{
			if(Tar_Amp[m]>0)			
			for(n=0;n<Tar_Num;n++) 
				Tar_Amp[m]*=float(!((abs(Tar_Az[m]-Tar_Az[n])<win_az)&&(abs(UINT16(Tar_Ra[m]-Tar_Ra[n]))<win_ra)&&(Tar_Amp[n]>Tar_Amp[m])&&(m!=n)));
			
			if(Tar_Amp[m]>0 && abs(Tar_ph[m]) < 50) 
			{	
				Tar_Az_temp[k] = Tar_Az[m];
				Tar_Ra_temp[k] = Tar_Ra[m];
				Tar_Amp_temp[k]= Tar_Amp[m];
				Tar_Ph_temp[k] = Tar_ph[m];
				k++;
			}
			}

			Tar_Num_New=k;
			memcpy(Tar_Az,Tar_Az_temp,sizeof(UINT16)*Tar_Num_New);
			memcpy(Tar_Ra,Tar_Ra_temp,sizeof(UINT32)*Tar_Num_New);
			memcpy(Tar_Amp,Tar_Amp_temp,sizeof(UINT16)*Tar_Num_New);
			memcpy(Tar_ph,Tar_Ph_temp,sizeof(float)*Tar_Num_New);
		
			delete []  Tar_Az_temp;
			delete []  Tar_Ra_temp;
			delete []  Tar_Amp_temp; 
			delete []  Tar_Ph_temp;

			return Tar_Num_New;

		}

		// ********** SAR/GMTI定位求解 2015/12/17 ***************
        sarGMTIAimInfo::sarGMTIAimInfo(UINT8* ar,double lastPlaneLon,double lastPlaneLat)
		{
			aimRangePoints=NULL;
			aimAzimuthPoints=NULL;
			//加入了标记校正
			Tar_Azloc=NULL;
			Tar_azrev=NULL;
			aimV=NULL;
			aimStrength=NULL;
			aimLongitude=NULL;
			aimlatitude=NULL;

			commonFuncs cmFuncs;

			//用于标识初始化是否成功
			blInitial=false;
			aimRangePoints=NULL;
			aimAzimuthPoints=NULL;
			aimV=NULL;
			aimStrength=NULL;
			aimLongitude=aimlatitude=NULL;

			sarGMTIAimInfoPosition ps;
			ps.initial();

			sarImageInfo sarImgInfo(ar);
			
			fmtConvCl fmtConv(ar);

			//原始
			aimsNum=fmtConv.getBigEndianResult(ps.aimsNum);

			//aimsNum=fmtConv.getResult(ps.aimsNum);
			/*UINT32 tmp=(UINT32)aimsNum;
			aimsNum=(tmp>>24)+(tmp&0xFF0000)>>8;*/

			if(aimsNum<=0||aimsNum>10240)
			{		
				aimsNum=0;
				return;
			}
			/******************************************/
			muInfo muPars(ar);
			muInfoPosition muPs;
			muPs.initial();

			//偏航角
			yawAngle=fmtConv.getResult(muPs.plane_departure_angle);
			//飞机高度
			plane_height=fmtConv.getResult(muPs.plane_height);
			//飞机经度
			plane_longitude=fmtConv.getResult(muPs.plane_longitude);
			//纬度
			plane_latitude=fmtConv.getResult(muPs.plane_latitude);
			//飞机航向角
			plane_direction_angle=fmtConv.getResult(muPs.plane_direction_angle);
			//飞机地速度
			plane_ground_v=fmtConv.getResult(muPs.plane_ground_v);

			/***********************************************************/
			sarImageInfoPosition sarImagePs;
			sarImagePs.initial();
			slope_nearest = fmtConv.getResult(sarImagePs.slope_nearest);

			if(slope_nearest>300.0e3 || slope_nearest < 10.0e3)
			{
				aimsNum=0;
				return;
			}

			sampoints=fmtConv.getResult(sarImagePs.sampoints);		
	    	double dbTmp=fmtConv.getResult(sarImagePs.prf);
			if(dbTmp!=0.0)
			{
				prf=1.0E8/dbTmp;
			}
			else
			{
				prf=ERROR_Value;
			}
			//  带宽 采样频率
			int temp=0;
			temp=(int)fmtConv.getResult(sarImagePs.band);				
			temp=(temp >> 21) & 0x0F;
			if(0<=temp&&temp<5)
			{	
				//band=(double)BD_ARRAY[temp];
				fs=(double)FS_ARRAY[temp];
			}
			else
			{
				fs=ERROR_Value;//band=
			}
			//多视
			multipleView=cmFuncs.getMViewNum(ar); // new added 
			if(multipleView<0 || multipleView> 100) multipleView = 1;

			elevationAngle=fmtConv.getResult(muPs.rAngle)*PI/180;

			if(elevationAngle<0)
			{
				look_Side=-1;  // 右侧视
			}
			else
			{
				look_Side=1;  // 左侧视
			}

			// Point control 
			if(aimsNum>5000)
			{
				aimsNum = aimsNum%2035;
			}

			/*****************************************/
			aimRangePointsFr = new stParInFrame[aimsNum];
			aimAzimuthPointsFr = new stParInFrame[aimsNum];	
			aimVFr = new stParInFrame[aimsNum];	
			aimStrengthFr=new stParInFrame[aimsNum];

			for(int i=0;i<aimsNum;i++)
			{
				//十个字节一个点目标
				//目标azimuth
				aimAzimuthPointsFr[i].startPosion=1028+i*GMTIAIMWIDTH;
				aimAzimuthPointsFr[i].numType=uInt16Enm;

				//目标range
				aimRangePointsFr[i].startPosion=1024+i*GMTIAIMWIDTH;
				aimRangePointsFr[i].numType=uInt32Enm;

				//目标速度	
				aimVFr[i].startPosion=1030+i*GMTIAIMWIDTH;
				aimVFr[i].numType=int16Enm;
				aimVFr[i].unit=1.0/256.0;

				//目标强度
				aimStrengthFr[i].startPosion=1032+i*GMTIAIMWIDTH;
				aimStrengthFr[i].numType=uInt16Enm;

			}
			aimRangePoints=new UINT32[aimsNum];
			aimAzimuthPoints=new UINT16[aimsNum];
			Tar_Azloc=new int[aimsNum];
			Tar_azrev=new char[aimsNum];

			aimV=new float[aimsNum];
			aimStrength=new UINT16[aimsNum];
			aimlatitude=new float[aimsNum];
		    memset(aimlatitude,0,sizeof(float)*aimsNum);
			aimLongitude=new float[aimsNum];
			memset(aimLongitude,0,sizeof(float)*aimsNum);

			//标记定位函数
			double dr=C_LIGHT/2.0/fs/1.0e6; // 距离采样间隔
			double az_vel = sqrt(muPars.plane_north_v*muPars.plane_north_v+muPars.plane_east_v*muPars.plane_east_v);
		    if(az_vel < 100 || az_vel > 400) az_vel = 250.0;
			double coef_azloc=prf/az_vel/az_vel; //(plane_ground_v*plane_ground_v);// problem 

			double samps=sarImgInfo.samples;
			double TTp=sarImgInfo.Tp;
			double dr1 = dr;
			if(samps>16384) dr1 = 2*dr;         // 实时处理时候做了抽取
			double offset = TTp*fs*1.0e6/2*dr1; // 实时处理图像做了裁剪
			double r_near = slope_nearest+offset;

			// STEP 1 读取参数
			for(int i=0;i<aimsNum;i++)
			{
				aimRangePoints[i] = (UINT32)fmtConv.getBigEndianResult(aimRangePointsFr[i]);
				aimAzimuthPoints[i] = (UINT16)fmtConv.getBigEndianResult(aimAzimuthPointsFr[i]);
				aimV[i]=(float)fmtConv.getBigEndianResult(aimVFr[i]);
				if(abs(aimV[i]) > 100) aimV[i] = 15.0; // Error control
				aimStrength[i]=(UINT16)fmtConv.getBigEndianResult(aimStrengthFr[i]);
			}
			
			// STEP2. 点迹凝聚
			int win_ra = 16;
			int win_az = 8;
			int checknum = Point_Trace2(aimAzimuthPoints,aimRangePoints,aimStrength,aimV,aimsNum,win_ra,win_az);
			//aimsNum为全局变量 误删
			aimsNum=checknum;
			if(checknum==0) return;

			// STEP3. 目标定位
			if(plane_height<0 || plane_height>25000) plane_height = 17000.0; 
			double R0,Rg;
			int az_len;
			double X_JD_t,Y_WD_t;

			double logn_s = plane_longitude;
			double lati_s = plane_latitude;
			double logn_e = lastPlaneLon; // modified 
			double lati_e = lastPlaneLat;  
			double plane_logn,plane_lati;
			int az_valid;
			double yaw_ang_res = 0.6*PI/180.0;
			// 注意：目标的方位位置是多视后目标在图像中的位置 
			for(int i=0;i<checknum;i++)
			{
				R0 = r_near+aimRangePoints[i]*dr1;	//目标斜距  近端斜距+
				Rg = sqrt(R0*R0-plane_height*plane_height);

				az_len = 512*int(64/multipleView);
				az_valid = 512*int(64/multipleView-1);  // 由于参考经纬度的位置偏移一样导致
				Tar_Azloc[i] = int(aimAzimuthPoints[i]-(R0*aimV[i]*coef_azloc/multipleView));
			    Tar_azrev[i] = char(-float(Tar_Azloc[i]<0)+float(Tar_Azloc[i]>(az_len-1)));
			   
				// **** 求解每一目标点方位位置载机的经纬度 ****
				plane_logn = logn_s+(logn_e-logn_s)*Tar_Azloc[i]/double(az_valid);
				plane_lati = lati_s+(lati_e-lati_s)*Tar_Azloc[i]/double(az_valid);

				Tar_Azloc[i] = MAX((Tar_Azloc[i]+az_len)%az_len,0);

				// **** 根据几何关系定位，精度需要改进（后续升级）,定位精度<1km ***
				
				X_JD_t = -Rg*look_Side*cos((plane_direction_angle-yaw_ang_res)*PI/180.0*look_Side);
				Y_WD_t = Rg*sin((plane_direction_angle-yaw_ang_res)*PI/180.0*look_Side);

				aimLongitude[i] = plane_logn + X_JD_t/60.0/1852.0/cos(plane_lati*PI/180);
				aimlatitude[i]  = plane_lati + Y_WD_t/60.0/1852.0;  

				/*cmFuncs.logRecords("Target_no:",(double)(i));
				cmFuncs.logRecords("az_loc:",(double)(Tar_Azloc[i]));
				cmFuncs.logRecords("rg_loc:",(double)(aimRangePoints[i]));
				cmFuncs.logRecords("longitude:",(double)(aimLongitude[i]));
				cmFuncs.logRecords("latitude:",(double)(aimlatitude[i]));*/
				// test code 
                //aimlatitude[i]  = plane_latitude+float(Rg*cos(plane_direction_angle+PI*look_Side/2.0)/60.0/1852.0);
				//aimLongitude[i] = plane_longitude+float(Rg*sin(plane_direction_angle+PI*look_Side/2.0)/60.0/1852.0/cos(aimlatitude[i]*PI/180));
			
			}

			blInitial=true;
		}

		sarGMTIAimInfo::sarGMTIAimInfo(UINT8 *ar)
		{ // modified by Yunhua-Luo @ 0724
		//	         
		//	aimRangePoints=NULL;
		//	aimAzimuthPoints=NULL;
		//	//加入了标记校正
		//	Tar_Azloc=NULL;
		//	Tar_azrev=NULL;
		//	aimV=NULL;
		//	aimStrength=NULL;
		//	aimLongitude=NULL;
		//	aimlatitude=NULL;
		//
		//			commonFuncs cmFuncs;
		//
		//			//用于标识初始化是否成功
		//			blInitial=false;
		//			aimRangePoints=NULL;
		//			aimAzimuthPoints=NULL;
		//			aimV=NULL;
		//			aimStrength=NULL;
		//			aimLongitude=aimlatitude=NULL;
		//
		//			sarGMTIAimInfoPosition ps;
		//			ps.initial();
		//
		//			fmtConvCl fmtConv(ar);

			//原始
		//			aimsNum=fmtConv.getBigEndianResult(ps.aimsNum);
		//
		//			//aimsNum=fmtConv.getResult(ps.aimsNum);
		//			/*UINT32 tmp=(UINT32)aimsNum;
		//			aimsNum=(tmp>>24)+(tmp&0xFF0000)>>8;*/
		//
		//			if(aimsNum<=0||aimsNum>10240)
		//			{				
		//				return;
		//			}
		//			/******************************************/
		//			muInfo muPars(ar);
		//			muInfoPosition muPs;
		//			muPs.initial();
		//
		//			//偏航角
		//			yawAngle=fmtConv.getResult(muPs.plane_departure_angle);
		//			//飞机高度
		//			plane_height=fmtConv.getResult(muPs.plane_height);
		//			//飞机经度
		//			plane_longitude=fmtConv.getResult(muPs.plane_longitude);
		//			//纬度
		//			plane_latitude=fmtConv.getResult(muPs.plane_latitude);
		//			//飞机航向角
		//			plane_direction_angle=fmtConv.getResult(muPs.plane_direction_angle);
		//			//飞机地速度
		//			plane_ground_v=fmtConv.getResult(muPs.plane_ground_v);
		//
		//			/***********************************************************/
		//			sarImageInfoPosition sarImagePs;
		//			sarImagePs.initial();
		//			slope_nearest = fmtConv.getResult(sarImagePs.slope_nearest);
		//
		//			if(slope_nearest>300.0e3 || slope_nearest < 30.0e3)
		//			{
		//				aimsNum=0;
		//				return;
		//			}
		//
		//			sampoints=fmtConv.getResult(sarImagePs.sampoints);		
		//	    	double dbTmp=fmtConv.getResult(sarImagePs.prf);
		//			if(dbTmp!=0.0)
		//			{
		//				prf=1.0E8/dbTmp;
		//			}
		//			else
		//			{
		//				prf=ERROR_Value;
		//			}
		//			//  带宽 采样频率
		//			int temp=0;
		//			temp=(int)fmtConv.getResult(sarImagePs.band);				
		//			temp=(temp >> 21) & 0x0F;
		//			if(0<=temp&&temp<5)
		//			{	
		//				//band=(double)BD_ARRAY[temp];
		//				fs=(double)FS_ARRAY[temp];
		//			}
		//			else
		//			{
		//				fs=ERROR_Value;//band=
		//			}
		//			//多视
		//			multipleView=cmFuncs.getMViewNum(ar);
		//
		//
		//			elevationAngle=fmtConv.getResult(muPs.rAngle)*PI/180;
		//
		//			if(elevationAngle<0)
		//			{
		//				look_Side=-1;
		//			}
		//			else
		//			{
		//				look_Side=1;
		//			}
		//			
		//			/*****************************************/
		//			aimRangePointsFr = new stParInFrame[aimsNum];
		//			aimAzimuthPointsFr = new stParInFrame[aimsNum];	
		//			aimVFr = new stParInFrame[aimsNum];	
		//			aimStrengthFr=new stParInFrame[aimsNum];
		//
		//			for(int i=0;i<aimsNum;i++)
		//			{
		//			//十个字节一个点目标
		//
		//			//目标azimuth
		//			aimAzimuthPointsFr[i].startPosion=1028+i*GMTIAIMWIDTH;
		//			aimAzimuthPointsFr[i].numType=uInt16Enm;
		//
		//			//目标range
		//			aimRangePointsFr[i].startPosion=1024+i*GMTIAIMWIDTH;
		//			aimRangePointsFr[i].numType=uInt32Enm;
		//
		//			//目标速度	
		//			aimVFr[i].startPosion=1030+i*GMTIAIMWIDTH;
		//			aimVFr[i].numType=int16Enm;
		//			aimVFr[i].unit=1.0/256.0;
		//
		//			aimStrengthFr[i].startPosion=1032+i*GMTIAIMWIDTH;
		//			aimStrengthFr[i].numType=uInt16Enm;
		//
		//			}
		//
		//			aimRangePoints=new UINT32[aimsNum];
		//			aimAzimuthPoints=new UINT16[aimsNum];
		//			Tar_Azloc=new int[aimsNum];
		//			Tar_azrev=new char[aimsNum];
		//
		//			aimV=new float[aimsNum];
		//			aimStrength=new UINT16[aimsNum];
		//			aimlatitude=new float[aimsNum];
		//		    memset(aimlatitude,sizeof(float),aimsNum);
		//			aimLongitude=new float[aimsNum];
		//			memset(aimLongitude,sizeof(float),aimsNum);
		//
		//			//标记定位函数
		//			double dr=C_LIGHT/2.0/fs/1.0e6; // 距离采样间隔
		//            //az_vel：飞机速度 Tar_Raloc:
		//
		//			double az_vel = sqrt(muPars.plane_north_v*muPars.plane_north_v+muPars.plane_east_v*muPars.plane_east_v);
		//		    double coef_azloc=prf/az_vel/az_vel; //(plane_ground_v*plane_ground_v);// problem 
		//
		//			for(int i=0;i<aimsNum;i++)
		//			{
		//				/*************小端************************************************/
		//				////目标距离门号
		//				//aimAzimuthPoints[i]=(UINT32)fmtConv.getResult(aimAzimuthPointsFr[i]);
		//				////目标方位点
		//				//aimRangePoints[i]=(UINT16)fmtConv.getResult(aimRangePointsFr[i]);
		//				//
		//				//aimV[i]=(float)fmtConv.getResult(aimVFr[i]);
		//				//aimStrength[i]=(UINT16)fmtConv.getResult(aimStrengthFr[i]);
		//				//目标方位点 U16
		//				aimRangePoints[i] = (UINT32)fmtConv.getBigEndianResult(aimRangePointsFr[i]);
		//				//距离门号   U32
		//				aimAzimuthPoints[i] = (UINT16)fmtConv.getBigEndianResult(aimAzimuthPointsFr[i]);
		//				
		//				aimV[i]=(float)fmtConv.getBigEndianResult(aimVFr[i]); // problem 
		//				aimStrength[i]=(UINT16)fmtConv.getBigEndianResult(aimStrengthFr[i]);
		//
		//			}
		//
		//			// 点迹凝聚
		//			int win_ra = 16;
		//			int win_az = 8;
		//			int checknum = Point_Trace2(aimAzimuthPoints,aimRangePoints,aimStrength,aimV,aimsNum,win_ra,win_az);
		//
		//			// 目标定位
		//			for(int i=0;i<checknum;i++)
		//			{
		//				double R0=slope_nearest+aimRangePoints[i]*dr;//目标斜距  近端斜距+
		//				double Rg=sqrt(R0*R0-plane_height*plane_height);
		//
		//				//罗运华校正
		//				int az_len = 512*4;
		//				multipleView = 1; 
		//				Tar_Azloc[i] = aimAzimuthPoints[i]-R0*aimV[i]*coef_azloc;
		//			    Tar_azrev[i] = char(-float(Tar_Azloc[i]<0)+float(Tar_Azloc[i]>(az_len-1)));
		//			    Tar_Azloc[i] = MAX((Tar_Azloc[i]+az_len)%az_len,0);
		//			    Tar_Azloc[i] = int(Tar_Azloc[i]/float(multipleView));
		//
		//				//double X_JD_t = -Rg*look_Side*cos(plane_direction_angle*PI/180.0*look_Side);
		//				//double Y_WD_t = Rg*sin(plane_direction_angle*look_Side);	
		//
		//				double X_JD_t = -Rg*look_Side*cos((plane_direction_angle-yawAngle)*PI/180.0*look_Side);
		//				double Y_WD_t = Rg*sin((plane_direction_angle-yawAngle)*PI/180.0*look_Side);
		//
		//				aimLongitude[i] = plane_longitude + X_JD_t/60.0/1852.0/cos(plane_latitude*PI/180);
		//				aimlatitude[i]  = plane_latitude + Y_WD_t/60.0/1852.0;  
		//
		//				/*cmFuncs.logRecords("Target_no:",(double)(i));
		//				cmFuncs.logRecords("az_loc:",(double)(Tar_Azloc[i]));
		//				cmFuncs.logRecords("rg_loc:",(double)(aimRangePoints[i]));
		//				cmFuncs.logRecords("longitude:",(double)(aimLongitude[i]));
		//				cmFuncs.logRecords("latitude:",(double)(aimlatitude[i]));*/
		//				// test code 
		//                //aimlatitude[i]  = plane_latitude+float(Rg*cos(plane_direction_angle+PI*look_Side/2.0)/60.0/1852.0);
		//				//aimLongitude[i] = plane_longitude+float(Rg*sin(plane_direction_angle+PI*look_Side/2.0)/60.0/1852.0/cos(aimlatitude[i]*PI/180));
		//			}
		//			//cmFuncs.logRecords("***************",0);
		//
		//			/*delete [] aimAzimuthPointsFr;
		//			delete [] aimVFr;
		//			delete [] aimStrengthFr;
		//			delete [] aimRangePointsFr;
		//			*/
		//			/*delete [] aimRangePoints;
		//			delete [] aimAzimuthPoints;
		//			delete [] Tar_Azloc;
		//			delete [] Tar_azrev;
		//			delete [] aimV;
		//			delete [] aimStrength;
		//			delete [] aimlatitude;
		//			delete [] aimLongitude;
		//			*/
		//			blInitial=true;
		}

		//飞机高度 飞机航向角 左右侧视 目标斜距离 目标经度 目标纬度 目标数目
		void sarGMTIAimInfo::locatFunc(double H,double fly_ang,float lookside,float *R0, float *logn, float *lati, int tar_num)
		{
			     long  h;
				 double Rg;
				 for(h=0;h<tar_num;h++)
				 {
			      Rg=sqrt(R0[h]*R0[h]-H*H);
                  lati[h]+=float(Rg*cos(fly_ang+PI*lookside/2.0)/60.0/1852.0);
				  logn[h]+=float(Rg*sin(fly_ang+PI*lookside/2.0)/60.0/1852.0/cos(lati[h]*PI/180));
				 } 

		}
		
		sarGMTIAimInfo::~sarGMTIAimInfo()
		{
			if(aimRangePoints!=NULL)
			{
             delete [] aimRangePoints;
			 aimRangePoints=NULL;
			}

			if(aimAzimuthPoints!=NULL)
			{
             delete [] aimAzimuthPoints;
			 aimAzimuthPoints=NULL;
			}

			if(Tar_Azloc!=NULL)
			{
             delete [] Tar_Azloc;
			 Tar_Azloc=NULL;
			}

			if(Tar_azrev!=NULL)
			{
             delete [] Tar_azrev;
			 Tar_azrev=NULL;
			}

			if(aimV!=NULL)
			{
             delete [] aimV;
			 aimV=NULL;
			}

			if(aimlatitude!=NULL)
			{
             delete [] aimlatitude;
			 aimlatitude=NULL;
			}

			if(aimLongitude!=NULL)
			{
             delete [] aimLongitude;
			 aimLongitude=NULL;
			}

			if(aimStrength!=NULL)
			{
             delete [] aimStrength;
			 aimStrength=NULL;
			}
			
		}
		
		int sarGMTIAimInfo::output(FILE * FL)
		{
			 if(blInitial==false)
			 {
				  return -1;
			 }

			  for(UINT32 i=0;i<aimsNum;i++)
			  {
				fprintf(FL,"目标编号：%d\n",(i+1));
				fprintf(FL,"目标经度(度)：%3.3f\n",aimLongitude[i]);
				fprintf(FL,"目标纬度(度)：%3.3f\n",aimlatitude[i]);
				fprintf(FL,"目标速度(米/秒)：%f\n",aimV[i]);
				fprintf(FL,"目标幅度：%d\n",aimStrength[i]);
			  }

			  return 0;

		}

		// WAS-GMTI参数获取
		GYParsInfo::GYParsInfo(UINT8 *ar)
		{
			static double scanAnglePre=0;
			
			if(ar==NULL)
			{
				return;
			}

			GYParsInfoPosition ps;
			ps.initial();
			muInfo mu(ar);
			sarImageInfo imgPars(ar);

			fmtConvCl fmtConv(ar);

			frameCodes=fmtConv.getResult(ps.frameCodes);

			waveCodes=fmtConv.getResult(ps.waveCodes);
			scanCenterAngle=fmtConv.getResult(ps.scanCenterAngle);
			scanScope=fmtConv.getResult(ps.scanScope);
			
			pulseResident=fmtConv.getResult(ps.pulseResident);
			
			scanAngle=fmtConv.getResult(ps.scanAngle);
			//扫描步进
			scanStep=scanAngle-scanAnglePre;
			scanAnglePre=scanAngle;
			
			//带宽 采样频率
			int temp=0;
			temp=(int)fmtConv.getResult(ps.band);				
			temp=(temp >> 21) & 0x0F;
			if(0<=temp<5)
			{
				band=(double)BD_ARRAY[temp];
				fs=(double)FS_ARRAY[temp];
			}
			else
			{
				band=0;
				fs=1;
			}
			if(band==80)
			{
				resvAb=10;
			}
			else
			{
                 resvAb=20;
			}
            //
			UINT32 wkMd=(UINT32)fmtConv.getResult(ps.workMode);
			workMode=(wkMd>>16) & 0x0F;

			loadCode=0x67;

			loadType=3;

			powerOnTimes=fmtConv.getResult(ps.powerOnTimes);
			//powerOnTimes,workModeFr,loadCode,loadType,
		    // resvAb
			//spotWid,prf;
			//prf值
			double dbTmp=fmtConv.getResult(ps.prf);
			if(dbTmp!=0.0)
			{
				prf=1.0E8/dbTmp;
			}
			else
			{
				prf=0;
			}

			sampleStart=fmtConv.getResult(ps.sampleStart);
			Tp=fmtConv.getResult(ps.Tp);

			samples=fmtConv.getResult(ps.samples);

			RNear=(sampleStart)*C_LIGHT/2;   // bug

			commonFuncs cmFc;

			//sarGMTI模式下
			int mdTempp=cmFc.getSarModel(ar);
			if(mdTempp==4&&temp==3)
			{
				RNear=(sampleStart+1.0/prf)*C_LIGHT/2; // bug
			}

			//RNear=(sampleStart)*C_LIGHT/2;
			//RNear=(sampleStart)*C_LIGHT/2;
			RFar=RNear+C_LIGHT/(2*fs*1.0E6)*((samples-Tp*(fs*1.0E6))-1);  // bug

			//方位波束中心角
			double azTemp=fmtConv.getResult(ps.azimuthCenterAngle);

			azimuthCenterAngle=(float)((int)(mu.plane_direction_angle-imgPars.look_Side*90+imgPars.look_Side*azTemp+360)%360);
			// updated by Yunhua-Luo 12/17;
			//azimuthCenterAngle=(float)((int)(mu.plane_direction_angle-imgPars.look_Side*90-azTemp+360)%360);

			double constTheta=0.731*0.03125*180/(0.768*PI);

			azimuthAngle=constTheta/cos(scanAngle*PI/180);

			if(scanScope>40)  // noticed 
				scanCycle = 60;
			else
				scanCycle = 30;
		}
		
		GYParsInfo::~GYParsInfo()
		{
		}
		
		int GYParsInfo::output(FILE *FL)
		{
			fprintf(FL,"帧编号:%.0f\n",frameCodes);
			fprintf(FL,"波位号:%.0f\n",waveCodes);
			fprintf(FL,"扫描中心角:%.3f\n",scanCenterAngle);
			fprintf(FL,"扫描范围:%.3f\n",scanScope);
			fprintf(FL,"扫描角:%.3f\n",scanAngle);
			fprintf(FL,"驻留脉冲数:%.0f\n",pulseResident);
			int wkMode=(int)workMode;
			if(0<=wkMode<5)
			{
			fprintf(FL,"工作模式:%s\n",MD_ARRAY[wkMode]);
			}
			else
			{
            fprintf(FL,"工作模式:数据异常\n");
			}
			fprintf(FL,"载荷编号:%05.0f\n",loadCode);
			fprintf(FL,"载荷类型:%02.0f\n",loadType);			
			fprintf(FL,"分辨率(米):%02.0f\n",resvAb);
			fprintf(FL,"脉冲重复频率(HZ): %04.0f\n",prf);

			////最小、大作用距离
			//fNDistance[0]=(UINT32 )GYPars.RNear;
			//fNDistance[1]=(UINT32 )GYPars.RFar;
			//fwrite(fNDistance,sizeof(UINT32),2,FL);
			//fwrite(fNDistance,sizeof(UINT32),2,FLSend);

			fprintf(FL,"最近距离(米): %04.0f\n",RNear);
			fprintf(FL,"最大距离(米): %04.0f\n",RFar);

			fprintf(FL,"方位波束中心角: %04.0f\n",azimuthCenterAngle);
			fprintf(FL,"方位波束宽度: %04.0f\n",azimuthAngle);

			return 0;
		}
		
		GYAimInfo::GYAimInfo(UINT8* ar)
       {// WAS-GMTI parameters parse functions 
		// check by Yunhua-Luo @ 07/22

			if(ar==NULL)
			{
			  return;
			}
			aimAggNum=0;

			lstHd1.gyAimInfoPt=NULL;
			lstHd1.numAll=0;

			lstHd2.gyAimInfoPt=NULL;
			lstHd2.numAll=0;

			GYAimInfoPosition ps;
			ps.initial();

			fmtConvCl fmtConv(ar);
			
			aimsNum=fmtConv.getBigEndianResult(ps.aimsNum);
			
			//广域的目标个数最多为512个
			if(aimsNum<=0||aimsNum>512)
				return;			
			aim3DtPrFr=new stParInFrame[aimsNum];
			aim3DtNxFr=new stParInFrame[aimsNum]; 
			aimAzimuthAngleFr=new stParInFrame[aimsNum];
			aimDoplerNumFr=new stParInFrame[aimsNum];
			aimRangeNumFr=new stParInFrame[aimsNum];
			//3dt杂波抑制前目标幅度、3dt杂波抑制后目标幅度、目标方位角、目标多普勒通道号、目标距离门号
			for(int  i=0;i<aimsNum;i++)
			{

				aim3DtPrFr[i].startPosion=1024+GMTIAIMWIDTH*i;
				aim3DtPrFr[i].numType=uInt16Enm;

				aim3DtNxFr[i].startPosion=1026+GMTIAIMWIDTH*i;
				aim3DtNxFr[i].numType=uInt16Enm;

				aimAzimuthAngleFr[i].startPosion=1028+GMTIAIMWIDTH*i;
				aimAzimuthAngleFr[i].numType=int16Enm;
				aimAzimuthAngleFr[i].unit=1.0/8192.0;

				aimDoplerNumFr[i].startPosion=1030+GMTIAIMWIDTH*i;
				aimDoplerNumFr[i].numType=uInt16Enm;

				aimRangeNumFr[i].startPosion=1032+GMTIAIMWIDTH*i;
				aimRangeNumFr[i].numType=uInt16Enm;				
			}

			aim3DtPr=new UINT16[aimsNum];
			aim3DtNx=new UINT16[aimsNum];
			aimAzimuthAngle=new double[aimsNum];
			aimDoplerNum=new UINT16[aimsNum];
			aimRangeNum=new UINT16[aimsNum];
			
			for(int i=0;i<aimsNum;i++)
			{	
				// Read parameters
				aim3DtPr[i]=fmtConv.getBigEndianResult(aim3DtPrFr[i]);
				aim3DtNx[i]=fmtConv.getBigEndianResult(aim3DtNxFr[i]);
				aimAzimuthAngle[i]=fmtConv.getBigEndianResult(aimAzimuthAngleFr[i]);
				aimRangeNum[i]=fmtConv.getBigEndianResult(aimRangeNumFr[i]);
				aimDoplerNum[i]=fmtConv.getBigEndianResult(aimDoplerNumFr[i]);
			}

			/********************************************/
			muInfoPosition muPs;
			muPs.initial(); // IMU parameters

			GYParsInfoPosition gyParsPs;
			gyParsPs.initial(); // WAS-GMTI parameters
			
			elevationAngle=fmtConv.getResult(muPs.rAngle)*PI/180;

			if(elevationAngle<0)
			{
				look_Side=-1; // right side 
			}
			else
			{
				look_Side=1; // left side 
			}

			azimuthAngle = fmtConv.getResult(muPs.aAngle)*PI/180;
			yawAngle = fmtConv.getResult(muPs.plane_departure_angle)*PI/180;

			/************************************************************/
			//高度,经度，纬度，
			plane_height=fmtConv.getResult(muPs.plane_height);
			plane_aim_height=plane_height-1096.0; //fmtConv.getResult(muPs.plane_aim_height); // TEST CODE 
			plane_longitude=fmtConv.getResult(muPs.plane_longitude);
			//纬度
			plane_latitude=fmtConv.getResult(muPs.plane_latitude);
			
			//飞机航向角
			plane_direction_angle=fmtConv.getResult(muPs.plane_direction_angle); // key points
			plane_east_v=fmtConv.getResult(muPs.plane_east_v);
			plane_north_v=fmtConv.getResult(muPs.plane_north_v);

			/***********************************************************/
			sarImageInfoPosition sarImagePs; // SAR image information
			sarImagePs.initial();

			slope_nearest = fmtConv.getResult(sarImagePs.slope_nearest);
			sampoints = fmtConv.getResult(sarImagePs.sampoints);

			//prf值
			double dbTmp=fmtConv.getResult(sarImagePs.prf);
			if(dbTmp!=0.0)
			{

			   prf=1.0E8/dbTmp;
			}
			else
			{
				prf=ERROR_Value;
			}

			//带宽 采样频率
			int temp=0;
			temp=(int)fmtConv.getResult(sarImagePs.band);				
			temp=(temp >> 21) & 0x0F;
			if(0<=temp<5)
			{
				//band=(double)BD_ARRAY[temp];
				fs=(double)FS_ARRAY[temp];
				deltaRG=C_LIGHT/(2.0E6*fs);
			}
			else
			{
				fs=ERROR_Value;//band=
				deltaRG=1.2;
			}

			if(sampoints>0&&fs!=0)
			{
				slope_far=slope_nearest+(sampoints/(2*fs*1.0e6))* C_LIGHT;
				slope_sen_center=slope_nearest+(sampoints/(2*2*fs*1.0e6))* C_LIGHT;
			}
			else
			{
				slope_sen_center=slope_far=slope_nearest;					
			}
			pulseNumG=fmtConv.getResult(gyParsPs.pulseResident);
		    deltaFG=prf/pulseNumG;


			// ************* data processing ******************
			// step1. 点迹凝聚
			int tmp = aimAgglomerate();
			// step2. 目标定位
			tmp = aimIntAngle();
			// step3. 目标标注
			parsTrans();
		}

		dat6CommonInfo::dat6CommonInfo(UINT8* ar)
		{
			if(ar==NULL)
			{
				return;
			}

			fmtConvCl fmtConv(ar);

			dat6CommonInfoPosition ps;

			infoMark=fmtConv.getResult(ps.infoMark);
			datLen=fmtConv.getResult(ps.datLen);
			missionCodes=fmtConv.getResult(ps.missionCodes);
			planeType=fmtConv.getResult(ps.planeType);
			planeNum=fmtConv.getResult(ps.planeNum);
			planeBatNum=fmtConv.getResult(ps.planeBatNum);
			imgCompRate=fmtConv.getResult(ps.imgCompRate);
			transType=fmtConv.getResult(ps.transType);
			equipType=fmtConv.getResult(ps.equipType);
			equipCode=fmtConv.getResult(ps.equipCode);
			powerOnCnt=fmtConv.getResult(ps.powerOnCnt);

			//32
			muNum=fmtConv.getResult(ps.muNum);
			date_year=fmtConv.getResult(ps.date_year);
			date_month=fmtConv.getResult(ps.date_month);
			date_day=fmtConv.getResult(ps.date_day);
			time_hour=fmtConv.getResult(ps.time_hour);
			time_minutes=fmtConv.getResult(ps.time_minutes);
			time_second=fmtConv.getResult(ps.time_second);
			time_m_second=fmtConv.getResult(ps.time_m_second);

			plane_longitude=fmtConv.getResult(ps.plane_longitude);
			plane_latitude=fmtConv.getResult(ps.plane_latitude);
			plane_height=fmtConv.getResult(ps.plane_height);
			aim_height=fmtConv.getResult(ps.aim_height);
			plane_direction_angle=fmtConv.getResult(ps.plane_direction_angle);
			plane_direction_angle_V=fmtConv.getResult(ps.plane_direction_angle_V);
			plane_direction_angle_A=fmtConv.getResult(ps.plane_direction_angle_A);
			plane_div_angle=fmtConv.getResult(ps.plane_div_angle);
			plane_div_angle_V=fmtConv.getResult(ps.plane_div_angle_V);
			plane_div_angle_A=fmtConv.getResult(ps.plane_div_angle_A);
			plane_hr_angle=fmtConv.getResult(ps.plane_hr_angle);
			plane_hr_angle_V=fmtConv.getResult(ps.plane_hr_angle_V);
			plane_hr_angle_A=fmtConv.getResult(ps.plane_hr_angle_A);
			plane_dflight_angle=fmtConv.getResult(ps.plane_dflight_angle);
			plane_dflow_angle=fmtConv.getResult(ps.plane_dflow_angle);
			plane_ground_v=fmtConv.getResult(ps.plane_ground_v);
			plane_noair_v=fmtConv.getResult(ps.plane_noair_v);
			plane_point_v=fmtConv.getResult(ps.plane_point_v);
			plane_east_v=fmtConv.getResult(ps.plane_east_v);
			plane_north_v=fmtConv.getResult(ps.plane_north_v);
			plane_up_v=fmtConv.getResult(ps.plane_up_v);
			plane_east_a=fmtConv.getResult(ps.plane_east_a);
			plane_north_a=fmtConv.getResult(ps.plane_north_a);
			plane_up_a=fmtConv.getResult(ps.plane_up_a);

			//21
			anFrameCode=fmtConv.getResult(ps.anFrameCode);
			waveNum=fmtConv.getResult(ps.waveNum);
			waveCode=fmtConv.getResult(ps.waveCode);
			cFreq=fmtConv.getResult(ps.cFreq);
			lookSide=fmtConv.getResult(ps.lookSide);
			workMode=fmtConv.getResult(ps.workMode);
			workSonMode=fmtConv.getResult(ps.workSonMode);
			RFar=fmtConv.getResult(ps.RFar);
			RNear=fmtConv.getResult(ps.RNear);
			anCenterAngle=fmtConv.getResult(ps.anCenterAngle);
			anScanScope=fmtConv.getResult(ps.anScanScope);
			a_Spot_cAngle=fmtConv.getResult(ps.a_Spot_cAngle);
			a_Spot_Width=fmtConv.getResult(ps.a_Spot_Width);
			a_Scan_step=fmtConv.getResult(ps.a_Scan_step);
	        r_Spot_cAngle=fmtConv.getResult(ps.r_Spot_cAngle);
			r_Spot_Width=fmtConv.getResult(ps.r_Spot_Width);
			r_Scan_step=fmtConv.getResult(ps.r_Scan_step);
			resident_pulse=fmtConv.getResult(ps.resident_pulse);
			resident_time=fmtConv.getResult(ps.resident_time);
			res=fmtConv.getResult(ps.res);
			prf=fmtConv.getResult(ps.prf);	
		}

		void dat6CommonInfo::output(FILE *FL)
		{
			fprintf(FL,"信息标签:%02.0f\n",infoMark);
			fprintf(FL,"数据包长度:%.0f\n",datLen);
			fprintf(FL,"任务代号:%04.0f\n",missionCodes);
			fprintf(FL,"飞行器类型:%.0f\n",planeType);
			fprintf(FL,"飞行批号:%02.0f\n",planeBatNum);
			fprintf(FL,"飞机号:%04.0f\n",planeNum);
			fprintf(FL,"图像压缩比:%03.0f\n",imgCompRate);
			fprintf(FL,"传输方式(0=地面回读,1=实时传输,2=选择传输):%01.0f\n",transType);			
			fprintf(FL,"载荷类型(01-高空CCD,02-长焦倾斜CCD,03-SAR,04-红外行扫仪,05-多光谱):%02.0f\n",equipType);
			fprintf(FL,"载荷编号:%05.0f\n",equipCode);
			fprintf(FL,"开机次数:%03.0f\n",powerOnCnt);

			fprintf(FL,"惯导序号:%05.0f\n",muNum);
			fprintf(FL,"日期(年.月.日):%04.0f.%02.0f.%02.0f\n",date_year,date_month,date_day);
			fprintf(FL,"时间(时:分:秒:毫秒):%02.0f:%02.0f:%02.0f:%03.0f\n",time_hour,time_minutes,time_second,time_m_second);	
			fprintf(FL,"飞机经度(度):%6.7f\n",plane_longitude);
			fprintf(FL,"飞机纬度(度):%.7f\n",plane_latitude);
			fprintf(FL,"飞机海拔高度(米):%.3f\n",plane_height);
			fprintf(FL,"机下点海拔高度(米):%.3f\n",aim_height);
			fprintf(FL,"飞机航向角(度):%.4f\n",plane_direction_angle);
			fprintf(FL,"飞机航向角速率(度/秒):%.4f\n",plane_direction_angle_V);
			fprintf(FL,"飞机航向角加速度(度/平方秒):%.4f\n",plane_direction_angle_A);
			fprintf(FL,"飞机俯仰角(度):%.4f\n",plane_div_angle);
			fprintf(FL,"飞机俯仰角速度(度/秒):%.4f\n",plane_div_angle_V);
			fprintf(FL,"飞机俯仰角加速度(度/平方秒)%.4f\n",plane_div_angle_A);
			fprintf(FL,"飞机横滚角(度):%.4f\n",plane_hr_angle);
			fprintf(FL,"飞机横滚角速度(度/秒):%.4f\n",plane_hr_angle_V);
			fprintf(FL,"飞机横滚角加速度(度/平方秒):%.4f\n",plane_hr_angle_A);
			fprintf(FL,"飞机偏航角(度):%.4f\n",plane_dflight_angle);
			fprintf(FL,"飞机偏流角(度):%.4f\n",plane_dflow_angle);
			fprintf(FL,"地速(米/秒):%f\n",plane_ground_v);
			fprintf(FL,"真空速(米/秒):%f\n",plane_noair_v);
			fprintf(FL,"指示空速(米/秒):%f\n",plane_point_v);
			fprintf(FL,"飞机东速(米/秒):%.4f\n",plane_east_v);
			fprintf(FL,"飞机北速(米/秒):%.4f\n",plane_north_v);
			fprintf(FL,"飞机天速(米/秒):%.4f\n",plane_up_v);
			fprintf(FL,"东向加速度(米/平方秒):%.4f\n",plane_east_a);
			fprintf(FL,"北向加速度(米/平方秒):%.4f\n",plane_north_a);
			fprintf(FL,"天向加速度(米/平方秒):%.4f\n",plane_up_a);

			fprintf(FL,"天线帧编号:%.6f\n",anFrameCode);
			fprintf(FL,"波位数:%.4f\n",waveNum);
			fprintf(FL,"波位号:%.4f\n",waveCode);
			fprintf(FL,"工作频段:%.2f\n",cFreq);
			fprintf(FL,"侧视方式:%.2f\n",lookSide);
			fprintf(FL,"工作模式:%.2f\n",workMode);
			fprintf(FL,"工作子模式:%.2f\n",workSonMode);
			fprintf(FL,"最大作用距离:%.0f\n",RFar);
			fprintf(FL,"最小作用距离:%.0f\n",RNear);
			fprintf(FL,"天线帧扫描中心角:%.4f\n",anCenterAngle);
			fprintf(FL,"天线帧扫描范围:%.4f\n",anScanScope);
			fprintf(FL,"方位波束中心角:%.4f\n",a_Spot_cAngle);
			fprintf(FL,"方位波束宽度:%.4f\n",a_Spot_Width);
			fprintf(FL,"俯仰波束中心角:%.4f\n",r_Spot_cAngle);
			fprintf(FL,"俯仰波束宽度:%.4f\n",r_Spot_Width);
			fprintf(FL,"俯仰向扫描步进:%.4f\n",r_Scan_step);
			fprintf(FL,"驻留脉冲数:%.4f\n",resident_pulse);				
		}



        // ******** WAS-GMTI目标定位求解 2015/11/18 ***********
        NewGYAimInfo::NewGYAimInfo(UINT8* ar)
		{

			lstHeader.gyAimInfoPt=NULL;
			lstHeader.numAll=0;

			NewGYAimInfoPosition ps;
			ps.initial();

			commonFuncs cmFuncs;
			fmtConvCl fmtConv(ar);			
			aimsNum=fmtConv.getBigEndianResult(ps.aimsNum);
			pulseResident=fmtConv.getResult(ps.pulseResident);

			/************************************/
			////cmFuncs.logRecords("",aimsNum);
			GYParsInfo GYPs(ar);
			//广域GMTI目标帧号
			//2015/12/16
			double dbFrameCode=GYPs.frameCodes;
			/*double ftTemp=(double)GYPs.RNear;
			cmFuncs.logRecords("近端距离",ftTemp);
			*/
			/***********************************
			if(aimsNum>60)
			{
				aimsNum = (long(aimsNum)%16);
			}else
			{
				aimsNum = 0;
			}*/

			//相位中值从1024开始
			int mdArsStart=1024; //OK
			stParInFrame vPsTemp;
			vPsTemp.numType=int16Enm;
			vPsTemp.unit=1.0/(8196.0);
			memset(phaseMiddleValue,0,sizeof(double)*GYPHMLENMAX);

			for(int i=0;i<pulseResident;i++)
			{				
				vPsTemp.startPosion=mdArsStart+2*i;
				phaseMiddleValue[i]=fmtConv.getBigEndianResult(vPsTemp);

				//cmFuncs.logRecords("",phaseMiddleValue[i]);
				//cmFuncs.logRecords("中指相位序号：",i);
				//cmFuncs.logRecords("数值：",phaseMiddleValue[i]);
				//fwrite(&phaseMiddleValue[i],sizeof(double),1,FL);
			}
			
			vPsTemp.numType=int16Enm;
			vPsTemp.unit=1;
			int aimParsStart=5120; //4096+512+512 
			if(aimsNum <= 0) return;
			for(int i=0;i<aimsNum;i++)
			{
				//cmFuncs.logRecords("目标参数序号：",i);

				vPsTemp.startPosion=aimParsStart+i*6*2;
				aimPars[i*6]=fmtConv.getBigEndianResult(vPsTemp);
				//cmFuncs.logRecords("I1路通道幅值：",aimPars[i*6]);

				vPsTemp.startPosion=aimParsStart+i*6*2+2;
				//aimPars[i*6+1]=fmtConv.getBigEndianResult(vPsTemp);
				aimPars[i*6+1]=fmtConv.getBigEndianResult(vPsTemp);
				//cmFuncs.logRecords("Q1路通道幅值：",aimPars[i*6+1]);

				vPsTemp.startPosion=aimParsStart+i*6*2+4;
				aimPars[i*6+2]=fmtConv.getBigEndianResult(vPsTemp);
				//cmFuncs.logRecords("I2路通道幅值：",aimPars[i*6+2]);

				vPsTemp.startPosion=aimParsStart+i*6*2+6;
				aimPars[i*6+3]=fmtConv.getBigEndianResult(vPsTemp);
				//cmFuncs.logRecords("",aimPars[i*6+3]);
				//cmFuncs.logRecords("Q2路通道幅值：",aimPars[i*6+3]);

				vPsTemp.startPosion=aimParsStart+i*6*2+8;
				vPsTemp.numType=uInt16Enm;
				aimPars[i*6+4]=fmtConv.getBigEndianResult(vPsTemp);
				aimPars[i*6+4]=long(aimPars[i*6+4])%long(pulseResident);
				//cmFuncs.logRecords("目标方位向位置",aimPars[i*6+4]);

				vPsTemp.startPosion=aimParsStart+i*6*2+10;
				aimPars[i*6+5]=fmtConv.getBigEndianResult(vPsTemp);
				aimPars[i*6+5]=long(aimPars[i*6+5])%32768; //实时处理，数据截断
				//cmFuncs.logRecords("目标距离向位置",aimPars[i*6+5]);
			}

			muInfo  mu(ar);
			sarImageInfo imgInfo(ar);
			GYParsInfo   parsInfo(ar);


			// ******************************************************
			// The following code is dev by Yunhua-Luo without any other functions support
			// Notice :  phaseMiddleValue --- double * 2048
			//           aimPars --- double * aimsNum*6			
			// The following code is dev by Yunhua-Luo
			sys_par pars;
			pars.B_Na = parsInfo.pulseResident; //驻留脉冲数
			if(pars.B_Na > 2048 || pars.B_Na < 256)
			{
				aimsNum=0;
				return;
			}
			pars.R_near = imgInfo.slope_nearest;//最近斜距离
			if(pars.R_near < 30.0e3 || pars.R_near > 200.0e3)
			{
				aimsNum=0;
				return;
			 }
			pars.tar_height = imgInfo.aim_height;
			if(pars.tar_height > 8000.0 || pars.tar_height < 0) 
				pars.tar_height = 1096.0;
			pars.prf = parsInfo.prf;//prf
			if(pars.prf < 0 || pars.prf > 5000) 
			{
				aimsNum=0;
				return;
			}
			pars.az_vel = sqrt(mu.plane_north_v*mu.plane_north_v+mu.plane_east_v*mu.plane_east_v);
			if(pars.az_vel < 100 || pars.az_vel > 300) 
				pars.az_vel = 225.0;
			pars.scan_ang = parsInfo.scanAngle;        // 角度
			//cmFuncs.logRecords("定位波束扫描角：",pars.scan_ang);
			pars.elev_ang = imgInfo.rsAngle;           // 角度
			pars.yaw_ang = mu.plane_departure_angle;   // 角度
			pars.lati = imgInfo.plane_latitude;  //载机纬度
			if(pars.lati < 0 || pars.lati > 90)
			{
				aimsNum=0;
				return;
			 }
			pars.logn = imgInfo.plane_longitude;  //载机经度
			if(abs(pars.logn)> 180)
			{
				aimsNum=0;
				return;
			}

			pars.fly_ang = mu.plane_direction_angle; // 载机航向角-偏航角=真航向（飞机实际飞行方向）
			pars.Fs = (imgInfo.fs*1.0e6);
			pars.href = mu.plane_height;
			if(pars.href > 30000 || pars.href < 0) pars.href = 17000.0;
			pars.lookside = imgInfo.look_Side;  // 左--1，右 -- -1;
			pars.fc = double(9.6e9);
			pars.Br = (parsInfo.band*1.0e6);
			pars.D = 0.384;
			pars.Nr = imgInfo.sampoints;
			if(pars.Nr < 0 || pars.Nr> 100000) 
			{
			    aimsNum=0;
				return;
			}

			// frame_no has problems
			static int myFrameCode = 0;
			static double scan_ang_pre = -90000;
			
			if(pars.scan_ang < scan_ang_pre && scan_ang_pre > 10) myFrameCode++;
			
			cmFuncs.logRecords("波束扫描角：",pars.scan_ang);
			cmFuncs.logRecords("计算帧号：",myFrameCode);

			scan_ang_pre = pars.scan_ang;
			pars.frame_no = myFrameCode % 100; //parsInfo.frameCodes;   // luo 
			pars.wave_no = parsInfo.waveCodes;   // luo 
			
			double *tar_output_info=new double[((int)aimsNum)*INFO_NUM];// 输出定位目标信息
			memset(tar_output_info,0,sizeof(double)*((int)aimsNum)*INFO_NUM);
			//cmFuncs.logRecords("计算帧号1：",myFrameCode);

			double R_near_new = pars.R_near;
			int validnum = WASGmti_locating(phaseMiddleValue,aimPars,aimsNum,pars,&R_near_new,tar_output_info);
			aimsNum = validnum;
			if(validnum == 0) return;
		
			//cmFuncs.logRecords("计算帧号2：",myFrameCode);
			/************************************************/
			int aimsNumInt=(int)aimsNum;			
			lstHeader.numAll=aimsNumInt;
			lstHeader.gyAimInfoPt=NULL;

			gyAimInfoList *lstTempPt1,*lstTempPt2;

			for(int i=0;i<aimsNum;i++)
			{
				lstTempPt2=(gyAimInfoList *)malloc(sizeof(gyAimInfoList));
				if(i==0)
				{
					lstTempPt1=lstHeader.gyAimInfoPt=lstTempPt2;
				}
				else
				{
				lstTempPt1->next=lstTempPt2;
				}
				
				lstTempPt2->aim_velocity=tar_output_info[i*OUT_INFO_NUM];			
				lstTempPt2->tar_r0=tar_output_info[i*OUT_INFO_NUM+1];
				lstTempPt2->tar_azimuth=tar_output_info[i*OUT_INFO_NUM+2];
				lstTempPt2->href=tar_output_info[i*OUT_INFO_NUM+3];
				
				lstTempPt2->aim_latitude=tar_output_info[i*OUT_INFO_NUM+4];
				//cmFuncs.logRecords("目标纬度：",tar_output_info[i*6+4]);
				lstTempPt2->aim_longitude=tar_output_info[i*OUT_INFO_NUM+5];
		
				lstTempPt2->tar_ampl = tar_output_info[i*OUT_INFO_NUM+6];
				lstTempPt2->aim_frame_no = tar_output_info[i*OUT_INFO_NUM+7];
				lstTempPt2->aim_wave_no = tar_output_info[i*OUT_INFO_NUM+8];
				//lstTempPt2->aim_direction = tar_output_info[i*OUT_INFO_NUM+9];

				lstTempPt2->next=NULL;
				lstTempPt1=lstTempPt2;
			}

			delete [] tar_output_info;  // added by luo;

			//cmFuncs.logRecords("计算帧号3：",myFrameCode);

			return;

		}
		
		NewGYAimInfo::~NewGYAimInfo()
		{
            gyAimInfoList * lstDel=lstHeader.gyAimInfoPt;
			while(lstDel!=NULL)
			{
				 gyAimInfoList * Temp=lstDel;
				 lstDel=lstDel->next;

				 delete Temp;
			}

			lstHeader.gyAimInfoPt=NULL;
		}

		int NewGYAimInfo::outputAimInfo(FILE *FL)
		{
			gyAimInfoList * listOutPut=lstHeader.gyAimInfoPt;
			int i=1;

			while(listOutPut!=NULL)
			{		 
				fprintf(FL,"目标编号：%d\n",i);
					 
				fprintf(FL,"目标速度(米/秒)：%f\n",listOutPut->aim_velocity);
					 
				//fprintf(FL,"目标斜距：%f\n",listOutPut->tar_r0);
					 //fprintf(FL,"3dt杂波抑制前目标幅度：%f\n",listOutPut->aimAmp1);
					 //fprintf(FL,"3dt杂波抑制后目标幅度：%f\n",listOutPut->aimAmp1);
					
				//fprintf(FL,"目标方位：%f\n",listOutPut->tar_azimuth);
					
				fprintf(FL,"目标经度：%f(度)\n",listOutPut->aim_longitude);
					 
				fprintf(FL,"目标纬度：%f(度)\n",listOutPut->aim_latitude);
			
				i++;
			
				listOutPut=listOutPut->next;	
			}

			return 0;
		}

		template <class T>
		inline  double NewGYAimInfo::min_val(T *val,__int64 num,__int64 *loc)
		{
			long    i;
			long    min_loc=0;
			double  min_val0;
			if(num<0) return 0.0;
			min_val0=val[0];
			for(i=0;i<num;i++)
			{
				if(val[i]<min_val0) 
				{	  
				min_val0=val[i];
				min_loc=i;
				}
				}
			*loc=min_loc;
			return   min_val0;
		}

		template <class T>
		inline void NewGYAimInfo::CircShift(T *data,long data_len,int mov_shift)
		{// CHECK BY luo
     
		T *buf=new T[data_len];
		if(mov_shift<0) mov_shift+=data_len;
		memcpy(buf+mov_shift,data,sizeof(T)*(data_len-mov_shift)); 
		memcpy(buf,data+data_len-mov_shift,sizeof(T)*(mov_shift));
		memcpy(data,buf,sizeof(T)*data_len);
		delete buf; 
		}

	    template <class T>
	    void NewGYAimInfo::Write2Double(char* file_out,T* pdata,__int64 N)
		{//OK

			FILE * hFile;
			if((hFile = fopen(file_out,"wb")) == NULL)
			{
			printf("Can't open file to read!!!!!\n");
			return;
			}
			__int64 len = fwrite(pdata,sizeof(T),N,hFile);
			fclose(hFile);

		}

        int NewGYAimInfo::Point_Trace(long *Tar_Az,long *Tar_Ra,float *Tar_Amp, float *Tar_ph,long Tar_Num,int win_ra,int win_az)
		{// 点迹凝聚 OK 10/15 CHECK dev by Yunhua-Luo 

			long   m,n,k,Tar_Num_New;
			long   *Tar_Az_temp =new  long[Tar_Num];
			long   *Tar_Ra_temp =new  long[Tar_Num];
			float  *Tar_Amp_temp=new  float[Tar_Num];  
			float  *Tar_Ph_temp =new  float[Tar_Num];  
			k=0;

			for(m=0;m<Tar_Num;m++)
			{
			if(Tar_Amp[m]>0)			
			for(n=0;n<Tar_Num;n++) 
				Tar_Amp[m]*=float(!((abs(Tar_Az[m]-Tar_Az[n])<win_az)&&(abs(Tar_Ra[m]-Tar_Ra[n])<win_ra)&&(Tar_Amp[n]>Tar_Amp[m])&&(m!=n)));
			
			if(Tar_Amp[m]>0) 
			{	
				Tar_Az_temp[k] = Tar_Az[m];
				Tar_Ra_temp[k] = Tar_Ra[m];
				Tar_Amp_temp[k]= Tar_Amp[m];
				Tar_Ph_temp[k] = Tar_ph[m];
				k++;
			}
			}

			Tar_Num_New=k;
			memcpy(Tar_Az,Tar_Az_temp,sizeof(long)*Tar_Num_New);
			memcpy(Tar_Ra,Tar_Ra_temp,sizeof(long)*Tar_Num_New);
			memcpy(Tar_Amp,Tar_Amp_temp,sizeof(float)*Tar_Num_New);
			memcpy(Tar_ph,Tar_Ph_temp,sizeof(float)*Tar_Num_New);
		
			delete []  Tar_Az_temp;
			delete []  Tar_Ra_temp;
			delete []  Tar_Amp_temp; 
			delete []  Tar_Ph_temp;

			return Tar_Num_New;

		}

        template <class T>
        void NewGYAimInfo::BubbleSort(T *pdata,__int64 N,__int64 *pIndex)
{// OK

	__int64 kk,jj,ind;
	T temp;

	for(kk=0; kk<N; kk++)
	{
		pIndex[kk] = kk;
	}

	for(kk=0; kk<N; kk++)
	{
		for(jj=kk+1; jj<N; jj++)
		{
			if(pdata[kk]<pdata[jj])
			{
				temp = pdata[kk];	
				pdata[kk] = pdata[jj];
				pdata[jj] = temp;

				ind = pIndex[kk];
				pIndex[kk] = pIndex[jj];
				pIndex[jj] = ind;
			}
		}
	}
}

        int NewGYAimInfo::WASGmti_locating(double *median_ph_raw, double *tar_info, long tar_num, sys_par par,double *R_near_new,double *tar_output_info)
		{// WAS-GMTI target locating function dev by Yunhua-Luo @ 2015/11/16 v2.0 OK
		 // updated version 2015/12/16 v3.0;
		 // input :
		 // median_ph --- 相位中值 < 2048
		 // tar_info  --- 检测目标信息 tar_num*6
		 // output:  tar_output_info --- 定位后目标的信息

		   commonFuncs cmFuncs;

			long h,m,j,k,l;
			__int64 B_Na = __int64(par.B_Na); //需要判读
			double R_near = par.R_near; // 近端斜距
			double prf = par.prf;  
			if(abs(prf)>3000.0) prf = 1181.0;
			double az_vel = par.az_vel; // 地速
			double scan_ang = par.scan_ang*PI/180.0; // 弧度 波束扫描角
			double elev_ang = par.elev_ang*PI/180.0; // 弧度 俯仰角
			double yaw_ang  = par.yaw_ang*PI/180.0;  // 弧度 载机偏航角
			double lati0 = par.lati;  //载机纬度
			double logn0 = par.logn;  //载机经度
			double fly_ang = par.fly_ang*PI/180.0; // 载机航向角
			double Fs = par.Fs; // 采样率
			if(abs(Fs)<10e6 || abs(Fs)>200e6) Fs = 125.0e6;
			double href = par.href; //载机海拔
			double D = par.D; // 天线长度
			double lookside = par.lookside;  //侧视方向 左--1，右 -- -1;
			double lamda = C/double(par.fc);
			double Br = par.Br;
			double dr = C/2/Fs;
			double df = prf/B_Na;
			double tar_h = par.tar_height;
			long Nr = par.Nr;
			int wave_no = par.wave_no;
			int frame_no = par.frame_no;

			int   win_ra=8,win_az=12;    // 点轨迹凝聚窗大小 8/6 -> 8/16
			float min_vr_was = 2.5;      // can be adjust;
			int   manner = 0;

			double fd_amp = 2.0*az_vel*sin(scan_ang)*sin(fabs(elev_ang))/lamda; // added - by luo OK 
			double *fa = new double[B_Na];
			double fd1 = fd_amp-int(fd_amp/prf)*prf;
			for(h=0;h<B_Na;h++) fa[h] = fd1+h*prf/double(B_Na)-prf/2; 
			double R_near1 = R_near;
			if(Br==25e6) R_near1 = R_near+C/prf/2.0;   //对海模式 	

			// step 1. ---- 点迹凝聚 ------
			printf("Point targets are tracking ...\n");
			long *Tar_Az = new long[tar_num];
			long *Tar_Ra = new long[tar_num];
			float *Tar_Amp = new float[tar_num];
			double *median_ph = new double[B_Na];
			float *Tar_ph = new float[tar_num];
			float *main_borne_ph = new float[B_Na];
			float *temp_ph0 = new float[B_Na];
			float *temp_ph1 = new float[B_Na];
			float *Tar_fa = new float[tar_num];
			double real,imag,PT;

			for(h=0; h<tar_num; h++)
			{
				Tar_Az[h] = (long(tar_info[INFO_NUM*h+4])+B_Na/2)%B_Na;  // azimuth loc fftshift 由于方位图像FFT后没有fftshift，导致位置不对，需要fftshift; 
				Tar_Az[h] = MAX(Tar_Az[h],0);
				Tar_Az[h] = Tar_Az[h]%B_Na;

				Tar_Ra[h] = long(tar_info[INFO_NUM*h+5])%Nr; // range loc 
				Tar_Ra[h] = MAX(Tar_Ra[h],0)%Nr;

				Tar_Amp[h] = sqrt(tar_info[INFO_NUM*h]*tar_info[INFO_NUM*h]+tar_info[INFO_NUM*h+1]*tar_info[INFO_NUM*h+1]);
			
				real = double(tar_info[INFO_NUM*h+0])*tar_info[INFO_NUM*h+2]+double(tar_info[INFO_NUM*h+1])*tar_info[INFO_NUM*h+3];
				imag = double(tar_info[INFO_NUM*h+1])*tar_info[INFO_NUM*h+2]-double(tar_info[INFO_NUM*h+0])*tar_info[INFO_NUM*h+3];
			
				Tar_ph[h]  = atan2(imag,real);  //目标干涉相位

			}// OK

			__int64 check_tarnum = Point_Trace(Tar_Az,Tar_Ra,Tar_Amp,Tar_ph,tar_num,win_ra,win_az);//点轨迹凝聚 OK
			if(check_tarnum<=0) return 0;

			//******* 去掉不合理的点目标 added 2015/11/18 ***********
			int threshold = 30;  // can be adjusted // test
			if(check_tarnum > threshold)
			{
				long   *Tar_Az_temp = new long[check_tarnum];
				long   *Tar_Ra_temp = new long[check_tarnum];
				float  *Tar_Amp_temp= new float[check_tarnum];  
				float  *Tar_Ph_temp = new float[check_tarnum];  
				memcpy(Tar_Az_temp,Tar_Az,sizeof(long)*check_tarnum);
				memcpy(Tar_Ra_temp,Tar_Ra,sizeof(long)*check_tarnum);
				memcpy(Tar_Amp_temp,Tar_Amp,sizeof(float)*check_tarnum);
				memcpy(Tar_Ph_temp,Tar_ph,sizeof(float)*check_tarnum);

				__int64 *index = new __int64[check_tarnum];
				BubbleSort(Tar_Amp,check_tarnum,index);  // 按照能量大小排序
				check_tarnum = check_tarnum%threshold;
				for(h=0; h<check_tarnum;h++)
				{
					Tar_Az[h]  = Tar_Az_temp[index[h]];
					Tar_Ra[h]  = Tar_Ra_temp[index[h]];
					Tar_Amp[h] = Tar_Amp_temp[index[h]];
					Tar_ph[h]  = Tar_Ph_temp[index[h]];
				}
				delete [] index;
				delete [] Tar_Az_temp;
				delete [] Tar_Ra_temp;
				delete [] Tar_Amp_temp;
				delete [] Tar_Ph_temp;
			}

			for(k=0;k<check_tarnum;k++) 
			{
				Tar_fa[k]=fa[*(Tar_Az+k)]+int(fd_amp/prf)*prf;
			}

			// step 2 目标定位
			printf("Moving targets are locating ...\n");
			long az_cen = (prf/2.0-fd1)*float(B_Na)/prf;
			az_cen = az_cen%B_Na; //added code ;
			CircShift(fa,B_Na,B_Na/2-az_cen);  // -- fftshift --

			double Bd1 = 2*az_vel/D*cos(scan_ang+yaw_ang)*0.886;  // OK
			Bd1 = MIN((Bd1*1.2),(prf*0.7));
			int dop_num = MAX((int(Bd1/prf*B_Na/2)*2),(B_Na*0.7));
			dop_num = MIN(dop_num,B_Na);
			Bd1 = prf*dop_num/double(B_Na);
			
			static int frame_no_pre = 1;

			if( frame_no < 0 || frame_no > 10000) frame_no = frame_no_pre;
			frame_no_pre = frame_no;

			float tar_fdc,Rg,Y_WD_t,X_JD_t;
			double lati,logn;
	
			// 求取主瓣干涉相位;
			CircShift(median_ph_raw,B_Na,B_Na/2);  // image fftshift

			for(h=0; h<B_Na; h++) median_ph[h] = 99.9;
			int mainborne_up = B_Na-1;
			int mainborne_down = 0;
			for(h=0; h<B_Na; h++)
			{
				if(fabs(fa[h]-fd1)>(Bd1/2.0)) continue;// 搜素主瓣外相位 
				median_ph[h] = median_ph_raw[h]; // ok
			}

			for(h=0; h<B_Na-1; h++)
			{
				if((median_ph[h]< 2*PI) && (median_ph[h+1] > 90.0)) {mainborne_up=h; break;}   
			}
			for(h=1; h<B_Na; h++)
			{
				if((median_ph[h-1] > 90.0) && (median_ph[h] < 2*PI)) {mainborne_down=h; break;}   
			}
	  
			// ********* 求取目标干涉相位并完成定位 *************
			for(h=0;h<B_Na;h++) fa[h] += int(fd_amp/prf)*prf;  // Real doppler frequency
			long tar_validnum = 0;
			float v1,v2,v3,v_min;
			double tar_vr,tar_r0,tar_azimuth,phi_t,tar_ampl;
			__int64 loc,loc1,loc2;


			for(h=0;h<check_tarnum;h++) 
			{
				PT = Tar_ph[h];	

				//--- 如果中值相位合理，需要根据中值相位进行判读来进行定位 ---
				tar_fdc = az_vel/(PI*D)*PT+fd_amp;  // simple way to locating 

				// 定位后的目标多普勒位置
				if((fabs(Tar_fa[h]-tar_fdc) < int(2*min_vr_was/lamda/df)) || (fabs(Tar_fa[h]-tar_fdc) > (B_Na-int(2*min_vr_was/lamda/df)))) continue; // 最小速度限制
		
				tar_vr  = (Tar_fa[h]-tar_fdc)*lamda/2.0;	// 靠近航线为正，否则为负
				tar_r0  = R_near1+Tar_Ra[h]*dr;				// 目标斜距			
				phi_t   = acos(href/tar_r0);				//目标对应的俯仰角 单位幅度
				tar_azimuth = asin(tar_fdc*lamda/2/az_vel/sin(phi_t)); //目标方位角
				tar_ampl = Tar_Amp[h];

				if(fabs(tar_azimuth - scan_ang)>1.8*PI/180) continue;

				double yaw_ang_res = 0.6*PI/180.0;

				Rg = sqrt(tar_r0*tar_r0-href*href);	
				X_JD_t = -Rg*lookside*cos((-tar_azimuth+fly_ang-yaw_ang_res)*lookside); // fly_ang-yaw_ang == true_fly_ang
				Y_WD_t = Rg*sin((-tar_azimuth+fly_ang-yaw_ang_res)*lookside);			// notice tar_azimuth +-  

				// 判读定位是否合理
				lati = lati0 + double(Y_WD_t)/double(111693.1);
				logn = logn0 + double(X_JD_t)/double(111693.1)/cos(lati0*PI/180);  // notice

				//lati = lati0 + Y_WD_t/60.0/1852.0;
				//logn = logn0 + X_JD_t/60.0/1852.0/cos(lati0*PI/180);  // notice 

				// ************ output results *****************
				tar_output_info[OUT_INFO_NUM*tar_validnum]   = tar_vr;
				tar_output_info[OUT_INFO_NUM*tar_validnum+1] = tar_r0;
				tar_output_info[OUT_INFO_NUM*tar_validnum+2] = tar_azimuth;
				tar_output_info[OUT_INFO_NUM*tar_validnum+3] = tar_h;
				tar_output_info[OUT_INFO_NUM*tar_validnum+4] = lati;
				tar_output_info[OUT_INFO_NUM*tar_validnum+5] = logn;
				tar_output_info[OUT_INFO_NUM*tar_validnum+6] = tar_ampl;
				tar_output_info[OUT_INFO_NUM*tar_validnum+7] = abs(frame_no) > 10000 ? 0:frame_no ;
				tar_output_info[OUT_INFO_NUM*tar_validnum+8] = wave_no;
				//tar_output_info[OUT_INFO_NUM*tar_validnum+8] = ;

				tar_validnum++;
			}

			// delete 
			delete [] Tar_Az; 
			delete [] Tar_Ra; 
			delete [] fa;
			delete [] Tar_Amp;
			delete [] median_ph;
			delete [] Tar_ph;
			delete [] main_borne_ph;
			delete [] Tar_fa;
			delete [] temp_ph0;
			delete [] temp_ph1;

			return tar_validnum;
			// OK check by Yunhua-Luo v1.0
		}


		// ********** WAS-GMTI 目标信息解析类 ************
		GYAimInfo::~GYAimInfo()
		{
		  gyAimInfoList *lstTemp2,*lstTemp2Nxt;
		  lstTemp2=lstHd2.gyAimInfoPt;
		  lstTemp2Nxt=NULL;
		  while(lstTemp2!=NULL)
		  {
			  lstTemp2Nxt=lstTemp2->next;
			  free(lstTemp2);
			  lstTemp2=lstTemp2Nxt;
		  }

          delete []aimRangeNumFr;
		  delete []aimDoplerNumFr;
		  delete []aim3DtPrFr;
		  delete []aim3DtNxFr;
		  delete []aimAzimuthAngleFr;


		  delete []aimRangeNum;
	      delete []aimDoplerNum;
	      delete []aim3DtPr;
	      delete []aim3DtNx;
	      delete []aimAzimuthAngle;
	
		}
		//lstHd1中的距离门号和多普勒号，在本版本中的计算中没有什么实际作用；
		//但是不知其以后是否会有新的变动，此处就依照所给的matlab这样冗余吧。
		
		//目标凝聚
		int GYAimInfo::aimAgglomerate()
{// check by Yunhua-Luo @ 07/22

			int powPar=2;
			int rangleCell  = 8; // 25  modified by Luo 07/22
			int dopplerCell = 16; // 10 modified by Luo 07/22

			gyAimInfoList *lstTemp1=NULL;
			gyAimInfoList *lstTemp1Pre=NULL;
			gyAimInfoList *lstTemp2=NULL;
			gyAimInfoList *lstTemp2Pre=NULL;

			for(int i=0;i<aimsNum;i++)
			{
				for(int j=0;j<aimsNum;j++)
				{
					int aimDopDiff=abs(aimDoplerNum[i]-aimDoplerNum[j]);
					int aimRangeDiff=abs(aimRangeNum[i]-aimRangeNum[j]);

					if((aimDopDiff<=dopplerCell)&&(aimRangeDiff<=rangleCell))
					{
						lstTemp1=(gyAimInfoList *)malloc(sizeof(gyAimInfoList));
						lstTemp1->aimsNum=j;

						//程序的数据类型需要确认和审核
						lstTemp1->aimDopNum = aimDoplerNum[j];
						lstTemp1->aimRangeNum = aimRangeNum[j];
						lstTemp1->aimInterPhase = aimAzimuthAngle[j];
						lstTemp1->aimAmp1=aim3DtPr[j];
						lstTemp1->aimAmp2=aim3DtNx[j];
						lstTemp1->next=NULL;

						if(lstHd1.numAll==0)
						{
							lstHd1.gyAimInfoPt=lstTemp1;
							lstTemp1Pre=lstTemp1;
						}
						else
						{
						    lstTemp1Pre->next=lstTemp1;
						    lstTemp1Pre=lstTemp1;
						}
						lstHd1.numAll++;
					}
				}

				if(lstHd1.numAll>0)
				{

					lstTemp1=lstHd1.gyAimInfoPt;
					double Max=pow(lstTemp1->aimAmp1,powPar);
					lstTemp1=lstTemp1->next;

					while(lstTemp1!=NULL)
					{
						double whTemp=pow(lstTemp1->aimAmp1,powPar);
						if(Max<whTemp)
						{
							Max=whTemp;
						}
						lstTemp1=lstTemp1->next;
					}

					if(Max==pow((double)(aim3DtPr[i]),powPar))
					{
						lstTemp2=(gyAimInfoList *)malloc(sizeof(gyAimInfoList));
						lstTemp2->aimDopNum=aimDoplerNum[i];
						lstTemp2->aimRangeNum=aimRangeNum[i];
						lstTemp2->aimInterPhase=aimAzimuthAngle[i];
						lstTemp2->aimAmp1=aim3DtPr[i];
						lstTemp2->aimAmp2=aim3DtNx[i];
						lstTemp2->next=NULL;

						if(lstHd2.numAll==0)
						{
							lstHd2.gyAimInfoPt=lstTemp2;
							lstTemp2Pre=lstTemp2;
						}
						else
						{
							lstTemp2Pre->next=lstTemp2;
							lstTemp2Pre=lstTemp2;
						}
						lstHd2.numAll++;
					}
				
					lstTemp1=lstHd1.gyAimInfoPt->next;
					delete lstHd1.gyAimInfoPt;
					while(lstTemp1!=NULL)
					{
						lstHd1.gyAimInfoPt=lstTemp1;
						lstTemp1=lstTemp1->next;
					    delete lstHd1.gyAimInfoPt;
					}
					lstTemp1Pre=lstTemp1=lstHd1.gyAimInfoPt=NULL;
					lstHd1.numAll=0;
				}

			}
			aimAggNum=lstHd2.numAll;
			return aimAggNum;
		}
		
		// 目标定位求解
		int GYAimInfo::aimIntAngle()
{// check by Yunhua-Luo @ 07/22

			double d=0.384;
			double lamda=0.03125;
			double H = plane_aim_height; // 载机到目标的高度
			double R0 = slope_nearest; // 近端斜距
			double deltaR=deltaRG; // 距离采样间隔
			double deltaF=deltaFG; //频率间隔 PRF/脉冲驻留数
			int pulseNum=pulseNumG; // 脉冲驻留数
			double min_vr_was = 1.5; // 最小可检测速度；
			
			double angleExp = 0; //-2.3824;	// set to 0	
			double angleExp2= 0;
			
			double v = sqrt(plane_east_v*plane_east_v+plane_north_v*plane_north_v);
			double addBelow = 2*PI*d*sin(fabs(elevationAngle))*sin(azimuthAngle)/lamda;
			//double addBelow = 2*PI*d*sin(fabs(elevationAngle))*sin(azimuthAngle-yawAngle)/lamda; // test code
			
			gyAimInfoList * listRgDopTemp=lstHd2.gyAimInfoPt;

			while(listRgDopTemp!=NULL)
			{
				// initial value ; 
				listRgDopTemp->aimInterAngle = 0.0;

				double interPhsTemp = listRgDopTemp->aimInterPhase;
				angleExp2 = int(addBelow/2/PI+0.5)*2*PI+interPhsTemp;	// 目标实际的相位
				double tar_psi = acos(angleExp2*lamda/2/PI/d);			// 求解目标所对应的锥角；
				double dbTemp = -acos((H/(R0+deltaR*listRgDopTemp->aimRangeNum)));//目标对应的俯仰角
				double dbResTemp1 = asin(cos(tar_psi)/sin(dbTemp));// 目标对于的方位角
				//单位：弧度
				double fdTemp = 2*v*sin(dbResTemp1-yawAngle)*sin(fabs(dbTemp))/lamda;
				double fdDvdDtF=fdTemp/deltaF; // 多普勒通道号

				int FL_fdDvdDtF = floor(fdDvdDtF);
				int CL_fdDvdDtF = ceil(fdDvdDtF);
				int fdDvdDtFRes = (abs(fdDvdDtF-FL_fdDvdDtF)<abs(CL_fdDvdDtF-fdDvdDtF))?FL_fdDvdDtF:CL_fdDvdDtF; // 校正后的多普勒通道号
				int dop_num = fdDvdDtFRes+pulseNum/2;

				int modTempMd1=0;
				if(dop_num==0||dop_num==pulseNum) modTempMd1=1;
				dop_num = (dop_num-modTempMd1) % pulseNum + modTempMd1;  // 定位后目标所在多普勒通道号(-prf/2,prf/2);
			
				int dop_num_pre = (listRgDopTemp->aimDopNum+pulseNum/2) % pulseNum; // 由于没有快视没有fftshift,需要位移；
				if(prf==ERROR_Value) 
				{

					return 0;
				}
				if((abs(dop_num-dop_num_pre)*deltaF < int(2*min_vr_was/lamda/deltaF)) || (abs(dop_num-dop_num_pre)*deltaF > (pulseNum-int(2*min_vr_was/lamda/deltaF)))) 
				{
					listRgDopTemp->aim_velocity = 999999.0;
					listRgDopTemp=listRgDopTemp->next;
					continue; // 最小速度限制
				}

						
				listRgDopTemp->aimPostDopNum = dop_num;
				listRgDopTemp->aim_velocity  = (dop_num_pre-dop_num)*deltaF*lamda/2.0;
				listRgDopTemp->aimInterAngle = dbResTemp1;

				listRgDopTemp=listRgDopTemp->next;
			}

			return 0;

}

	    int GYAimInfo::parsTrans()
{// aim locating 0722 modified by Yunhua-Luo

		double  Az_angle, Az_shift, diju, Az_angle_R,R0;
		double  X_JD_t, Y_WD_t,d2H;

		d2H=PI/180;
		gyAimInfoList * listOutPut=lstHd2.gyAimInfoPt;
		double yaw_ang_res = 0.6*PI/180.0;

		while(listOutPut!=NULL )
		{
			R0=slope_nearest+listOutPut->aimRangeNum*(1/(fs*1.0e6))*C_LIGHT/2;	//目标斜距  近端斜距+
			Az_angle =listOutPut->aimInterAngle;//目标角度
            Az_shift =R0*sin(Az_angle); //
		
            diju = sqrt(R0*R0 - plane_height*plane_height);
            //Az_angle_R = asin(Az_shift/diju); // Raw code 
			Az_angle_R = atan(Az_shift/diju); // modified by Luo;

			// look_Side : left -- 1, right --- -1; 
			X_JD_t = -diju*look_Side*cos(Az_angle+(plane_direction_angle-yaw_ang_res*180.0/PI)*PI/180.0*look_Side);
			Y_WD_t = diju*sin(Az_angle+(plane_direction_angle-yaw_ang_res*180.0/PI)*PI/180.0*look_Side);

			//X_JD_t = -diju*look_Side*cos(Az_angle+plane_direction_angle*PI/180.0*look_Side);
			//Y_WD_t = diju*sin(Az_angle+plane_direction_angle*PI/180.0*look_Side);
			listOutPut->aim_longitude = plane_longitude + X_JD_t/60.0/1852.0/cos(plane_latitude*PI/180); //经度 //modified by Yunhua-Luo
            listOutPut->aim_latitude  = plane_latitude + Y_WD_t/60.0/1852.0;    //纬度




			listOutPut=listOutPut->next;
		 } 


		return 0;

}

		int GYAimInfo::output(FILE *FL)
		{
			gyAimInfoList * listOutPut=lstHd2.gyAimInfoPt;
			int i=1;

			while(listOutPut!=NULL)
			{

				if(listOutPut->aim_velocity<1000 && abs(listOutPut->aim_longitude)<360)
				{
					 fprintf(FL,"目标编号：%d\n",i);
					 fprintf(FL,"目标距离门号：%d\n",listOutPut->aimRangeNum);
					 fprintf(FL,"目标多普勒通道号：%d\n",listOutPut->aimDopNum);
					 //fprintf(FL,"3dt杂波抑制前目标幅度：%f\n",listOutPut->aimAmp1);
					 //fprintf(FL,"3dt杂波抑制后目标幅度：%f\n",listOutPut->aimAmp1);
					 fprintf(FL,"目标干涉角：%f(度)\n",listOutPut->aimInterAngle*180/PI);
					 fprintf(FL,"目标经度：%f(度)\n",listOutPut->aim_longitude);
					 fprintf(FL,"目标纬度：%f(度)\n",listOutPut->aim_latitude);
				}
			 i++;
			 listOutPut=listOutPut->next;
			}
			///************************************************/	  
			//for(UINT32 i=0;i<aimsNum;i++)
			//{

			//fprintf(FL,"start*******************");
			//fprintf(FL,"目标编号：%d\n",(i+1));
			//fprintf(FL,"目标距离门号：%d\n",aimRangeNum[i]);
			//fprintf(FL,"目标多普勒通道号：%d\n",aimDoplerNum[i]);
			//fprintf(FL,"3dt杂波抑制前目标幅度：%d\n",aim3DtPr[i]);
			//fprintf(FL,"3dt杂波抑制后目标幅度：%d\n",aim3DtNx[i]);
			//fprintf(FL,"目标方位角：%f\n",aimAzimuthAngle[i]);
   //         fprintf(FL,"%d %d %f %d %d\n",aim3DtPr[i],aim3DtNx[i],aimAzimuthAngle[i],aimDoplerNum[i],aimRangeNum[i]);
			//fprintf(FL,"end*******************");
			//}
		    ///************************************************/	
			return 0;
		}

		int GYAimInfo::GeoMapOutPut(FILE * FL)
		{
		   static float cntCodes=0;
		   double   *Tar_Info;
		   int       info_num=7;
		   int       aimNums=0;

		   aimNums=lstHd2.numAll;
		 /*if((aimNums=lstHd2.numAll)==0);
		   {
			   return -1;
		   }*/
		   float    *Tar_Output=new float[aimNums*info_num];
		   float     fscan_buf[8];
		   char      mark_file[256];
		   FILE     *fid;
			int      Tar_Loc;
			double   *tar[7],*tar_back[7],*TarA,*trace_mat;
	        double   *RO;


			gyAimInfoList * listOutPut=lstHd2.gyAimInfoPt;
			int h=0;

			while(listOutPut!=NULL)
			{
			   Tar_Loc=h*info_num;
			   Tar_Output[Tar_Loc+0]=(float)(cntCodes+1);              //序号
			   Tar_Output[Tar_Loc+1]=(float)listOutPut->aim_longitude;  //经度
			   Tar_Output[Tar_Loc+2]=(float)listOutPut->aim_latitude;  //纬度
			   Tar_Output[Tar_Loc+3]=(float)1;                        ///扫Α描时间
			   Tar_Output[Tar_Loc+4]=(float)0; ///观测波位号？？？
			   Tar_Output[Tar_Loc+5]=(float)0;//Tar_Info[Tar_Loc+4];//目标径向速度
			   Tar_Output[Tar_Loc+6]=(float)0;//(Tar_Info[Tar_Loc+4]>0)*180;
			   /*if((h%8)==0)
			     {
				   printf("     ");
				   for(m=0;m<info_num;m++)	 printf("%5.2f",Tar_Output[Tar_Loc+m]);
			       printf("\n");
			      }  
			   */
			   
			 h++;
			 cntCodes++;
			 listOutPut=listOutPut->next;
			}

		    ///////////////////output no trace tar infomation///////////////////////
			//fwrite(
			int cntTemp=fwrite(Tar_Output,sizeof(float),info_num*aimNums,FL);
			//////////////output  trace tar infomation///////////////////
			///////////////////////////////////////////////////////
	
           delete  [] Tar_Output;

		   return 0;
		}



		// ********* 航迹关联类函数实现 *****************
		NewGYLineInfo::NewGYLineInfo(UINT8 *arIn)
		{
			ar=arIn;
			linePathHeader.gyPathPt=NULL;
			linePathHeader.pathNum=0;
		}
		
		NewGYLineInfo::~NewGYLineInfo()
		{

		}

		void NewGYLineInfo::flightPathCon()
		{// rewrite by Yunhua-Luo @2015/12/25

			commonFuncs cmFuncs;
			NewGYAimInfo gyNewAim(ar);
			gyAimInfoList* aimPtTemp=NULL;
			int aimsNumInt=(int)gyNewAim.aimsNum;

			if(aimsNumInt<1)
			{
				return;
			}
			aimPtTemp = gyNewAim.lstHeader.gyAimInfoPt;
			MT_relate_XL(aimPtTemp,aimsNumInt);
		
		}

		void NewGYLineInfo::outPutLineTxt(FILE * FL)
		{
			gyPathList *pp=linePathHeader.gyPathPt;

		   while(pp!=NULL)
			{		 
				fprintf(FL,"航迹批号：%d\n",pp->Id);
				fprintf(FL,"目标经度：%f(度)\n",pp->Longitude);
				fprintf(FL,"目标纬度：%f(度)\n",pp->Latitude);
				fprintf(FL,"目标高度：%f\n",pp->Velocity);
				fprintf(FL,"目标速度(米/秒)：%f\n",pp->Velocity);
				fprintf(FL,"目标方向(米/秒)：%f\n",pp->Velocity);
				fprintf(FL,"新批标识(米/秒)：%f\n",pp->Velocity);
				fprintf(FL,"目标属性(米/秒)：%f\n",pp->Velocity);
			
				pp=pp->Next;	
			}

			return;
		}

		// ******** added by Luo **********
		bool NewGYLineInfo::MovingTar_Relate(Node *mynode, long tar_num, bool beFirstBat)
		{// Moving target track relate baisc function 
		 // Dev by Yunhua-Luo @ 2015/12/20-12/27 OK
		 // check 2016/1/15

		 // cur_bat_no --- 当前的周期号
		 // mynode     --- 每个波位的目标集合（相邻的可能在一个周期）
		 // tar_num    --- 波位中目标个数

			commonFuncs cmFuncs;
			AxisCal ax;
			GYParsInfo gypar(ar);

			dotPathNum = 0;
			char *outfile_dat = "d:\\DZS_HJ_XL.dat";
			
			FILE *fid_txt;
			FILE *fid_dat;

			double var_y = 100*100;
			double var_x = 100*100; // 100- X,Y measure error;
			double scanCycle = gypar.scanCycle;

			int cur_frame_no = mynode[0].frame_no;
			double RANGE_MIN = gypar.scanCycle*VR_MIN;
			double RANGE_MAX = gypar.scanCycle*VR_MAX;
			if(RANGE_MIN < 0 || RANGE_MIN > 1000) RANGE_MIN = 100;
			if(RANGE_MAX < 0 || RANGE_MAX > 10000) RANGE_MAX = 1000;

			double RG_THRESHOLD = 1000;//(RANGE_MIN+RANGE_MAX)/2;
			double EST_ERR = 500;//abs(RG_THRESHOLD-RANGE_MIN);

			cmFuncs.logRecords("frame_no :",cur_frame_no);

			if((fid_dat = fopen(outfile_dat,"wb"))==NULL)  return true;
			if((fid_txt = fopen(HJ_filePath,"a")) == NULL) return true;
			
			if(cur_frame_no>3) fprintf(fid_txt,"\n\n*********** Scan-Frame No %d ************\n",cur_frame_no);
			if(abs(cur_frame_no) > 10000) return true; 

			static long list_num = 0;
			static list *mylist = NULL;
			
			// ready 
			long kk,jj;
			double range,rg;
			if(beFirstBat) // first batch
			{
				if(mylist!=NULL) { delete [] mylist; mylist = NULL;}
				mylist = new list[MAX_LIST_NUM];
				if(mylist == NULL) 
				{
					fclose(fid_dat);
					fclose(fid_txt);
					dotPathNum = 0;
					return false;
				}

				for(kk=0; kk<tar_num; kk++)
				{
					mynode[kk].is_related = true;
					mylist[kk].CreateNodeList(&mynode[kk]);
					mylist[kk].T_SCAN = scanCycle;
					mylist[kk].is_update = false;
				}
				list_num = tar_num;
			}
	
			// the other batch 
			double list_dir,next_dir;
			double min_range,real_range;
			long ind_min,list_len;
			if(!beFirstBat)
			{
				min_range = 100000;
				for(jj=0; jj<list_num; jj++)
				{
					// ******* condition 1 *********
					if(mylist[jj].head == NULL) continue;  // un-valid list 

					list_len = mylist[jj].GetLength();
					// ******* condition 2  build track *********
					if(list_len ==1)  // list with length 1
					{
						min_range = 100000;
						for(kk=0; kk<tar_num; kk++)
						{
							if(mylist[jj].tail->frame_no == (mynode[kk].frame_no-1) && 
							abs(mylist[jj].tail->lati-mynode[kk].lati)<0.02 &&
							abs(mylist[jj].tail->logn-mynode[kk].logn)<0.02 &&
							(mynode[kk].is_used==false))
							{
								real_range = ax.RangeCalByGPS(mylist[jj].head->lati,mylist[jj].head->logn,mynode[kk].lati,mynode[kk].logn);
								rg = abs(real_range - RG_THRESHOLD);
								if(rg < min_range) {min_range = rg;ind_min = kk;}
							}
						}
					}
					

					// ******* condition 3 Track confirm *********
					if(list_len >= 2)  // list with length 2
					{
					    mylist[jj].PredictNext();
						// mylist[jj].KalmanPredict();  // wait for test
						list_dir = ax.CalDirection(mylist[jj].tail->lati,mylist[jj].tail->logn,mylist[jj].next_tail->lati,mylist[jj].next_tail->logn);
						min_range = 100000;
						for(kk=0; kk<tar_num; kk++)
						{
							if(mylist[jj].tail->frame_no == (mynode[kk].frame_no-1) && 
							abs(mylist[jj].next_tail->lati-mynode[kk].lati)<0.02 &&
						    abs(mylist[jj].next_tail->logn-mynode[kk].logn)<0.02 &&
							(mynode[kk].is_used==false))
							{
								next_dir = ax.CalDirection(mylist[jj].tail->lati,mylist[jj].tail->logn,mynode[kk].lati,mynode[kk].logn);
								mynode[kk].tar_direction = next_dir;

								if(abs(next_dir-list_dir) < 60)
								{
									range = ax.RangeCalByGPS(mylist[jj].next_tail->lati,mylist[jj].next_tail->logn,mynode[kk].lati,mynode[kk].logn);
									rg = abs(range-RG_THRESHOLD);
									if(rg < min_range) {min_range = rg;ind_min = kk;}
								}
							}
						}
					}

					// 保证轨迹关联只在相邻批次
					if(mylist[jj].tail->frame_no == (cur_frame_no-1))
					{
						if(min_range < EST_ERR)
						{
							mynode[ind_min].is_real = true;
							mynode[ind_min].is_used = true;
							mynode[ind_min].is_related = true;
							mylist[jj].AddNode(&mynode[ind_min]); //关联标记位 / 标记
							mylist[jj].is_update = true;
				
						}else if(mylist[jj].GetLength() >= 2)
						{	
							Node *node_est = mylist[jj].next_tail;
							node_est->is_real = false;
							mylist[jj].AddNode(node_est);		  //关联标记位 / 标记估计位
							mylist[jj].is_update = true;
						}
					}
				}
		

				// judge list weight and output 
				int len;
				for(jj=0; jj<list_num; jj++)
				{
					len = mylist[jj].GetLength();

					// delete unvalid list;
					if((len==1) && (cur_frame_no > (mylist[jj].head->frame_no+2))) 
					{
						mylist[jj].ListDestroy();
					}

					if(len>3)
					{
						// condition is very important 
						if(mylist[jj].CalListWeight() >= TH_VALUE || len > 15 || len > cur_frame_no+1) 
						{
							mylist[jj].ListDestroy();
						}
						else
						{
							// ----- 航迹输出 -----
							mylist[jj].Output(fid_txt,fid_dat,jj,len);
							dotPathNum++;
						}
					}
				}


				// ********** Create new list ***************
				for(jj=0; jj<tar_num; jj++)
				{
					if(mynode[jj].is_related) continue;

					mynode[jj].is_related = true;
					mylist[list_num++].CreateNodeList(&mynode[jj]);
					mylist[kk].T_SCAN = scanCycle;
					mylist[kk].is_update = false;

					if(list_num > MAX_LIST_NUM)
					{
						list_num=0;
						delete [] mylist;
						mylist = NULL;
						dotPathNum = 0;
						fclose(fid_dat);
						fclose(fid_txt);

						return false;
					}
				}

			}

		fclose(fid_dat);
		fclose(fid_txt);

		return true;

		}
		
		bool NewGYLineInfo::MovingTar_Relate_New(Node *mynode, long tar_num, bool beFirstBat)
		{// Moving target track relate baisc function 
		 // Dev by Yunhua-Luo @ 2015/12/20-12/27 OK
		 // check 2016/1/15

		 // cur_bat_no --- 当前的周期号
		 // mynode     --- 每个波位的目标集合（相邻的可能在一个周期）
		 // tar_num    --- 波位中目标个数

			commonFuncs cmFuncs;
			AxisCal ax;
			GYParsInfo gypar(ar);

			dotPathNum = 0;
			char *outfile_dat = "d:\\DZS_HJ_XL.dat";
			
			FILE *fid_txt;
			FILE *fid_dat;

			double var_y = 100*100;
			double var_x = 100*100; // 100- X,Y measure error;
			double scanCycle = gypar.scanCycle;

			int cur_frame_no = mynode[0].frame_no;
			double RANGE_MIN = gypar.scanCycle*VR_MIN;
			double RANGE_MAX = gypar.scanCycle*VR_MAX;
			if(RANGE_MIN < 0 || RANGE_MIN > 1000) RANGE_MIN = 100;
			if(RANGE_MAX < 0 || RANGE_MAX > 10000) RANGE_MAX = 1000;

			double RG_THRESHOLD = 1000;//(RANGE_MIN+RANGE_MAX)/2;
			double EST_ERR = 500;//abs(RG_THRESHOLD-RANGE_MIN);

			cmFuncs.logRecords("frame_no :",cur_frame_no);

			if((fid_dat = fopen(outfile_dat,"wb"))==NULL)  return true;
			if((fid_txt = fopen(HJ_filePath,"a")) == NULL) return true;
			
			if(cur_frame_no>3) fprintf(fid_txt,"\n\n*********** Scan-Frame No %d ************\n",cur_frame_no);
			if(abs(cur_frame_no) > 10000) return true; 

			static long list_num = 0;
			static list *mylist = NULL;
			
			// ready 
			long kk,jj;
			double range,rg;
			if(beFirstBat) // first batch
			{
				if(mylist!=NULL) { delete [] mylist; mylist = NULL;}
				mylist = new list[MAX_LIST_NUM];
				if(mylist == NULL) 
				{
					fclose(fid_dat);
					fclose(fid_txt);
					dotPathNum = 0;
					return false;
				}

				for(kk=0; kk<tar_num; kk++)
				{
					mynode[kk].is_related = true;
					mylist[kk].CreateNodeList(&mynode[kk]);
					mylist[kk].T_SCAN = scanCycle;
				}
				list_num = tar_num;
			}
	
			// the other batch 
			double list_dir,next_dir;
			double min_range,real_range;
			long ind_min,list_len;
			if(!beFirstBat)
			{
				min_range = 100000;
				for(jj=0; jj<list_num; jj++)
				{
					// ******* condition 1 *********
					if(mylist[jj].head == NULL) continue;  // un-valid list 

					list_len = mylist[jj].GetLength();
					// ******* condition 2  build track *********
					if(list_len ==1)  // list with length 1
					{
						min_range = 100000;
						for(kk=0; kk<tar_num; kk++)
						{
							if(mylist[jj].tail->frame_no == (mynode[kk].frame_no-1) && 
							abs(mylist[jj].tail->lati-mynode[kk].lati)<0.02 &&
							abs(mylist[jj].tail->logn-mynode[kk].logn)<0.02 && (mynode[kk].is_used==false))
							{
								real_range = ax.RangeCalByGPS(mylist[jj].head->lati,mylist[jj].head->logn,mynode[kk].lati,mynode[kk].logn);
								rg = abs(real_range - RG_THRESHOLD);
								if(rg < min_range) {min_range = rg;ind_min = kk;}
							}
						}
					}
					

					// ******* condition 3 Track confirm *********
					if(list_len >= 2)  // list with length 2
					{
						// mylist[jj].KalmanPredict();  // wait for test
						Node* preTail = (Node *)malloc(sizeof(Node));
						mylist[jj].GetPreTail(preTail);
						list_dir = ax.CalDirection(mylist[jj].tail->lati,mylist[jj].tail->logn,preTail->lati,preTail->logn); // test code 
						free(preTail);
						min_range = 100000;
						for(kk=0; kk<tar_num; kk++)
						{
							if(mylist[jj].tail->frame_no == (mynode[kk].frame_no-1) && 
							abs(mylist[jj].next_tail->lati-mynode[kk].lati)<0.02 &&
						    abs(mylist[jj].next_tail->logn-mynode[kk].logn)<0.02 &&
							(mynode[kk].is_used==false))
							{
								next_dir = ax.CalDirection(mylist[jj].tail->lati,mylist[jj].tail->logn,mynode[kk].lati,mynode[kk].logn);
								mynode[kk].tar_direction = next_dir;

								if(abs(next_dir-list_dir) < 60)
								{
									range = ax.RangeCalByGPS(mylist[jj].tail->lati,mylist[jj].tail->logn,mynode[kk].lati,mynode[kk].logn);
									rg = abs(range-RG_THRESHOLD);
									if(rg < min_range) {min_range = rg;ind_min = kk;}
								}
							}
						}
					}

					
					// 保证轨迹关联只在相邻批次
					if(mylist[jj].tail->frame_no == (cur_frame_no-1))
					{
						if(min_range < EST_ERR)
						{
							mylist[jj].KalmanFilter(var_x,var_y,&mynode[ind_min]);
							mynode[ind_min].is_used = true;
							Node *node_filter = mylist[jj].next_tail;
							mylist[jj].AddNode(node_filter);	//关联标记位 / 标记
				
						}else if(mylist[jj].GetLength() >= 2)
						{	
							mylist[jj].KalmanPredict();  // wait for test
							Node *node_est = mylist[jj].next_tail;
							mylist[jj].AddNode(node_est);		  //关联标记位 / 标记估计位
						}
					}
				}
		

				// judge list weight and output 
				int len;
				for(jj=0; jj<list_num; jj++)
				{
					len = mylist[jj].GetLength();

					// delete unvalid list;
					if((len==1) && (cur_frame_no > (mylist[jj].head->frame_no+2))) 
					{
						mylist[jj].ListDestroy();
					}

					if(len>3)
					{
						// condition is very important 
						if(mylist[jj].CalListWeight() >= TH_VALUE || len > cur_frame_no+1) 
						{
							mylist[jj].ListDestroy();
						}
						else
						{
							// ----- 航迹输出 -----
							mylist[jj].Output(fid_txt,fid_dat,jj,len);
							dotPathNum++;
						}
					}
				}


				// ********** Create new list ***************
				for(jj=0; jj<tar_num; jj++)
				{
					if(mynode[jj].is_related) continue;

					mynode[jj].is_related = true;
					mylist[list_num++].CreateNodeList(&mynode[jj]);
					mylist[kk].T_SCAN = scanCycle;

					if(list_num > MAX_LIST_NUM)
					{
						list_num=0;
						delete [] mylist;
						mylist = NULL;
						dotPathNum = 0;
						fclose(fid_dat);
						fclose(fid_txt);

						return false;
					}
				}

			}

		fclose(fid_dat);
		fclose(fid_txt);

		return true;

		}

		void NewGYLineInfo::MT_relate_XL(gyAimInfoList* aimPtTemp,long tar_num)
		{// check 1/15

			// static variable 
			static Node *mynode = NULL;
			if(mynode == NULL)
			   mynode = new Node[MAX_NODE_NUM];
			if(mynode == NULL) return;

			static bool beFirstBat = false;
			static long node_cnt = 0;
			static long bat_cnt = 0;
			bat_cnt++;
	
			if(bat_cnt < START_BAT_NO) return;
			beFirstBat = false;
			if(bat_cnt == START_BAT_NO) beFirstBat = true;

			if((node_cnt+tar_num) > (MAX_NODE_NUM-10))
			{
				node_cnt = 0; 
				bat_cnt = 0;
				delete [] mynode;
				mynode = NULL;
				return;
			}

			commonFuncs cmFuncs;

			long kk = 0;
			while(aimPtTemp!=NULL)
			{
				// 目标点赋值 
				mynode[node_cnt+kk].tar_vr = aimPtTemp->aim_velocity;
				mynode[node_cnt+kk].tar_r0 = aimPtTemp->tar_r0;
				mynode[node_cnt+kk].tar_azi = aimPtTemp->tar_azimuth;
				mynode[node_cnt+kk].tar_h = aimPtTemp->href;
				mynode[node_cnt+kk].tar_direction = 0.0;   //aimPtTemp->aim_direction;
				mynode[node_cnt+kk].lati = aimPtTemp->aim_latitude;
				mynode[node_cnt+kk].logn = aimPtTemp->aim_longitude;

				mynode[node_cnt+kk].tar_ampl = aimPtTemp->tar_ampl;

				mynode[node_cnt+kk].frame_no = aimPtTemp->aim_frame_no;
				mynode[node_cnt+kk].wave_no = aimPtTemp->aim_wave_no;
				mynode[node_cnt+kk].is_related = false;
				mynode[node_cnt+kk].is_real = true;
				mynode[node_cnt+kk].is_used = false;

				kk++;
				aimPtTemp=aimPtTemp->next;
			}

			bool flag = MovingTar_Relate(&mynode[node_cnt],tar_num,beFirstBat);
			
			if(!flag)
			{
				node_cnt = 0; 
				bat_cnt = 0;
				delete [] mynode;
				mynode = NULL;
				return;
			}

			node_cnt += tar_num;
		}


		// ********* 图像产生及图像处理类函数实现 *****************
		imgProc::imgProc(UINT8* arIn,string strPath)
		{
			rootPath=strPath+"\\";
			ar=arIn;

			commonFuncs cmFuncs;
		}
		
		imgProc::imgProc()
		{
			rootPath="";
			ar=NULL;
		}

		int imgProc::norm_image(Mat & src){
			int type = src.type();
			//cout<<src(Range(1,10),Range(1,10))<<endl;
			if(type == CV_8U)
			{
				src.convertTo(src,CV_32F,1.0/255.0);
				return type;
			}
			else if(type == CV_16U)
			{
				src.convertTo(src,CV_32F,1.0/65535.0);
				return type;
			}
			else 
				return -1;
		}

		Mat imgProc::mean_filter(Mat & src,int WinW){
			Mat mean_kernel = Mat::ones(WinW*2+1,WinW*2+1,CV_32F);
			Mat image_mean;
			mean_kernel = mean_kernel * (1.0/((WinW*2+1)*(WinW*2+1)));
			filter2D(src,image_mean,-1, mean_kernel);
			return image_mean;
		}

		Mat imgProc::var_filter(Mat & src, int WinW){
			Mat src2 = src.mul(src);
			src2 = mean_filter(src2,WinW);
			Mat src_mean = mean_filter(src,WinW);
			Mat var = src2 - src_mean.mul(src_mean);
			return var;
		}

		Mat imgProc::Lee(Mat& image_in,int WinW,float Looks)
		{
			Mat dst = image_in.mul(image_in);
			float noise_var = 1/sqrtf(Looks);
			//参数提取
			Mat I_mean = mean_filter(dst,WinW);
			Mat I_var = var_filter(dst,WinW);
			Mat x_var = (I_var -I_mean.mul(I_mean) * noise_var)/(1-noise_var);
			//滤波
			double var_min,var_max,cmin,cmax; 
			minMaxLoc(I_var, &var_min,&var_max);
			cmin = var_min + 0.1*(var_max - var_min);
			cmax = var_min + 0.9*(var_max - var_min);
			Mat ImgX = x_var.mul(1.0/I_var);
			Mat temp0=dst-I_mean;
			Mat temp1=ImgX.mul(temp0);
			ImgX = I_mean + temp1;
	
			float *p_var = (float *) I_var.data;
			float *p_dst = (float *) dst.data;
			float *p_x = (float *) ImgX.data;
			float *p_m = (float *) I_mean.data;
			float *temp;
	
			long long Num = dst.cols *dst.rows;

			do{
				if(*p_var<cmin)
					*p_x = *p_m;
				else if(*p_var>cmax)
					*p_x = *p_dst;
				p_x ++;
				p_m ++;
				p_dst ++;
				p_var ++;
			}while(--Num);
	
			sqrt(ImgX,ImgX);
			return ImgX;
		}

		Mat imgProc::Gamma(Mat& image_in,int WinW,float Looks)
		{
			Mat dst;
			image_in.copyTo(dst);
			float noise_var = 1/sqrtf(Looks);
			//参数提取
			Mat I_mean = mean_filter(dst,WinW);
			Mat I_var = var_filter(dst,WinW);
			Mat c_i;
			sqrt(I_var,c_i);
			c_i = c_i.mul(1.0/I_mean);
			Mat a = (1+noise_var*noise_var)/(c_i.mul(c_i) -noise_var*noise_var);
			Mat middle = a - Looks -1;
			middle = middle.mul(I_mean);

			float *p_var = (float *) I_var.data;
			float *p_dst = (float *) dst.data;
			float *p_c_i = (float *) c_i.data;
			float *p_middle = (float *) middle.data;
			float *p_mean = (float *) I_mean.data;
			float *p_a = (float *) a.data;
			float *p_in = (float *) image_in.data;
			float temp;
			long long Num = dst.cols *dst.rows;

			do{
				if(((*p_c_i)>= noise_var) && ((*p_middle) >=0) && ((*p_c_i) <= 1.414*noise_var))
				{
					temp = sqrtf((*p_middle)*(*p_middle) + 4*Looks*(*p_a) * (*p_in)*(*p_mean));
					*p_dst = ((*p_middle) + temp)/(2*(*p_a));
				}
				else if(*p_c_i < noise_var)
				{
					*p_dst = *p_mean;
				}
				else if(*p_c_i > 1.414*noise_var)
				{
					*p_dst = *p_in;
				}
				p_var++;
				p_dst++;
				p_c_i++;
				p_middle++;
				p_mean++;
				p_a++;
				p_in++;
			}while(--Num);
			return dst;
		}

		Mat imgProc::Kuan(Mat& image_in,int WinW,float Looks)
		{
			Mat dst;
			image_in.copyTo(dst);
			float noise_var = 1/sqrtf(Looks);
			//参数提取
			Mat I_mean = mean_filter(dst,WinW);
			Mat I_var = var_filter(dst,WinW);
			Mat x_var = (I_var - I_mean.mul(I_mean)*(noise_var*noise_var))/(1+noise_var*noise_var);
			Mat tempM = x_var>0;
			tempM.convertTo(tempM,CV_32F,1.0/255);
			x_var = x_var.mul(tempM);

			tempM = x_var.mul(1/(I_mean.mul(I_mean) + x_var)*(noise_var*noise_var));
			dst = I_mean + tempM.mul(image_in - I_mean);
			return dst;
		}

		Mat imgProc::Frost(Mat& image_in,int WinW)
		{
			Mat dst;
			image_in.copyTo(dst);
			int M = WinW*2+1;
			float p = 0.1;
			Mat I_mean = mean_filter(image_in,WinW);
			Mat I_var = var_filter(image_in,WinW);
			Mat subImage = Mat::ones(M,M,CV_32F);


			Mat dist, weight;
			subImage.copyTo(dist);//Mat::zeros(M,M,CV_32F);
			Scalar Sum_tmp;
			for(int ri = 0;ri<dist.rows;ri++)
				for(int ci = 0; ci<dist.cols; ci++)
				{
					dist.at<float>(ri,ci) = sqrtf(powf(ri-(float)WinW,2)+ powf(ci-(float)WinW,2));
				}
			//cout<<dist<<endl;
			for(int ci=WinW; ci<image_in.cols - WinW-1;ci++)
				for(int ri = WinW; ri<image_in.rows - WinW-1;ri++)
				{
					subImage = image_in(Range(ri-WinW,ri+WinW+1),Range(ci-WinW,ci+WinW+1));
					exp(0-dist * I_var.at<float>(ri,ci) * p/powf(I_mean.at<float>(ri,ci),2),weight);
					subImage = subImage.mul(weight);
			
					Sum_tmp = sum(subImage)/sum(weight);//<<endl;
					dst.at<float>(ri,ci) = Sum_tmp.val[0];
				}
				return dst;
		}

		Mat imgProc::Sigma(Mat& image_in,int WinW)
		{
			Mat dst;
			image_in.copyTo(dst);
			int M = WinW*2+1;
			float sigma = 0.3;
			Mat subImage = Mat::ones(M,M,CV_32F);
			Mat tmp, tmp2;
			Scalar Sum_tmp;

			for(int ci=WinW; ci<image_in.cols - WinW-1;ci++)
				for(int ri = WinW; ri<image_in.rows - WinW-1;ri++)
				{
					subImage = image_in(Range(ri-WinW,ri+WinW+1),Range(ci-WinW,ci+WinW+1));
					tmp = (subImage >= image_in.at<float>(ri,ci) * (1-2*sigma))+(subImage <= image_in.at<float>(ri,ci) * (1+2*sigma));
			
					tmp.convertTo(tmp,CV_32F,1.0/255);
			
					Sum_tmp = sum(subImage.mul(tmp))/sum(tmp);
					dst.at<float>(ri,ci) = Sum_tmp.val[0];
				}
				return dst;
		}

		void imgProc::gamma_correct(Mat &src,float high,float low, float gamma)//src 单通道，CV_8U或者CV_16U
		{
	
			float paramA,paramB;
			paramA = 1.0/(high-low);
			paramB = -paramA *low;

			int hist_bin_num ;
			int type = src.type();
			if(type == CV_8U)//规范化到0-1之间的float类型
				hist_bin_num = 256;
			if(type == CV_16U)
				hist_bin_num = 65536;
			Mat lut(hist_bin_num,1,CV_32F);
			lut.setTo(0);
			for(int i = 0;i<hist_bin_num;i++)
			{
				if(i<=low*(hist_bin_num-1))
					lut.at<float>(i) = 0;
				else if(i>=high*(hist_bin_num-1))
					lut.at<float>(i) = 1;
				else
				{
					lut.at<float>(i) = powf(paramA*(float)i/(hist_bin_num-1)+paramB,gamma);
				}
			}
			lut.convertTo(lut,CV_8U,255);
	
			unsigned long long *p =(unsigned long long *) src.data, temp;
			unsigned char * pl = (unsigned char *) lut.data;
	
			if(type == CV_16U)
			{
				long long NUM = src.cols*src.rows/4;
				unsigned long long D0,D1,D2,D3;
				do 
				{ 
					temp = *p;
					D0 = *(pl+(temp & 0xffff));
					D1 = *(pl+((temp>>16) & 0xffff));
					D2 = *(pl+((temp>>32) & 0xffff));
					D3 = *(pl+((temp>>48) & 0xffff));
					*(p++) = (D3<<48) | (D2<<32) | (D1<<16) | D0;
				} while (--NUM);
				src = src*256;
				//src.convertTo(src,CV_8U);
			}
			if(type == CV_8U)
			{
				long long NUM = src.cols*src.rows/8;
				unsigned long long D0,D1,D2,D3,D4,D5,D6,D7;
				do 
				{ 
					temp = *p;
					D0 = *(pl+(temp & 0xff));
					D1 = *(pl+((temp>>8) & 0xff));
					D2 = *(pl+((temp>>16) & 0xff));
					D3 = *(pl+((temp>>24) & 0xff));
					D4 = *(pl+((temp>>32) & 0xff));
					D5 = *(pl+((temp>>40) & 0xff));
					D6 = *(pl+((temp>>48) & 0xff));
					D7 = *(pl+((temp>>56) & 0xff));
					*(p++) = (D7<<56) | (D6<<48) | (D5<<40) | (D4<<32) |
							(D3<<24) | (D2<<16) | (D1<<8) | D0;
				} while (--NUM);
			}
		}

		void imgProc::high_low(Mat &src ,float &low,float &high)
		{
				//设定bin数目
			int histSize = 256;
			float range[] = { 0,255 };
			const float* histRange = { range };
			bool uniform = true; 
			bool accumulate = false;

			Mat NormSrc,hist;
	
			//设置ROI用于计算直方图
			int HeightBlockNum(0),WidthBlockNum(0),BlockHeight(256),BlockWidth(256);
			int jumpBlock;
			int BlockLength = MIN(src.rows,src.cols)/BlockHeight;
			if(BlockLength < 3)
				jumpBlock = 1;
			else if(BlockLength < 6)
				jumpBlock = 3;
			else if(BlockLength < 12)
				jumpBlock = 5;
			else if(BlockLength < 18)
				jumpBlock = 6;
			else if(BlockLength < 40)
				jumpBlock = 8;
			else if(BlockLength < 60)
				jumpBlock = 10;
			else 
				jumpBlock = 12;
	
			Rect roi = Rect(0,0,BlockWidth,BlockHeight);
			HeightBlockNum = src.rows /(BlockHeight*(jumpBlock));
			WidthBlockNum = src.cols /(BlockWidth*(jumpBlock));
			for(int Hidx = 0; Hidx < HeightBlockNum;Hidx++ )
			{
				for (int Widx = 0; Widx < WidthBlockNum; Widx++)
				{
					roi.x = Widx * jumpBlock * BlockWidth;
					roi.y = Hidx * jumpBlock * BlockWidth;
					NormSrc = src(roi);
					if(src.type() == CV_16U)//16位数据
					{	
						NormSrc.convertTo(NormSrc,CV_8U,1.0/256);
					}
					if(Hidx == 0 && Widx ==0)
					{
						calcHist( &NormSrc, 1, 0, Mat(), hist, 1, &histSize, &histRange, uniform, accumulate );
						accumulate = true;
					}else
					{
						calcHist( &NormSrc, 1, 0, Mat(), hist, 1, &histSize, &histRange, uniform, accumulate );
					}
				}
			}
	
			{//计算高低值
				Mat cdf;
				double minVal, maxVal,sc;
				int tempIdx[]={0,0};

				Mat temp;
				hist.convertTo(hist,CV_32F,(1.0/norm(hist,NORM_L1)));//归一化
				hist.copyTo(cdf);
	
				for(int i = 1;i<cdf.rows;i++)
					cdf.at<float>(i) = cdf.at<float>(i-1) + cdf.at<float>(i);//计算累积分布
	
				absdiff(cdf,low,temp);
				minMaxIdx(temp,& minVal, & maxVal,tempIdx);
				low = ((float)tempIdx[0])/(float)cdf.rows;
	   
				absdiff(cdf,high,temp);
				minMaxIdx(temp,& minVal, & maxVal,tempIdx);
				high = ((float)tempIdx[0])/(float)cdf.rows;
			}
		}

		void imgProc::SAR_VS_params_init(SAR_VS_params &params)
		{
			params.input_file_name="";
			params.output_file_name="";
			params.tifParams.dataMat=NULL;
			params.tifParams.dtHeight=0;
			params.tifParams.dtWidth=0;
			params.WinWidth = 2;
			params.looks = 4;
			params.gamma = 1;
			params.low = 0.01;
			params.high = 0.98;
			params.funtype = params.AUTO;
		}
		
		openCv_Proc::openCv_Proc()
		{
			WinWidth = 2;
			looks = 4;
			gamma = 1;
			low = 0.01;
			high = 0.98;
			funtype =0;
		}
		
		void imgProc::Local_Funcs(SAR_VS_params param)
		{
			if(param.funtype == param.AUTO)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				float high, low;
				high = param.high;
				low = param.low;
				high_low(src,low,high);
				//cout<< param.WinWidth<<endl;
				gamma_correct(src,high,low,param.gamma);//src 单通道，CV_8U或者CV_16U
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.LEE)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Lee(src,param.WinWidth,param.looks);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			
			if(param.funtype == param.FROST)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Frost(src,param.WinWidth);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.GAMMA)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Gamma(src,param.WinWidth,param.looks);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.KUAN)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Kuan(src,param.WinWidth,param.looks);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.SIGMA)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Sigma(src,param.WinWidth);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
		}

		void imgProc::Local_Funcs()
		{
			commonFuncs cmFuncs;
			int widthTif=cmFuncs.getRangePoints(ar);
			int heightTif=TIFHEIGHT;

			string strName=rootPath.append(cmFuncs.getName(ar)+".tif");
			Mat src(heightTif,widthTif,CV_8U);

			src.data=ar;
			src.rows=heightTif;
			src.cols=widthTif;
			src.dims=2;
			int type = src.type();
			float high, low;
			high = 0.98;
			low = 0.01;
			high_low(src,low,high);
			gamma_correct(src,high,low,1);//src 单通道，CV_8U或者CV_16U
			imwrite(strName,src);
		}

		void imgProc::Local_Funcs1(SAR_VS_params param)
		{
			if(param.funtype == param.AUTO)
			{
				//Mat src = imread(param.input_file_name,-1);
				int dtH=param.tifParams.dtHeight/10;
				int dtW=param.tifParams.dtWidth;
				Mat src(dtH,dtW,CV_8UC1);
				src.data=param.tifParams.dataMat;
				src.rows=param.tifParams.dtHeight;
				src.cols=param.tifParams.dtWidth;
				src.dims=2;
				flip(src,src,0);
				int type = src.type();
				float high, low;
				high = param.high;
				low = param.low;
				high_low(src,low,high);
				gamma_correct(src,high,low,param.gamma);//src 单通道，CV_8U或者CV_16U
				//gdalCreatTif(param);
				imwrite(param.output_file_name,src);
				//src.deallocate();
			}
			/*if(param.funtype == param.LEE)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Lee(src,param.WinWidth,param.looks);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.FROST)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Frost(src,param.WinWidth);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.GAMMA)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Gamma(src,param.WinWidth,param.looks);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.KUAN)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Kuan(src,param.WinWidth,param.looks);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}
			if(param.funtype == param.SIGMA)
			{
				Mat src = imread(param.input_file_name,-1);
				int type = src.type();
				norm_image(src);
				src = Sigma(src,param.WinWidth);
				src.convertTo(src,type,(type==CV_8U) ? (255.0) : (65535.0));
				imwrite(param.output_file_name,src);
			}*/
		}

		int  imgProc::creatTif()
		{

			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);
			if(md==4)
				return ERROR_MODEL;

			string strName=rootPath.append(cmFuncs.getName(ar));

			if(md==3)
			{
               strName=strName+"_M.tif";
			}
			else
			{
				strName=strName+".tif";
			}


			int tifHeight=512;
			int tifWidth=cmFuncs.getRangePoints(ar);
			int ps=0;

			Mat src(tifHeight,tifWidth,CV_8UC1);
	     
			if(md==3)
			{
				ps=1024;
				
			}
			else
			{
				ps=512;
				
			}


			UINT8 *buffer=new UINT8[tifHeight*tifWidth];

            int j;
			for(j=0;j<tifHeight*tifWidth;j++)
			{			

			buffer[j]=ar[ps+j];
			}

			//src.rows=tifWidth;
			//src.cols=tifHeight;
			src.dims=2;	
			src.data=buffer;			
			flip(src,src,0);
			imwrite(strName,src);
			delete []buffer;
			return 0;
		}

        int  imgProc::creatCoTif(UINT8* dataAr)
      {// core code 

			static int cntRecvpLoop=0;
			static unsigned char * imgAr=NULL;
			static unsigned char * parsAr=NULL;
			static __int64  prfCountLast=0;
			static int  tifWidthLast=0;
			static int  modeLast=0;
			//方位向号码
		    static int loopNum=0;
		    static int pwOnTime=1;

			//多少小条(512行)生成一幅大图
			static int  numToMerge=8;
			int ps;
			commonFuncs cmFuncs;			
			int md=cmFuncs.getSarModel(dataAr);

			ps=512;
			/*if(md==3)
			{
				ps=1024;
				
			}
			else
			{
				ps=512;
				
			}*/

			int tifWidth=cmFuncs.getRangePoints(dataAr);

			__int64 prfCount=cmFuncs.getPRFNum(dataAr);
			
			int resNumTemp=cmFuncs.getSarRes(dataAr);

			//if(pwOnTime==(cmFuncs.getPowerOnTime(ar)-1))
			//{
			//	loopNum=0;
			//  pwOnTime++;
			//}

///*****************************拼成大图******************************/
//			//判断是否第一次，并且初始化存储数组
				if(cntRecvpLoop==0)
				{
					tifWidthLast=tifWidth;
					prfCountLast=prfCount;
					modeLast=md;
					//图像
					imgAr=new unsigned char[tifWidth*512*numToMerge];
					memcpy(imgAr,&(dataAr[ps]),tifWidth*512);
					//参数
					parsAr=new unsigned char[512*numToMerge];
					memcpy(parsAr,dataAr,512);
					cntRecvpLoop++;
				}
				else
				{
					if(tifWidth==tifWidthLast&&md==modeLast&&prfCount==prfCountLast)
					{
                     memcpy(&(imgAr[tifWidth*512*cntRecvpLoop]),&(dataAr[ps]),tifWidth*512);

					 memcpy(&(parsAr[512*cntRecvpLoop]),dataAr,512);

					 if(cntRecvpLoop==(numToMerge-1))
					 {
						string flPath=rootPath.append("COMBINATION\\"+cmFuncs.getCombPicName(dataAr,loopNum)+".tif");
						SAR_VS_params stPars;
						SAR_VS_params_init(stPars);
						stPars.output_file_name=flPath;
						stPars.tifParams.dataMat=imgAr;
						stPars.tifParams.dtHeight=512*numToMerge;
						stPars.tifParams.dtWidth=tifWidth;
						Local_Funcs1(stPars);
						//gdalCreatTif(stPars);
						cmFuncs.logRecords("prf:",(double)prfCount);
						//成像完成

						////生成大图的参数信息

						int pathLen=flPath.length();	
						char * nameCh=NULL;
						nameCh=new char[pathLen+1];

						for(int i=0;i<pathLen;i++)
						{
							nameCh[i]=flPath[i];
						}
						nameCh[pathLen-3]='t';
						nameCh[pathLen-2]='x';
						nameCh[pathLen-1]='t';
						nameCh[pathLen]='\0';
						FILE * FL=fopen(nameCh,"a");

						if(FL==NULL)
						{
							if(nameCh!=NULL)
							{
								delete []nameCh;
								nameCh=NULL;
							}

						    return ERROR_PATH;
						}
						

						sarImageInfo imgInfo(parsAr);
						muInfo muStart(parsAr);
						muInfo muEnd(parsAr);

						// ************** Modified by Yunhua-Luo @2015/11/17 V2 **************
						
						int Tar_Num = 4;
						double Tar_info[8]; // 用于存储定位输出结果；（存储顺序：左上角经度，纬度，右上角经度，纬度，左下角经度，纬度，右下角经度，纬度）
						double Rs[2];
						double Fs = imgInfo.fs*1.0e6;
						double dr = C_LIGHT/2/Fs;
						double az_vel0 = sqrt(muStart.plane_east_v*muStart.plane_east_v+muStart.plane_north_v*muStart.plane_north_v);
						double da = az_vel0/double(imgInfo.prf)*2;// *2 -- 方位向采样间隔 （处理时进行了抽取）
						double Length = da*8*512;
						float fly_ang = muStart.plane_direction_angle; // 飞机航向角，度；以正北为参考，顺时针为正，如果没有直接给出，可以用ATAN(e_v/n_v)
						
						Rs[0] = imgInfo.slope_nearest+16384.0*dr; // 图像近端斜距,修正成像中的裁剪
						Rs[1] = imgInfo.slope_far-16384.0*dr;     // 图像远端斜距
						float plan_logn[2];	
						float plan_lati[2]; 
						plan_logn[0]=muStart.plane_longitude;     // 第一幅图像对应位置飞机的经纬度
						plan_lati[0]=muStart.plane_latitude; 
						
						// 根据航向角算出图像结束为止飞机的经纬度 // added by Luo 
						double JD_L = Length*sin(fly_ang*PI/180.0);
						double WD_L = Length*cos(fly_ang*PI/180.0);
						plan_logn[1] = plan_logn[0] + JD_L/60.0/1852.0/cos(plan_lati[0]*PI/180);
						plan_lati[1] = plan_lati[0] + WD_L/60.0/1852.0;     

						float href=muStart.plane_aim_height;         // 载机到地面高度，米；
						float look_side=imgInfo.look_Side;           // 侧视方向，左侧 1， 右侧为-1；

						Geo_locating(Tar_info,Rs,plan_logn,plan_lati,fly_ang,href,look_side,Tar_Num);
						
						taskInfo task0(parsAr);
						task0.output(FL);											
						sarImageInfo sarImageInfo0(parsAr);
						sarImageInfo0.img_rows=numToMerge*sarImageInfo0.img_rows;
						sarImageInfo0.left_top_longitude=Tar_info[0];
						sarImageInfo0.left_top_latitude=Tar_info[1];
						sarImageInfo0.right_up_longitude=Tar_info[2];
						sarImageInfo0.right_down_latitude=Tar_info[3];
						sarImageInfo0.left_down_longitude=Tar_info[4];
						sarImageInfo0.left_down_latitude=Tar_info[5];
						sarImageInfo0.right_down_longitude=Tar_info[6];
						sarImageInfo0.right_down_latitude=Tar_info[7];
						sarImageInfo0.img_center_longitude=(Tar_info[0]+Tar_info[6])/2;
						sarImageInfo0.img_center_latitude=(Tar_info[1]+Tar_info[7])/2;						
						sarImageInfo0.output(FL);



						muInfo mu0(parsAr);
						mu0.output(FL);  // write file 


						fprintf(FL,"\n");

						for(int j=0;j<numToMerge;j++)
						{ 
							fprintf(FL,"序号:%d\n",j+1);
							taskInfo task(&(parsAr[512*j]));
							task.output(FL);											
							sarImageInfo sarImageInfo(&(parsAr[512*j]));
							sarImageInfo.output(FL);
							muInfo mu(&(parsAr[512*j]));
							mu.output(FL,j);
							fprintf(FL,"\n");
						}

						/*
						fprintf(FL,"图像左上角经度(度):%6.7f\n",Tar_info[0]);
						fprintf(FL,"图像左上角纬度(度):%6.7f\n",Tar_info[1]);
						fprintf(FL,"图像右上角经度(度):%6.7f\n",Tar_info[2]);
						fprintf(FL,"图像右上角纬度(度):%6.7f\n",Tar_info[3]);
						fprintf(FL,"图像左下角经度(度):%6.7f\n",Tar_info[4]);
						fprintf(FL,"图像左下角纬度(度):%6.7f\n",Tar_info[5]);
						fprintf(FL,"图像右下角经度(度):%6.7f\n",Tar_info[6]);
						fprintf(FL,"图像右下角纬度(度):%6.7f\n",Tar_info[7]);
						*/


						if(nameCh!=NULL)
						{
							delete [] nameCh;
							nameCh=NULL;
						}

						fclose(FL);

						loopNum++;

						if(imgAr!=NULL)
						{
							delete []imgAr;
							imgAr=NULL;
						}

						if(parsAr!=NULL)
						{
							delete []parsAr;
							parsAr=NULL;
						}

						 cntRecvpLoop=0;
					 }
					 else
					 {
					  cntRecvpLoop++;
					 }
					}
					else
					{

						string flSgPath=rootPath.append("combination\\"+cmFuncs.getRawPicName(parsAr,loopNum)+".tif");					
						SAR_VS_params stSgPars;
						SAR_VS_params_init(stSgPars);
						stSgPars.output_file_name=flSgPath;
						stSgPars.tifParams.dataMat=imgAr;
						stSgPars.tifParams.dtHeight=512*cntRecvpLoop;
						stSgPars.tifParams.dtWidth=tifWidthLast;
						Local_Funcs1(stSgPars);


						////生成大图的参数信息

						int pathLenT=flSgPath.length();
						char * nameChT=NULL;						
						nameChT=new char[pathLenT+1];

						for(int i=0;i<pathLenT;i++)
						{
							nameChT[i]=flSgPath[i];
						}
						nameChT[pathLenT-3]='t';
						nameChT[pathLenT-2]='x';
						nameChT[pathLenT-1]='t';
						nameChT[pathLenT]='\0';
						FILE * FLT=fopen(nameChT,"a");

						if(FLT==NULL)
						{
							delete [] nameChT;
							nameChT=NULL;
						    return ERROR_PATH;
						}

                       
						sarImageInfo imgInfo(parsAr);
						muInfo muStart(parsAr);
						muInfo muEnd(parsAr);

						// ************** Modified by Yunhua-Luo @2015/11/17 **************
						// ************** Modified by Yunhua-Luo @2015/11/17 V2 **************
						
						int Tar_Num = 4;
						double Tar_info[8]; // 用于存储定位输出结果；（存储顺序：左上角经度，纬度，右上角经度，纬度，左下角经度，纬度，右下角经度，纬度）
						double Rs[2];
						double Fs = imgInfo.fs*1.0e6;
						double dr = C_LIGHT/2/Fs;
						double az_vel0 = sqrt(muStart.plane_east_v*muStart.plane_east_v+muStart.plane_north_v*muStart.plane_north_v);
						double da = az_vel0/double(imgInfo.prf)*2;// *2 -- 方位向采样间隔 （处理时进行了抽取）
						double Length = da*8*512;
						float fly_ang = muStart.plane_direction_angle; // 飞机航向角，度；以正北为参考，顺时针为正，如果没有直接给出，可以用ATAN(e_v/n_v)
						
						Rs[0] = imgInfo.slope_nearest+16384.0*dr; // 图像近端斜距,修正成像中的裁剪
						Rs[1] = imgInfo.slope_far-16384.0*dr;     // 图像远端斜距
						float plan_logn[2];	
						float plan_lati[2]; 
						plan_logn[0]=muStart.plane_longitude;     // 第一幅图像对应位置飞机的经纬度
						plan_lati[0]=muStart.plane_latitude; 
						
						// 根据航向角算出图像结束为止飞机的经纬度 // added by Luo 
						double JD_L = Length*sin(fly_ang*PI/180.0);
						double WD_L = Length*cos(fly_ang*PI/180.0);
						plan_logn[1] = plan_logn[0] + JD_L/60.0/1852.0/cos(plan_lati[0]*PI/180);
						plan_lati[1] = plan_lati[0] + WD_L/60.0/1852.0;     

						float href=muStart.plane_aim_height;         // 载机到地面高度，米；
						float look_side=imgInfo.look_Side;           // 侧视方向，左侧 1， 右侧为-1；

						Geo_locating(Tar_info,Rs,plan_logn,plan_lati,fly_ang,href,look_side,Tar_Num);
						

						taskInfo task0(parsAr);
						task0.output(FLT);											
						sarImageInfo sarImageInfo0(parsAr);
						sarImageInfo0.img_rows=numToMerge*cntRecvpLoop;
						sarImageInfo0.left_top_longitude=Tar_info[0];
						sarImageInfo0.left_top_latitude=Tar_info[1];
						sarImageInfo0.right_up_longitude=Tar_info[2];
						sarImageInfo0.right_down_latitude=Tar_info[3];
						sarImageInfo0.left_down_longitude=Tar_info[4];
						sarImageInfo0.left_down_latitude=Tar_info[5];
						sarImageInfo0.right_down_longitude=Tar_info[6];
						sarImageInfo0.right_down_latitude=Tar_info[7];
						sarImageInfo0.img_center_longitude=(Tar_info[0]+Tar_info[6])/2;
						sarImageInfo0.img_center_latitude=(Tar_info[1]+Tar_info[7])/2;						
						sarImageInfo0.output(FLT);
						muInfo mu0(parsAr);
						mu0.output(FLT);
						fprintf(FLT,"\n");

						for(int j=0;j<cntRecvpLoop;j++)
						{ 
							fprintf(FLT,"序号:%d\n",j+1);
							taskInfo task(&(parsAr[512*j]));
							task.output(FLT);											
							sarImageInfo sarImageInfo(&(parsAr[512*j]));
							sarImageInfo.output(FLT);
							muInfo mu(&(parsAr[512*j]));
							mu.output(FLT,j);
							fprintf(FLT,"\n");
						}
						/*fprintf(FLT,"图像左上角经度(度):%6.7f\n",Tar_info[0]);
						fprintf(FLT,"图像左上角纬度(度):%6.7f\n",Tar_info[1]);
						fprintf(FLT,"图像右上角经度(度):%6.7f\n",Tar_info[2]);
						fprintf(FLT,"图像右上角纬度(度):%6.7f\n",Tar_info[3]);
						fprintf(FLT,"图像左下角经度(度):%6.7f\n",Tar_info[4]);
						fprintf(FLT,"图像左下角纬度(度):%6.7f\n",Tar_info[5]);
						fprintf(FLT,"图像右下角经度(度):%6.7f\n",Tar_info[6]);
						fprintf(FLT,"图像右下角纬度(度):%6.7f\n",Tar_info[7]);*/


						if(nameChT!=NULL)
						{
							delete [] nameChT;
							nameChT=NULL;
						}

						fclose(FLT);

						loopNum++;


						cntRecvpLoop=0;

						if(imgAr!=NULL)
						{
						   delete []imgAr;
						   imgAr=NULL;
						}

						if(parsAr!=NULL)
						{
						   delete []parsAr;
						   parsAr=NULL;
						}

                    md=cmFuncs.getSarModel(dataAr);
                    tifWidth=cmFuncs.getRangePoints(dataAr);
			        prfCount=cmFuncs.getPRFNum(dataAr);

					tifWidthLast=tifWidth;
					prfCountLast=prfCount;
					modeLast=md;
					//图像
					imgAr=new unsigned char[tifWidth*512*numToMerge];
					memcpy(imgAr,&(dataAr[ps]),tifWidth*512);
					//参数
					parsAr=new unsigned char[512*numToMerge];
					memcpy(parsAr,dataAr,512);
					cntRecvpLoop++;
					}
				}

			return 0;
		}

        void  imgProc::Geo_locating(double *Tar_info, double *Rs,float *plan_logn,float *plan_lati,float fly_ang,double href,double look_side,__int64 Tar_Num)
     {// OK 0511 OK 

     double    plane_JD, plane_WD;
     double    diju,R0;
     double    X_JD_t, Y_WD_t;
	 __int64   i,pos,pos1;
	 double yaw_ang_res = 0.6;

     for(i = 0; i < Tar_Num; i++)
     {
			pos= i%2;
			plane_JD = plan_logn[pos];
            plane_WD = plan_lati[pos];
			pos1 = int(i/2);
			R0 = Rs[pos1];
	        diju = sqrt(R0*R0 - href*href);

			// look_side : left -- 1, right --- -1;
			X_JD_t = -diju*look_side*cos((fly_ang-yaw_ang_res)*PI/180.0*look_side);
			Y_WD_t = diju*sin((fly_ang-yaw_ang_res)*PI/180.0*look_side);
			Tar_info[2*i] = plane_JD + X_JD_t/60.0/1852.0/cos(plane_WD*PI/180);
            Tar_info[2*i+1] = plane_WD + Y_WD_t/60.0/1852.0;     
	}
}

		void imgProc::allImageProMethod(char * strImage,char * strDest,imageProcParsST procPars)
		{// check 07/25 by luo
			//读取图像
			string flSrcPath(strImage);
			string flDestPath(strDest);
			Mat src = imread(flSrcPath,-1);
			int heightI=src.rows;
			int widthI=src.cols;
		    const	int typeI=src.type();

			UINT8 *dataR = new UINT8[heightI*widthI];
			memset(dataR,0,sizeof(UINT8)*heightI*widthI);
			for(long i=0;i<heightI*widthI;i++)
			{
				dataR[i]= src.data[i];
			}
			
			unsigned char *dataRes=new unsigned char[heightI*widthI];
			if(procPars.blRemoveSpots>0)
			{
			//unsigned char *dataRes=dataR;
			LeeSmooth(dataR,widthI,heightI,dataRes);
			}
			else
			{
				for(long i=0;i<heightI*widthI;i++)
				{
				  dataRes[i]=dataR[i];
				}
			}
			
			//辐射校正
			__int64 img_nr=widthI;
			__int64 img_na=heightI; // 图像的大小
			float dr=procPars.ra_res;	  // 距离采样间隔
			float r_near=procPars.r_near; // 近端斜距；
			float href=procPars.href;   // 飞机到地面高度
			float r_ang=procPars.r_ang*PI/180.0;  // 雷达下视角;
			float ra_beam_ang=procPars.ra_beam_ang*PI/180.0; // 距离向波束宽度;
			unsigned char *img_data = dataRes; // 存储数据
			
			if(procPars.blGeoCor>0)
			{
			// 辐射校正
			float *ampl_coef = new float[img_nr];
			ampl_corr(ampl_coef,dr,r_near,href,r_ang,ra_beam_ang,img_nr);
			img_corr(img_data,ampl_coef,img_na,img_nr);		
			delete [] ampl_coef;
			}
			//几何校正
			//float ra_res; // 距离向采样间隔 
			//float r_near; // 近端斜距；
			//float href;   // 载机到地面高度
			if(procPars.blAmpCor>0)
			{
			// 几何校正
			img_corr(img_data,dr,r_near,href,img_na,img_nr);
			}
			
			for(long i=0;i<heightI*widthI;i++)
			{
				src.data[i]=img_data[i];
			}		

			if(procPars.blHs>0)
			{
			//直方图均衡
			float high, low , gamma;
			high = 0.01;
			low  = 0.98;
			gamma=1;
			high_low(src,low,high);
			gamma_correct(src,high,low,gamma);
			}


			imwrite(flDestPath,src);
			delete []dataRes;
			delete []dataR;

		}

		void imgProc::img_corr(UINT8 *img_data,float *img,float ra_res,float r_near,float href,__int64 till_nr,__int64 till_na,__int64 img_na,__int64 img_nr)
		{
			//OK
			__int64 h,i;
			__int64 az_loc;
			double  R0;

			//////////////////////////////////////////////////
			float *coef  = new float[img_na];
			float *rcoef = new float[img_nr];
			UINT8 *temp=new UINT8[img_nr];
			int    *ra = new int[img_nr];
			float  daz = float(till_na-2)/float(img_na-1);

			// 两点线性插值
			for(i=0;i<img_na;i++) 
				coef[i] = float(i)*daz-float(int(i*daz));

			//////////////////////azimuth line interpft///////////
			#pragma omp parallel for firstprivate(az_loc,i)		
			for(h=0;h<till_nr;h++)
			{
				az_loc=h*till_na;
				for(i=0;i<img_na;i++)
					img_data[i*img_nr+h] = short(img[az_loc+int(i*daz)]*coef[i]+img[az_loc+1+int(i*daz)]*(1.0-coef[i]));
			}

			/////////geometry correct/////////
			if(href>1) 
			{	
				double  r_far   = r_near+till_nr*ra_res;
				double  gr_near = sqrt(r_near*r_near-href*href);

				//#pragma omp parallel for firstprivate(R0)					 
				for(i=0;i<img_nr;i++) 
				{ 
					R0 = sqrt((gr_near+i*ra_res)*(gr_near+i*ra_res)+href*href);
					ra[i] = int((R0-r_near)/ra_res)%(till_nr-1);
					rcoef[i] = (R0-r_near)/ra_res-float(ra[i]);	   
				}

				for(h=0;h<img_na;h++)
				{
					//#pragma omp parallel for		
					for(i=0;i<img_nr;i++)  
					{	
						temp[i]=short(img_data[*(ra+i)+h*img_nr]*rcoef[i]+img_data[*(ra+i)+1+h*img_nr]*(1-rcoef[i]));
					}
					memcpy(img_data+h*img_nr,temp,sizeof(UINT8)*img_nr);
				}
			} 

			delete [] coef;
			delete [] temp;
			delete [] ra;
			delete [] rcoef;

		}

		void imgProc::LeeFilter(unsigned char* pUnchImg,long npos,long nWidth,long nHight,unsigned char* pUnchSmooth)
		{		
				long x,y,ng,nv,i;
	
				double Mean;
				double Var;
				double K;
				//int temp[25];
				ng=0;
				i=0;
				for(y=-1;y<=1;y++)
				{
					for(x=-1;x<=1;x++)
					{
						ng+= pUnchImg[npos+x+y*nWidth];//求均值
					}
				}
				Mean= ng/9;
				pUnchSmooth[npos] = unsigned char(Mean); //255; //pUnchImg[npos];//unsigned char(Mean);
				
				/*
				nv=0;
				for(y = -2;y<=2;y++)
				{
					for(x=-2;x<=2;x++)
					{
						nv += (pUnchImg[npos+x+y*nWidth]-Mean)*(pUnchImg[npos+x+y*nWidth]-Mean);//求方差
					}
				}
				Var=nv/24;

				double nL;
				nL=(Var+Mean*Mean)/1.27-Mean*Mean;//等效视数
				K=nL/(Mean*Mean*0.27+nL);

				if(Mean>0)
				{
					pUnchSmooth[npos] = Mean+K*(pUnchImg[npos]-Mean);
				}
				else
				{
					pUnchSmooth[npos]=pUnchImg[npos];
				}*/

		}
		
		void imgProc::LeeSmooth(unsigned char* pUnchImage,long nWidth,long nHeight,unsigned char* pUnchSmooth)
		{
			long x,y,npos;
			for(y=5;y<=nHeight-5;y++)	
			{
				for(x=5;x<=nWidth-5;x++)
				{
					npos=y*nWidth+x; 
					//npos=x*nHeight+y;
					LeeFilter(pUnchImage,npos,nWidth,nHeight,pUnchSmooth);
				}
			}
		}

		double imgProc::sinc(double x)
		{
			double  val;
			if(x==0)  val=1.0;
			else      val=sin(PI*x)/x/PI;
			return val;
		}
		
		void imgProc::ampl_corr(float *ampl_coef,float dr,float r_near ,float href,float r_ang, float ra_beam_ang,long nr )
		{// OK 
		 // ra_beam_ang -- fudu	 
		 // r_ang -- fudu 		 // 

			long i;
			double gr,r0,theta;
			double gain;
			double la_r,la_t;////发射与接受天线

			if(ra_beam_ang<0.05)
			{
				ra_beam_ang=acos(href/(r_near+nr*dr))-acos(href/r_near);      
			}

			la_r=0.886/ra_beam_ang;
			la_t=0.886/ra_beam_ang;
			double sincv = 0.0;
	
			gr=r_near+nr/2*dr;
			double rc=sqrt(gr*gr+href*href);
			theta=acos(href/rc);

			for(i=0;i<nr;i++)
			{
				gr=r_near+i*dr;
				r0=sqrt(gr*gr+href*href);
				theta=acos(href/r0)-r_ang;
				sincv = sinc(sin(theta)*la_t);
				gain=pow(r_near/r0,3/2)*sincv*sincv;  
				ampl_coef[i]=gain; 
			}

		}
		
		void imgProc::img_corr(unsigned char *img_data,float *ampl_coef,__int64 img_na,__int64 img_nr)
		{//OK
	
			// -- 需要注意数据的存储顺序；按img_nr顺序存储；1,...,img_nr;
			__int64 h,i;
			unsigned char *temp = new unsigned char[img_nr];
			for(h=0;h<img_na;h++)
			{	
				for(i=0;i<img_nr;i++)  
				{	
					temp[i] = unsigned char(img_data[i+h*img_nr]*ampl_coef[i]);
				}
				memcpy(img_data+h*img_nr,temp,sizeof(unsigned char)*img_nr);
			}
			delete [] temp;
		}
		
		void imgProc::img_corr(unsigned char *img_data,float ra_res,float r_near,float href,__int64 img_na,__int64 img_nr)
		{//OK
	
			__int64 h,i;
			double  R0;
	
			//////////////////////////////////////////////////
			float *rcoef = new float[img_nr];
			unsigned char *temp=new unsigned char[img_nr];
			int    *ra = new int[img_nr];

			/////////geometry correct/////////
			if(href>1) 
			{	
				double  r_far   = r_near+img_nr*ra_res;
				double  gr_near = sqrt(r_near*r_near-href*href);
					 
				for(i=0;i<img_nr;i++) 
				{ 
				   R0 = sqrt((gr_near+i*ra_res)*(gr_near+i*ra_res)+href*href);
				   ra[i] = int((R0-r_near)/ra_res)%(img_nr-1);
				   rcoef[i] = (R0-r_near)/ra_res-float(ra[i]);	   
				}
		
				for(h=0;h<img_na;h++)
				{	
					for(i=0;i<img_nr;i++)  
					{	
						temp[i]=unsigned char(img_data[*(ra+i)+h*img_nr]*rcoef[i]+img_data[*(ra+i)+1+h*img_nr]*(1-rcoef[i]));
					}
					memcpy(img_data+h*img_nr,temp,sizeof(unsigned char)*img_nr);
				}
			} 

			delete [] temp;
			delete [] ra;
			delete [] rcoef;
    
		}
	
		string commonFuncs::getName(UINT8* ar)
		{
			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			int dbstrpNum=(int)fmtConv.getResult(imgInfoPs.loop_num);
			sprintf_s(chAr,"%05d",dbstrpNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt);
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");
			////有无损压缩
			//strName.append("Y002_");

			//飞机批号、飞机号
			//strName.append("01");
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

			double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}
			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);
			
			if(transType==0)
				{				  					
					strName.append("001");
					strName.append("_");
					
				}
				else
				{
					rateCompress=rateCompress>999?999:rateCompress;
					sprintf_s(chAr,"%03d",rateCompress);
					strName.append(chAr);
					strName.append("_");
				}

			
			strName.append("0703");

			UINT32 wkMd=(UINT32)fmtConv.getResult(imgInfoPs.work_mode);
				
			UINT32 work_mode=(wkMd>>16) & 0x0F;

			
			switch (sarResIndex2)
			{
			case 1:
				strName.append("04");//0.3米聚束
				break;
			case 2:
				strName.append("01");//0.5米条带
				break;
			case 3:
				strName.append("02");//1米条带
				break;
			case 4:            //3米 条带和sarGMTI都有三米模式
				if((int)work_mode==0)
				{
					strName.append("03");
				}
				else
				{
					strName.append("05");
				}
				break;
			case 5:          //5米
				strName.append("06");
				break;
			case 6:
				strName.append("07");
				break;
			case 7:
				strName.append("08");
				break;
			}

			return strName;
		}
		//生成不叠加点迹的图像名称
		string commonFuncs::getRawPicName(UINT8 * ar)
		{
            string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			int dbstrpNum=(int)fmtConv.getResult(imgInfoPs.loop_num);
			sprintf_s(chAr,"%05d",dbstrpNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt);
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");
			////有无损压缩
			//strName.append("Y002_");

			//飞机批号、飞机号
			//strName.append("01");
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

			double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}

			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);

			if(transType==0)
				{				  					
					strName.append("001");
					strName.append("_");
					
				}
				else
				{
					rateCompress=rateCompress>999?999:rateCompress;
					sprintf_s(chAr,"%03d",rateCompress);
					strName.append(chAr);
					strName.append("_");
				}

			
			strName.append("0703");

			UINT32 wkMd=(UINT32)fmtConv.getResult(imgInfoPs.work_mode);
				
			UINT32 work_mode=(wkMd>>16) & 0x0F;

			switch (sarResIndex2)
			{
			case 1:
				strName.append("04");//0.3米聚束
				break;
			case 2:
				strName.append("01");//0.5米条带
				break;
			case 3:
				strName.append("02");//1米条带
				break;
			case 4:            //3米 条带和sarGMTI都有三米模式
				if((int)work_mode==0)
				{
					strName.append("03");
				}
				else
				{
					strName.append("05");
				}
				break;
			case 5:          //5米
				strName.append("06");
				break;
			case 6:
				strName.append("07");
				break;
			case 7:
				strName.append("08");
				break;
			}

			return strName;
		}
	    //生成点目标的文件名称
		string commonFuncs::getDataName(UINT8 * ar)
		{
			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			int dbstrpNum=(int)fmtConv.getResult(imgInfoPs.loop_num);
			sprintf_s(chAr,"%05d",dbstrpNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt);
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");
			////有无损压缩
			//strName.append("Y002_");

			//飞机批号、飞机号
			//strName.append("01");
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

			double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}
			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);

			
			if(transType==0)
			{
				//GMTI
				strName.append("M00_");
			}
			else
			{
				strName.append("M01_");
			}
			
			strName.append("0703");

			//
			if(sarModelNumTemp==3)//sarGMTI
			{
				strName.append("03");
			}
			else if(sarModelNumTemp==4)
			{
				strName.append("00");
			}

			return strName;
		}
	    //生成点图像融合的图像名称
		string commonFuncs::getMarkPicName(UINT8 *ar)
		{
 
			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			int dbstrpNum=(int)fmtConv.getResult(imgInfoPs.loop_num);
			sprintf_s(chAr,"%05d",dbstrpNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt)+900;
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");
			////有无损压缩
			//strName.append("Y002_");

			//飞机批号、飞机号
			//strName.append("01");
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

			double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}
			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);

			

			if(transType==0)
				{				  					
					strName.append("001");
					strName.append("_");					
				}
				else
				{
					rateCompress=rateCompress>999?999:rateCompress;
					sprintf_s(chAr,"%03d",rateCompress);
					strName.append(chAr);
					strName.append("_");
				}
			
			strName.append("0703");

			UINT32 wkMd=(UINT32)fmtConv.getResult(imgInfoPs.work_mode);
				
			UINT32 work_mode=(wkMd>>16) & 0x0F;
			
			switch (sarResIndex2)
			{
			case 1:
				strName.append("04");//0.3米聚束
				break;
			case 2:
				strName.append("01");//0.5米条带
				break;
			case 3:
				strName.append("02");//1米条带
				break;
			case 4:            //3米 条带和sarGMTI都有三米模式
				if((int)work_mode==0)
				{
					strName.append("03");
				}
				else
				{
					strName.append("05");
				}
				break;
			case 5:          //5米
				strName.append("06");
				break;
			case 6:
				strName.append("07");
				break;
			case 7:
				strName.append("08");
				break;
			}

			return strName;
		}
	  
		string commonFuncs::getNameByLoopNum(UINT8* ar,int stripNum)
		{

			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			////获取日期、时间
			//time_t rawTime;
			//struct tm * tmInfo;
			//time(&rawTime);
			//tmInfo=localtime(&rawTime);
			//sprintf_s(chAr,"%02d",tmInfo->tm_mon+1);
			//strName.append(chAr);
			//sprintf_s(chAr,"%02d",tmInfo->tm_mday);
			//strName.append(chAr);
			//sprintf_s(chAr,"%02d",(tmInfo->tm_year-100));
			//strName.append(chAr);
			//strName.append("_");

			//sprintf_s(chAr,"%02d",tmInfo->tm_hour);
			//strName.append(chAr);
			//sprintf_s(chAr,"%02d",tmInfo->tm_min);
			//strName.append(chAr);
			//sprintf_s(chAr,"%02d",tmInfo->tm_sec);
			//strName.append(chAr);
			//strName.append("_");

			////条代号，固定值01;周期号：
			//strName.append("01_");
			//int dbstrpNum=(int)fmtConv.getResult(imgInfoPs.loop_num);
			//sprintf_s(chAr,"%05d",dbstrpNum);
			//strName.append(chAr);
			//strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			sprintf_s(chAr,"%05d",stripNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt) + 900; // modify by zhang : 900, TODO check only outPutGMTIInfo() call this function
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");
			////有无损压缩
			//strName.append("Y002_");

			//飞机批号、飞机号
			//strName.append("01");
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

			if(sarModelNumTemp!=3)  // modify by zhang : SAR/GMTI mode number is 3?
			{
			//GMTI
			strName.append("MTI_");
			}
			else
			{
				/* ==== modify by zhang ==== */
				double transType = fmtConv.getResult(tskPs.transType);
				if(transType > 2)transType = 1;

				int rateCompress = (int)fmtConv.getResult(tskPs.imgCompRate);
			
				if(transType == 0){				  					
					strName.append("001_");
				}else{
					rateCompress = rateCompress > 999 ? 999 : rateCompress;
					sprintf_s(chAr, "%03d_", rateCompress);
					strName.append(chAr);
				}

#if 0
			//压缩比
			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);
			sprintf_s(chAr,"%03d",rateCompress);
			strName.append(chAr);
			strName.append("_");
			//strName.append("008_");
#endif
				/* ========================= */
			}
			
			strName.append("0703");

			UINT32 wkMd=(UINT32)fmtConv.getResult(imgInfoPs.work_mode);
				
			UINT32 work_mode=(wkMd>>16) & 0x0F;

			switch (sarResIndex2)
				{
				case 1:
					strName.append("04");//0.3米聚束
					break;
				case 2:
					strName.append("01");//0.5米条带
					break;
				case 3:
					strName.append("02");//1米条带
					break;
				case 4:            //3米
					if((int)work_mode==0)
					{
						strName.append("03");
					}
					else
					{
						strName.append("05");
					}
					break;
				case 5:          //5米
					strName.append("06");
					break;
				case 6:
					strName.append("07");
					break;
				case 7:
					strName.append("08");
					break;
				}

			return strName;
		}
		//生成不叠加点迹的图像名称
		string commonFuncs::getRawPicName(UINT8 * ar,int stripNum)
		{
            string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			sprintf_s(chAr,"%05d",stripNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt);
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");


			//飞机批号、飞机号
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

            double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}

			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);

			if(transType==0)
				{				  					
					strName.append("001");
					strName.append("_");
					
				}
				else
				{
					rateCompress=rateCompress>999?999:rateCompress;
					sprintf_s(chAr,"%03d",rateCompress);
					strName.append(chAr);
					strName.append("_");
				}

			
			strName.append("0703");

			UINT32 wkMd=(UINT32)fmtConv.getResult(imgInfoPs.work_mode);
				
			UINT32 work_mode=(wkMd>>16) & 0x0F;

			switch (sarResIndex2)
				{
				case 1:
					strName.append("04");//0.3米聚束
					break;
				case 2:
					strName.append("01");//0.5米条带
					break;
				case 3:
					strName.append("02");//1米条带
					break;
				case 4:            //3米
					if((int)work_mode==0)
					{
						strName.append("03");
					}
					else
					{
						strName.append("05");
					}
					break;
				case 5:          //5米
					strName.append("06");
					break;
				case 6:
					strName.append("07");
					break;
				case 7:
					strName.append("08");
					break;
				}

			return strName;
		}
		
		string commonFuncs::getCombPicName(UINT8 * ar,int stripNum)
		{
			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			sprintf_s(chAr,"%05d",stripNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt)+800;
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");


			//飞机批号、飞机号
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

            double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}

			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);

			if(transType==0)
				{				  					
					strName.append("001");
					strName.append("_");
					
				}
				else
				{
					rateCompress=rateCompress>999?999:rateCompress;
					sprintf_s(chAr,"%03d",rateCompress);
					strName.append(chAr);
					strName.append("_");
				}

			
			strName.append("0703");

			UINT32 wkMd=(UINT32)fmtConv.getResult(imgInfoPs.work_mode);
				
			UINT32 work_mode=(wkMd>>16) & 0x0F;

			switch (sarResIndex2)
				{
				case 1:
					strName.append("04");//0.3米聚束
					break;
				case 2:
					strName.append("01");//0.5米条带
					break;
				case 3:
					strName.append("02");//1米条带
					break;
				case 4:            //3米
					if((int)work_mode==0)
					{
						strName.append("03");
					}
					else
					{
						strName.append("05");
					}
					break;
				case 5:          //5米
					strName.append("06");
					break;
				case 6:
					strName.append("07");
					break;
				case 7:
					strName.append("08");
					break;
				}

			return strName;
		}
	    
		string commonFuncs::getDataName(UINT8 * ar,int stripNum)
		{
			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			sprintf_s(chAr,"%05d",stripNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt);
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");

			//飞机批号、飞机号
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

			double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}
			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);

			
			if(transType==0)
			{
				//GMTI
				strName.append("M00_");
			}
			else
			{
				strName.append("M01_");
			}
			
			strName.append("0703");

			//
			if(sarModelNumTemp==3)//sarGMTI
			{
				strName.append("03");
			}
			else if(sarModelNumTemp==4)
			{
				strName.append("00");
			}

			return strName;

		}
	    
		string commonFuncs::getMarkPicName(UINT8 *ar,int stripNum)
		{
 
			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			sarImageInfoPosition imgInfoPs;
			imgInfoPs.initial();

			muInfoPosition ps;
			ps.initial();

			fmtConvCl  fmtConv(ar);
			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			
			int itDate=(int)fmtConv.getResult(ps.date_year);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_month);

			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.date_day);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);


			strName.append("_");

			itDate=(int)fmtConv.getResult(ps.time_hour);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_minutes);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			itDate=(int)fmtConv.getResult(ps.time_second);
			sprintf_s(chAr,"%02d",itDate);
			strName.append(chAr);

			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			sprintf_s(chAr,"%05d",stripNum);
			strName.append(chAr);
			strName.append("_");

			//sar模式
			int sarModelNumTemp=getSarModel(ar);

			//分辨率
			UINT32 sarResIndex1=(UINT32)fmtConv.getResult(imgInfoPs.sarRes);
			int sarResIndex2=sarResIndex1>>25 & 0x07;

			//开机次数
			int powerOnTime=(int)fmtConv.getResult(tskPs.powerOnCnt)+900;
			sprintf_s(chAr,"%03d",powerOnTime);
			strName.append(chAr);

			strName.append("_");

			//飞机批号、飞机号
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");

			double transType=fmtConv.getResult(tskPs.transType);
			double tTypeU=transType;
			//时传经常出现数值很大的SB错误,所以弄个补丁
			if(tTypeU>2)
			{ 
				transType=1;
			}
			int rateCompress=(int)fmtConv.getResult(tskPs.imgCompRate);

			if(transType==0)
				{				  					
					strName.append("001");
					strName.append("_");					
				}
				else
				{
					rateCompress=rateCompress>999?999:rateCompress;
					sprintf_s(chAr,"%03d",rateCompress);
					strName.append(chAr);
					strName.append("_");
				}
			
			strName.append("0703");

			UINT32 wkMd=(UINT32)fmtConv.getResult(imgInfoPs.work_mode);
				
			UINT32 work_mode=(wkMd>>16) & 0x0F;
			
			switch (sarResIndex2)
			{
			case 1:
				strName.append("04");//0.3米聚束
				break;
			case 2:
				strName.append("01");//0.5米条带
				break;
			case 3:
				strName.append("02");//1米条带
				break;
			case 4:            //3米 条带和sarGMTI都有三米模式
				if((int)work_mode==0)
				{
					strName.append("03");
				}
				else
				{
					strName.append("05");
				}
				break;
			case 5:          //5米
				strName.append("06");
				break;
			case 6:
				strName.append("07");
				break;
			case 7:
				strName.append("08");
				break;
			}

			return strName;
		}
		//以当前时间为标准
		string commonFuncs::getNameLocalTime(UINT8* ar,int stripNum)
		{
			string strName;
			char   chAr[64];			
	
			taskInfoPosition tskPs;
			tskPs.initial();

			fmtConvCl  fmtConv(ar);

			int dbTaskCode=(int)fmtConv.getResult(tskPs.missionCodes);
			sprintf_s(chAr,"%04d",dbTaskCode);
			strName.append(chAr);
			strName.append("_");

			//获取日期、时间
			time_t rawTime;
			struct tm * tmInfo;
			time(&rawTime);
			tmInfo=localtime(&rawTime);
			sprintf_s(chAr,"%02d",tmInfo->tm_mon+1);
			strName.append(chAr);
			sprintf_s(chAr,"%02d",tmInfo->tm_mday);
			strName.append(chAr);
			sprintf_s(chAr,"%02d",(tmInfo->tm_year-100));
			strName.append(chAr);
			strName.append("_");

			sprintf_s(chAr,"%02d",tmInfo->tm_hour);
			strName.append(chAr);
			sprintf_s(chAr,"%02d",tmInfo->tm_min);
			strName.append(chAr);
			sprintf_s(chAr,"%02d",tmInfo->tm_sec);
			strName.append(chAr);
			strName.append("_");

			//条代号，固定值01;周期号：
			strName.append("01_");
			sprintf_s(chAr,"%05d",stripNum);
			strName.append(chAr);
			strName.append("_");
			
			//有无损压缩
			strName.append("Y002_");
			//飞机批号、飞机号
			strName.append("01");
			int dbPlaneNum=(int)fmtConv.getResult(tskPs.planeNum);
			sprintf_s(chAr,"%04d",dbPlaneNum);
			strName.append(chAr);
			strName.append("_");
			//压缩比
			strName.append("08_");
			//
			strName.append("0703");
			//string str9(asctime(tmInfo));
			return strName;
		}
		//搜索到01dcef18,则返回帧头位置，否则返回-1
		int commonFuncs::getHeadPosition(UINT8 *dataAr,int arLen)
		{

			const int *dtahead=DT_HEAD;
			int headLen=HD_LEN;
			int cntAr=0;
			int cntHd=0;
			while(cntAr<arLen&&cntHd<headLen)
			{
				
				if(dataAr[cntAr]==dtahead[cntHd])
				{
					cntAr++;
					cntHd++;
				}
				else
				{
					cntAr=cntAr-cntHd+1;
					cntHd=0;
				}
			}

			if(cntHd==headLen)
			{
				return (cntAr-headLen);
			}
			else
			{
				return -1;
			}
  
		}
		//搜索到55AA55AA,则返回帧头位置，否则返回-1
		int commonFuncs::getHead6SuoDatePosition(UINT8 *dataAr,int arLen)
		{

			const int *dtahead=DT6Suo_HEAD;
			int headLen=HD_LEN;
			int cntAr=0;
			int cntHd=0;
			while(cntAr<arLen&&cntHd<headLen)
			{
				
				if(dataAr[cntAr]==dtahead[cntHd])
				{
					cntAr++;
					cntHd++;
				}
				else
				{
					cntAr=cntAr-cntHd+1;
					cntHd=0;
				}
			}

			if(cntHd==headLen)
			{
				return (cntAr-headLen);
			}
			else
			{
				return -1;
			}
  
		}
		
		int commonFuncs::getHead6SuoDateFrameLen(UINT8 *dataAr)
		{
			int mdPs=2*0x04;
			fmtConvCl fmtCnv(dataAr);		
			UINT32 md=fmtCnv.byteToUint32(mdPs);			
			return	md; 
		}

		int commonFuncs::getHeadPosition(UINT8 *dataAr,int arLen,int *rePos)
		{
			const int *dtahead=DT_HEAD;
			int headLen=HD_LEN;
			int cntHd=0;
			int cntAr=0;
			int posLen=0;
			while(cntAr<arLen)
			{
				if(dataAr[cntAr]==dtahead[cntHd])
				{										
					if(cntHd==(headLen-1))
					{
						posLen++;
						rePos[posLen-1]=(cntAr-cntHd);	
						//debug info
						logRecords("frame position:",posLen-1);
						//调整帧头计数
						cntHd=-1;
					}
					cntAr++;
					cntHd++;
				}
				else
				{
					cntAr=cntAr-cntHd+1;
					cntHd=0;
				}

			}

				return posLen;
			
		}

		int commonFuncs::getSarModel(UINT8 * ar)
		{
			
			int mdPs=4*0x04;
			fmtConvCl fmtCnv(ar);
		
			UINT32 mdTemp=fmtCnv.byteToUint32(mdPs);

			int md=(mdTemp>>16)&0x0F;
			
			return	md;

		}

		int commonFuncs::getSarRes(UINT8 *ar)
		{
		
			//分辨率
            int mdPs=4*0x0F;
			fmtConvCl fmtCnv(ar);
		
			UINT32 mdTemp=fmtCnv.byteToUint32(mdPs);
			int md=(mdTemp>>25) & 0x07;
			
			return	md;
		}

		int commonFuncs::getRangePoints(UINT8 *ar)
		{
			stParInFrame ptFr;
			ptFr.startPosion=510;
			ptFr.numType=uInt16Enm;
			ptFr.unit=512;

			fmtConvCl fmtConv(ar);
			return  (int)fmtConv.getResult(ptFr);

		}

		int commonFuncs::searchHeadPosition(FILE * FL)
		{
			int hdLen=512;//帧头有512个字节
			UINT32 step=513*100;

			UINT8 *searchBuffer=new UINT8[step];
			UINT8 *headerAr=new UINT8[hdLen];
			int endMark=feof(FL);

			while(endMark==0)
			{
			  UINT32 rdState=fread(searchBuffer,sizeof(UINT8),step,FL);

			  if(rdState<hdLen)
			  {
				  endMark=feof(FL);
				  break;
			  }

			  int re=getHeadPosition(searchBuffer,rdState);
			  
			  if(re!=-1)
			  {
				 
				 fseek(FL,re-rdState,SEEK_CUR);
				 break;
			  }	 
			  else 
			  {				 
					//防止帧头标志位处于两帧分割之间
					fseek(FL,-1*HD_LEN,SEEK_CUR);
			  }	

			}

			delete [] searchBuffer;
			delete [] headerAr;

			return endMark; 
		}

		int commonFuncs::searchHeadPositionX64(FILE * FL)
		{

			int hdLen=512;//帧头有512个字节
			UINT32 step=512*100;

			UINT8 *searchBuffer=new UINT8[step];
			UINT8 *headerAr=new UINT8[hdLen];
			int endMark=feof(FL);

			while(endMark==0)
			{
			  UINT32 rdState=fread(searchBuffer,sizeof(UINT8),step,FL);
			  int re=getHeadPosition(searchBuffer,rdState);
			  
			  if(re!=-1)
			  {
				/* long ll1=ftell(FL);
				 long gg1=_ftelli64(FL);*/
                 long backDis=re-rdState;
				 //fseek(FL,re-rdState,SEEK_CUR);
				 int pp=_fseeki64(FL,backDis,SEEK_CUR);
				 /*long ll=ftell(FL);
				 long gg=_ftelli64(FL);*/
				 break;
			  }	 

			   endMark=feof(FL);
			}

			delete [] searchBuffer;
			delete [] headerAr;

			return endMark;
		}

		template <class T>
		void commonFuncs::logRecords(char* chMessage,T cnt)
		{// modified by Yunhua-Luo is OK 2016/1/5

			FILE * FL;
			double temp = double(cnt);
			if(recordsPrint==true)
			{
			   FILE * FL;
			   if((FL=fopen("log.txt","a"))==NULL) return;
			   fprintf(FL,"%s %.2f\n",chMessage,temp);			   
			   fclose(FL);
			}
		}

		UINT64 commonFuncs::getPRFNum(UINT8 * ar)
		{
			stParInFrame prfNumPs;
			prfNumPs.startPosion=4;
			prfNumPs.numType=uInt32Enm;
			prfNumPs.unit=1;

			fmtConvCl fmtConv(ar);
			return  (UINT64)fmtConv.getResult(prfNumPs);
		}

		int commonFuncs::getNewGYAimsNum(UINT8 *ar)
		{
			NewGYAimInfoPosition ps;
			ps.initial();
			commonFuncs cmFuncs;
			fmtConvCl fmtConv(ar);			
			int asNum=fmtConv.getBigEndianResult(ps.aimsNum);
			return asNum;
		}

		int commonFuncs::getMViewNum(UINT8 *ar)
		{
			stParInFrame multipleViewPs;			
			multipleViewPs.startPosion=4*0x22;
			multipleViewPs.numType=uInt32Enm;
			multipleViewPs.unit=1;

			fmtConvCl fmtConv(ar);

			UINT32 resTemp=(UINT32)fmtConv.getResult(multipleViewPs);
			int res=resTemp>>24;
			return  res;
		}

		int commonFuncs::getPowerOnTime(UINT8 * ar)
		{
			taskInfo tskInfo(ar);

			return (int)tskInfo.powerOnCnt;
			
		}

		string commonFuncs::getSysTime(FILE *fl)
		{
			string strName;

			char chAr[64];
			
			//获取日期、时间
			time_t rawTime;
			struct tm * tmInfo;
			time(&rawTime);
			tmInfo=localtime(&rawTime);
						
			sprintf_s(chAr,"%02d",(tmInfo->tm_year-100));
			strName.append(chAr);
			sprintf_s(chAr,"%02d",tmInfo->tm_mon+1);
			strName.append(chAr);
			sprintf_s(chAr,"%02d",tmInfo->tm_mday);
			strName.append(chAr);
			strName.append("  ");
			sprintf_s(chAr,"%02d",tmInfo->tm_hour);
			strName.append(chAr);
			strName.append(":");
			sprintf_s(chAr,"%02d",tmInfo->tm_min);
			strName.append(chAr);
			strName.append(":");
			sprintf_s(chAr,"%02d",tmInfo->tm_sec);
			strName.append(chAr);

			if(fl!=NULL)
			{				
              fprintf(fl,"系统时间:%s\n",strName.c_str());
			}

			return strName;
		}
		
		bool commonFuncs::getIfSarGmtiAim(UINT8 * ar)
		{
			unsigned char aimsInfoTemp=ar[sarGmtiAimPos];

			if(aimsInfoTemp==0x55)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		
		//各种模式参数输出
		sarModel::sarModel(UINT8* arIn,string str)
		{
			ar=arIn;
			rootPath=str+"\\";
		}

		int sarModel::outPutSarInfo()
		{			
			
			//方位向号码
		    static int loopNum=0;
		    int pwOnTime=1;


			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);
			
			/* ==== add by zhang : reset power on time ==== */
			static int lastPowerOnTime = -1;
			int currentPowerOnTime = cmFuncs.getPowerOnTime(ar);
			if(currentPowerOnTime != lastPowerOnTime){
				lastPowerOnTime = currentPowerOnTime;
				loopNum = 0;
			}
			/* ============================================= */

			//if(pwOnTime==(cmFuncs.getPowerOnTime(ar)-1))
			//{
			//	loopNum=0;
			//  pwOnTime++;
			//}

			/*if(md==3||md==4)
			{
				
				return ERROR_MODEL;
			}*/
	
			string nameStr=rootPath.append(cmFuncs.getRawPicName(ar,loopNum))+".txt";

			int pathLen=nameStr.length();
	
			char * nameCh=new char[pathLen+1];

			for(int i=0;i<pathLen;i++)
			{
				nameCh[i]=nameStr[i];
			}
			nameCh[pathLen]='\0';

			FILE * FL=fopen(nameCh,"a");

			if(FL==NULL)
			{
				if(nameCh!=NULL)
				{
				  delete []nameCh;
				  nameCh=NULL;
				}
				return ERROR_PATH;
			}


			taskInfo task(ar);
			task.output(FL);

			sarImageInfo sarImageInfo(ar);
			//同步文件名字中的loopnum和txt中的loopnum
			sarImageInfo.loop_num=loopNum;
			sarImageInfo.output(FL);

			muInfo mu(ar);
			mu.output(FL);

			loopNum++;

			delete [] nameCh;
			fclose(FL);
			return 0;
		}

		GMTIModel::GMTIModel(UINT8* arIn,string str)
		{
			ar=arIn;
			rootPath=str;
			sockM=NULL;
			sockfd=NULL;
			multicast_init();
			lastPlaneLon=0;
			lastPlaneLat=0;
			gmtiAimPt=NULL;
		}
		
		int GMTIModel::multicast_init()
		{
			
			//获取组播IP
			std::ifstream fin("iniDzs.txt",std::ios::in);
			if(!fin)
			{
				return -1;
			}
			
			char ipAr[64]={0};
			char portAr[8]={0};
			fin.getline(ipAr, sizeof(ipAr));
			fin.getline(portAr,sizeof(portAr));
			int lenPortAr=strlen(portAr);
			int portNum=portAr[0]-'0';
			for(int i=1;i<lenPortAr;i++)
			{
				int iTemp=portAr[i]-'0';
				portNum=10*portNum+iTemp;
			}

			if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0)
				{
				return -1;
				}
         
				sockfd=WSASocket(AF_INET,SOCK_DGRAM,0,NULL,
					0,WSA_FLAG_MULTIPOINT_C_LEAF|WSA_FLAG_MULTIPOINT_D_LEAF|WSA_FLAG_OVERLAPPED);
				
				if(sockfd==INVALID_SOCKET)
				{
				  return -1;
				}   
  
				memset(&servaddr,0, sizeof(servaddr));  
				servaddr.sin_family = AF_INET;  
				servaddr.sin_addr.s_addr = inet_addr(ipAr);  
				servaddr.sin_port=htons(portNum);
				sockM=WSAJoinLeaf(sockfd,(SOCKADDR*)&servaddr,sizeof(servaddr),NULL,NULL,NULL,NULL,JL_BOTH);
				if(sockM==INVALID_SOCKET)
				{
				  return -1;
				} 

			return 0;		
		}

		int GMTIModel::outPutGMTIInfo()
		{		

			
		    static int loopNum=0;
		    int pwOnTime=0;
			commonFuncs cmFuncs;
			//if(loopNum==0)
			//{
				pwOnTime=cmFuncs.getPowerOnTime(ar);
			//}

			//if(pwOnTime!=cmFuncs.getPowerOnTime(ar))
			//{
			//	loopNum=0;
			//}

			//融合，对收到的图像进行计算
			static int cntRecvpLoop=0;
			static char * imgAr=NULL;
			static int  tifWidthLast=0;
			int tifWidth;

			static int stTemp=0;
			static char mergePath[4][128];

			int md=cmFuncs.getSarModel(ar);
			

			if(md!=3)
			{
				//cmFuncs.logRecords("广域GMTI中的sarModel错误",0);
				return ERROR_MODEL;
			}
			//判断是点还是图
			bool ifAimsInfo=cmFuncs.getIfSarGmtiAim(ar);

			string namePicStr=rootPath;
			//拆分后的路径
			string nameStr=rootPath+cmFuncs.getDataName(ar,loopNum)+".txt";
			string nameAim=rootPath+cmFuncs.getDataName(ar,loopNum)+"_M.txt";
			//
			int pathLen=nameStr.length();
	
			char * nameCh=new char[pathLen+1];
			char * nameAimCh=new char[nameAim.length()+1];

			strcpy(nameAimCh,nameAim.c_str());

			for(int i=0;i<pathLen;i++)
			{
				nameCh[i]=nameStr[i];
			}
			nameCh[pathLen]='\0';

			FILE * FL=fopen(nameCh,"a");

			if(FL==NULL)
			{
				
				delete [] nameCh;
				nameCh=NULL;

				delete [] nameAimCh;
				nameAimCh=NULL;

				return ERROR_PATH;
			}			

			taskInfo task(ar);
			task.output(FL);

			sarImageInfo sarImageInfo(ar);
			sarImageInfo.loop_num=loopNum;
			sarImageInfo.output(FL);

			muInfo mu(ar);
			mu.output(FL);
			fclose(FL);

			if(ifAimsInfo)
			{
				FILE * FLAim=fopen(nameAimCh,"a");
				if(FLAim==NULL)
				{
					return ERROR_PATH;
				}
				sarGMTIAimInfo gmtiAim(ar);
				gmtiAim.output(FLAim);
				fclose(FLAim);
				/******************融合逻辑判断***************************/

				formGIFFromFengJinCl sarGmtiMergeCl;

				int aimNumTemp=gmtiAim.aimsNum;

				long *aimAzPts=new long[aimNumTemp];
				long *aimRgPts=new long[aimNumTemp];

				for(int p=0;p<aimNumTemp;p++)
				{
					aimAzPts[p]=(long)gmtiAim.aimAzimuthPoints[p];
					aimRgPts[p]=(long)gmtiAim.aimRangePoints[p];
				}
				
				char path[512];

				sprintf(path,"D:\\restoreInfo\\sarGMTI\\merge\\a%d.tiff",stTemp);
				stTemp++;

				//sarGmtiMergeCl.sarGmti_Aim_Mark(path,imgAr,aimAzPts,aimRgPts,gmtiAim.aimV,tifWidthLast,512*cntRecvpLoop,gmtiAim.aimsNum);
				sarGmtiMergeCl.sarGmti_Aim_Mark(mergePath,imgAr,aimAzPts,aimRgPts,gmtiAim.aimV,tifWidthLast,512*cntRecvpLoop,gmtiAim.aimsNum);
				
				delete []aimAzPts;
				delete []aimRgPts;
				delete []imgAr;
				cntRecvpLoop=0;
				/******************************************************/
			}
			else
			{
				/**********************************************/
				/*imgProc imgCon(ar,namePicStr);			
				SAR_VS_params stPars;
				commonFuncs cmFuncs;
				string flPath=namePicStr.append(cmFuncs.getName(ar)+".tif");
				imgCon.SAR_VS_params_init(stPars);
				stPars.output_file_name=flPath;
				stPars.tifParams.dataMat=ar;
				stPars.tifParams.dtHeight=512;
				stPars.tifParams.dtWidth=cmFuncs.getRangePoints(ar);
				imgCon.Local_Funcs1(stPars);*/
				/******************融合逻辑判断***************************/
				//判断是否第一次，并且初始化存储数组
				if(cntRecvpLoop==0)
				{
					tifWidth=cmFuncs.getRangePoints(ar);
					tifWidthLast=tifWidth;
					imgAr=new char[tifWidth*512*4];
					memcpy(imgAr,&(ar[512]),tifWidth*512);
					
					//记住名字					
					//记住名字					
					string strTemp=rootPath+cmFuncs.getName(ar)+"_merge.tiff";
					strcpy(mergePath[cntRecvpLoop],strTemp.c_str());

					cntRecvpLoop++;
				}
				else
				{
				    tifWidth=cmFuncs.getRangePoints(ar);

					if(tifWidth==tifWidthLast&&cntRecvpLoop<5)
					{
                     memcpy(&(imgAr[tifWidth*512*cntRecvpLoop]),&(ar[512]),tifWidth*512);

					//记住名字					
					string strTemp=rootPath+cmFuncs.getName(ar)+"_merge.tiff";
					strcpy(mergePath[cntRecvpLoop],strTemp.c_str());

					cntRecvpLoop++;
					}
					else
					{
						delete []imgAr;
						cntRecvpLoop=0;
					}
				}

				/*********************************************/
				/*imgProc imgCon(ar,namePicStr);
				int rtRes=imgCon.creatTif();
				if(rtRes!=0)
				{
					delete [] nameCh;
			        fclose(FL);
					return ERROR_TIFF;
				}*/
			}
			delete [] nameCh;
			delete [] nameAimCh;
			
			//周期号码
			loopNum++;

			return 0;

		}

		int GMTIModel::outPutTxtInfo()
		{
			static int loopNum=0;
		    int pwOnTime=0;
			commonFuncs cmFuncs;
			//if(loopNum==0)
			//{
				pwOnTime=cmFuncs.getPowerOnTime(ar);
			//}

			//if(pwOnTime!=cmFuncs.getPowerOnTime(ar))
			//{
			//	loopNum=0;
			//}
			
			int md=cmFuncs.getSarModel(ar);
			
			if(md!=3)
			{				
				return ERROR_MODEL;
			}
			//判断是点还是图
			bool ifAimsInfo=cmFuncs.getIfSarGmtiAim(ar);

			string namePicStr=rootPath;
			//拆分后的路径
			string nameStr=rootPath+cmFuncs.getDataName(ar,loopNum)+".txt";
			string nameAim=rootPath+cmFuncs.getDataName(ar,loopNum)+"_M.txt";
			//
			int pathLen=nameStr.length();
	
			char * nameCh=new char[pathLen+1];
			char * nameAimCh=new char[nameAim.length()+1];

			strcpy(nameAimCh,nameAim.c_str());

			for(int i=0;i<pathLen;i++)
			{
				nameCh[i]=nameStr[i];
			}
			nameCh[pathLen]='\0';

			FILE * FL=fopen(nameCh,"a");

			if(FL==NULL)
			{
				
				delete [] nameCh;
				nameCh=NULL;

				delete [] nameAimCh;
				nameAimCh=NULL;

				return ERROR_PATH;
			}			

			taskInfo task(ar);
			task.output(FL);

			sarImageInfo sarImageInfo(ar);
			sarImageInfo.loop_num=loopNum;
			sarImageInfo.output(FL);

			muInfo mu(ar);
			mu.output(FL);
			fclose(FL);

			if(ifAimsInfo)
			{
				FILE * FLAim=fopen(nameAimCh,"a");
				if(FLAim==NULL)
				{
					return ERROR_PATH;
				}
				if(gmtiAimPt!=NULL)
			    {
					gmtiAimPt->output(FLAim);
			    }
				else
				{
					sarGMTIAimInfo gmtiAim(ar,lastPlaneLon,lastPlaneLat);
				    gmtiAim.output(FLAim);
				}
				//
				fclose(FLAim);

			}
			delete [] nameCh;
			delete [] nameAimCh;
			
			//周期号码
			loopNum++;

			return 0;
		}
		

		// ******** SAR/GMTI发送点迹到电子地图 2015/12/17 *************
		int  GMTIModel::outPutGMTIData()
		{

			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);
			static int aScanMdAngle=0;
			static string dataName=cmFuncs.getDataName(ar,0);

			if(md!=3)
			{
				return ERROR_MODEL;
			}

			string gyDatInfoName=rootPath;
			gyDatInfoName.append(dataName+".dat");
			taskInfo task(ar);  
			muInfo mu(ar);
			sarImageInfo imgPars(ar);
			GYParsInfo GYPars(ar);
			//sarGMTIAimInfo gmtiAim(ar,lastPlaneLon,lastPlaneLat);
			
			if(gmtiAimPt==NULL)
			{
				return -1;
			}

			//UINT16 aimNms=gmtiAim.aimsNum;
			UINT16 aimNms=gmtiAimPt->aimsNum;
			
			//用于发送
			char * sendFlName="sarGMTISend.dat";
			FILE * FLSend=fopen(sendFlName,"wb");

			FILE * FL=fopen(gyDatInfoName.c_str(),"ab");

			//数据包信息
			UINT32 *packetInfo=new UINT32[3];
			packetInfo[0]=0X55AA55AA;
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FLSend);
			packetInfo[1]=1;
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FLSend);
			packetInfo[2]=216+aimNms*40; 
            fwrite(&(packetInfo[2]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[2]),sizeof(UINT32),1,FLSend);

			
			UINT16 taskCode=(UINT16)(task.missionCodes);
            //12
			fwrite(&taskCode,sizeof(UINT16),1,FL);//任务代号
			fwrite(&taskCode,sizeof(UINT16),1,FLSend);//任务代号
			//
			UINT8 planeType=7;

			fwrite(&planeType,sizeof(UINT8),1,FL);//飞行器类型
			fwrite(&planeType,sizeof(UINT8),1,FLSend);//飞行器类型

			UINT8 planePP=0;

			fwrite(&planePP,sizeof(UINT8),1,FL);//飞机批号
			fwrite(&planePP,sizeof(UINT8),1,FLSend);//飞机批号

			UINT16 planeCode=(UINT16)(task.planeNum);
			
			fwrite(&planeCode,sizeof(UINT16),1,FL);//飞机号 
			fwrite(&planeCode,sizeof(UINT16),1,FLSend);//飞机号
             //18
			UINT8 picCompress=0;
			fwrite(&picCompress,sizeof(UINT8),1,FL);//图像压缩比
			fwrite(&picCompress,sizeof(UINT8),1,FLSend);//图像压缩比

			UINT8 transType=(UINT8)task.transType;
			fwrite(&transType,sizeof(UINT8),1,FL);//传输方式
			fwrite(&transType,sizeof(UINT8),1,FLSend);//传输方式

			UINT8 loadType=3;
			fwrite(&loadType,sizeof(UINT8),1,FL);
			fwrite(&loadType,sizeof(UINT8),1,FLSend);

			UINT32 loadCode=0;
			fwrite(&loadCode,sizeof(UINT32),1,FL);
			fwrite(&loadCode,sizeof(UINT32),1,FLSend);
            //25
			UINT16 powerOn=(UINT16)GYPars.powerOnTimes;
			fwrite(&powerOn,sizeof(UINT16),1,FL);
			fwrite(&powerOn,sizeof(UINT16),1,FLSend);

			cmFuncs.logRecords("GMTI开机次数：",powerOn);

			UINT32 muCode=0;
			fwrite(&muCode,sizeof(UINT32),1,FL);
			fwrite(&muCode,sizeof(UINT32),1,FLSend);
            //31
			UINT16 year=(UINT16)mu.date_year;
			fwrite(&year,sizeof(UINT16),1,FL);
			fwrite(&year,sizeof(UINT16),1,FLSend);
             //33
			UINT8 month=(UINT8)mu.date_month;
			fwrite(&month,sizeof(UINT8),1,FL);
			fwrite(&month,sizeof(UINT8),1,FLSend);

			UINT8 day=(UINT8)mu.date_day;
			fwrite(&day,sizeof(UINT8),1,FL);
			fwrite(&day,sizeof(UINT8),1,FLSend);

			UINT8 hour=(UINT8)mu.time_hour;
			fwrite(&hour,sizeof(UINT8),1,FL);
			fwrite(&hour,sizeof(UINT8),1,FLSend);

			UINT8 minutes=(UINT8)mu.time_minutes;
			fwrite(&minutes,sizeof(UINT8),1,FL);
			fwrite(&minutes,sizeof(UINT8),1,FLSend);

			UINT8 seconds=(UINT8)mu.time_second;
			fwrite(&seconds,sizeof(UINT8),1,FL);
			fwrite(&seconds,sizeof(UINT8),1,FLSend);

			UINT16 mseconds=(UINT16)mu.time_m_second;
			fwrite(&mseconds,sizeof(UINT16),1,FL);
			fwrite(&mseconds,sizeof(UINT16),1,FLSend);
             //40
			double plane_Long=(double)mu.plane_longitude;
			fwrite(&plane_Long,sizeof(double),1,FL);
			fwrite(&plane_Long,sizeof(double),1,FLSend);
			double plane_Lat=(double)mu.plane_latitude;
			fwrite(&plane_Lat,sizeof(double),1,FL);//
			fwrite(&plane_Lat,sizeof(double),1,FLSend);//

			cmFuncs.logRecords("GMTI载机经度：",plane_Long);
			cmFuncs.logRecords("GMTI载机纬度：",plane_Lat);

			float * flt=new float[22];
             //56
			flt[0]=(float)mu.plane_height;
			fwrite(&(flt[0]),sizeof(float),1,FL);
			fwrite(&(flt[0]),sizeof(float),1,FLSend);

			flt[1]=(float)mu.plane_aim_height;
			fwrite(&(flt[1]),sizeof(float),1,FL);
			fwrite(&(flt[1]),sizeof(float),1,FLSend);

			flt[2]=(float)mu.plane_direction_angle;
			fwrite(&(flt[2]),sizeof(float),1,FL);
			fwrite(&(flt[2]),sizeof(float),1,FLSend);

			//航向角加速率
			flt[3]=(float)mu.plane_departure_angle;
			fwrite(&(flt[3]),sizeof(float),1,FL);
			fwrite(&(flt[3]),sizeof(float),1,FLSend);

			flt[4]=(float)mu.plane_departure_angle;
			fwrite(&(flt[4]),sizeof(float),1,FL);
			fwrite(&(flt[4]),sizeof(float),1,FLSend);

			//俯仰角
			flt[5]=(float)mu.plane_dive_angle;
			fwrite(&(flt[5]),sizeof(float),1,FL);
			fwrite(&(flt[5]),sizeof(float),1,FLSend);

			flt[6]=(float)mu.plane_dive_angle_V;
			fwrite(&(flt[6]),sizeof(float),1,FL);
			fwrite(&(flt[6]),sizeof(float),1,FLSend);

			flt[7]=(float)mu.plane_dive_angle_a;
			fwrite(&(flt[7]),sizeof(float),1,FL);
			fwrite(&(flt[7]),sizeof(float),1,FLSend);

			//横滚角
			flt[8]=(float)mu.plane_hor_angle;
			fwrite(&(flt[8]),sizeof(float),1,FL);
			fwrite(&(flt[8]),sizeof(float),1,FLSend);

            flt[9]=(float)mu.plane_hor_angle_v;
			fwrite(&(flt[9]),sizeof(float),1,FL);
			fwrite(&(flt[9]),sizeof(float),1,FLSend);

			flt[10]=(float)mu.plane_hor_angle_a;
			fwrite(&(flt[10]),sizeof(float),1,FL);
			fwrite(&(flt[10]),sizeof(float),1,FLSend);

			//
			flt[11]=(float)mu.plane_departure_angle;
			fwrite(&(flt[11]),sizeof(float),1,FL);
			fwrite(&(flt[11]),sizeof(float),1,FLSend);

			flt[12]=(float)mu.plane_de_flow_angle;
			fwrite(&(flt[12]),sizeof(float),1,FL);
			fwrite(&(flt[12]),sizeof(float),1,FLSend);

			flt[13]=(float)mu.plane_ground_v;
			fwrite(&(flt[13]),sizeof(float),1,FL);
			fwrite(&(flt[13]),sizeof(float),1,FLSend);

            flt[14]=(float)mu.plane_noair_v;
			fwrite(&(flt[14]),sizeof(float),1,FL);
			fwrite(&(flt[14]),sizeof(float),1,FLSend);

			flt[15]=(float)mu.plane_point_v;
			fwrite(&(flt[15]),sizeof(float),1,FL);
			fwrite(&(flt[15]),sizeof(float),1,FLSend);
			//
			flt[16]=(float)mu.plane_east_v;
			fwrite(&(flt[16]),sizeof(float),1,FL);
			fwrite(&(flt[16]),sizeof(float),1,FLSend);

			flt[17]=(float)mu.plane_north_v;
			fwrite(&(flt[17]),sizeof(float),1,FL);
			fwrite(&(flt[17]),sizeof(float),1,FLSend);

			flt[18]=(float)mu.plane_up_v;
			fwrite(&(flt[18]),sizeof(float),1,FL);
			fwrite(&(flt[18]),sizeof(float),1,FLSend);

			flt[19]=(float)mu.plane_east_a;
			fwrite(&(flt[19]),sizeof(float),1,FL);
			fwrite(&(flt[19]),sizeof(float),1,FLSend);

			flt[20]=(float)mu.plane_north_a;
			fwrite(&(flt[20]),sizeof(float),1,FL);
			fwrite(&(flt[20]),sizeof(float),1,FLSend);

			flt[21]=(float)mu.plane_up_a;
			fwrite(&(flt[21]),sizeof(float),1,FL);
			fwrite(&(flt[21]),sizeof(float),1,FLSend);

			/*fwrite(flt,sizeof(float),22,FL);
			fwrite(flt,sizeof(float),22,FLSend);*/

			if(flt!=NULL)
			{
				delete []flt;
				flt=NULL;
			}
             //22*4+56=144
			//天线帧编号
			UINT32 frameNum=(UINT32)GYPars.frameCodes;
			fwrite(&frameNum,sizeof(UINT32),1,FL);
			fwrite(&frameNum,sizeof(UINT32),1,FLSend);

			//波位数
			UINT16 waveNum=0;
			fwrite(&waveNum,sizeof(UINT16),1,FL);
			fwrite(&waveNum,sizeof(UINT16),1,FLSend);

			//波位号
			UINT16 waveCode=(UINT16)GYPars.waveCodes;
			fwrite(&waveCode,sizeof(UINT16),1,FL);
			fwrite(&waveCode,sizeof(UINT16),1,FLSend);

			//工作频段 侧视方式  工作模式 工作子模式
			UINT8 * FreqLS=new UINT8[4];
			FreqLS[0]=0;
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FLSend);

			FreqLS[1]=0;
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FLSend);

			FreqLS[2]=3; // SAR/GMTI
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FLSend);

			FreqLS[3]=0;
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FLSend);

			/*fwrite(FreqLS,sizeof(UINT8),4,FL);
			fwrite(FreqLS,sizeof(UINT8),4,FLSend);*/

			//156
			UINT32 *fNDistance=new UINT32[2];

			//cmFuncs.logRecords("SAR/GMTI最大距离：",GYPars.RFar);
			//cmFuncs.logRecords("SAR/GMTI最小距离：",GYPars.RNear);

			//最小、大作用距离
			if(abs(GYPars.RNear)>900.0e3 || abs(GYPars.RNear)<10.0e3)
			{
				fNDistance[1]=(UINT32 )180.0e3; // luo
			    fNDistance[0]=(UINT32 )120.0e3;;//dbRNear luo

				// return -1; // added by luo
			}
			else
			{
				fNDistance[1]=(UINT32 )GYPars.RFar;
			    fNDistance[0]=(UINT32 )GYPars.RNear;//dbRNear
			}

			//fNDistance[1]=(UINT32 )GYPars.RFar;
			//fNDistance[0]=(UINT32 )GYPars.RNear;//dbRNear

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FL);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FL);

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FLSend);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FLSend);
			//fwrite(fNDistance,sizeof(UINT32),2,FLSend);

			if(fNDistance!=NULL)
			{
				delete []fNDistance;
				fNDistance=NULL;
			}

			float * scanPar=new float[8];

			//天线帧扫描中心角		
			scanPar[0]=(float)((int)(mu.plane_direction_angle-imgPars.look_Side*90+360)%360);
			//cmFuncs.logRecords("GYGMTI天线帧扫描中心角：",scanPar[0]);
			fwrite(&(scanPar[0]),sizeof(float),1,FL);
			fwrite(&(scanPar[0]),sizeof(float),1,FLSend);
			
			//天线帧扫描范围
			scanPar[1]=2*(float)GYPars.scanScope;   // luo
			scanPar[1] = imgPars.beam_horz_width; // luo
			//cmFuncs.logRecords("GYGMTI天线帧扫描范围：",scanPar[1]);
			fwrite(&(scanPar[1]),sizeof(float),1,FL);
			fwrite(&(scanPar[1]),sizeof(float),1,FLSend);

			//方位波束中心角
			//scanPar[2]=(float)GYPars.azimuthCenterAngle; // luo
			scanPar[2] = (float)((int)(mu.plane_direction_angle-imgPars.look_Side*90+360)%360);
			
			//cmFuncs.logRecords("GYGMTI方位波束中心角：",scanPar[2]);
			
			fwrite(&(scanPar[2]),sizeof(float),1,FL);
			fwrite(&(scanPar[2]),sizeof(float),1,FLSend);

			//scanPar[2]=(float)(mu.plane_direction_angle-imgPars.look_Side*90);
            //方位波束宽度 ***************imgPars.beam_horz_width
			scanPar[3]=(float)imgPars.beam_horz_width;

			fwrite(&(scanPar[3]),sizeof(float),1,FL);
			fwrite(&(scanPar[3]),sizeof(float),1,FLSend);

			//scanPar[4]=(float)GYPars.azimuthAngle;
			//方位向扫描步进
			//scanPar[4]=(float)GYPars.scanStep;
			scanPar[4]=(int)imgPars.beam_horz_width;
			//cmFuncs.logRecords("GYGMTI方位向扫描步进：",scanPar[4]);
			fwrite(&(scanPar[4]),sizeof(float),1,FL);
			fwrite(&(scanPar[4]),sizeof(float),1,FLSend);
			//俯仰波束中心角
			scanPar[5]=imgPars.R_angle_new;
			//cmFuncs.logRecords("俯仰波束中心角：",imgPars.R_angle_new);
			fwrite(&(scanPar[5]),sizeof(float),1,FL);
			fwrite(&(scanPar[5]),sizeof(float),1,FLSend);
			//俯仰波束宽度
			scanPar[6]=imgPars.beam_R_width;
			//cmFuncs.logRecords("俯仰波束宽度：",imgPars.beam_R_width);
			fwrite(&(scanPar[6]),sizeof(float),1,FL);
			fwrite(&(scanPar[6]),sizeof(float),1,FLSend);
			//俯仰向扫描步进
			scanPar[7]=0;
			//cmFuncs.logRecords("俯仰向扫描步进：",0);
			fwrite(&(scanPar[7]),sizeof(float),1,FL);
			fwrite(&(scanPar[7]),sizeof(float),1,FLSend);
			//fwrite(scanPar,sizeof(float),8,FL);
			//fwrite(scanPar,sizeof(float),8,FLSend);
			if(scanPar!=NULL)
			{
				delete []scanPar;
				scanPar=NULL;
			}		

			UINT16 resPulseNum=(UINT16)GYPars.pulseResident;
			fwrite(&resPulseNum,sizeof(UINT16),1,FL);
			fwrite(&resPulseNum,sizeof(UINT16),1,FLSend);

			UINT16 resTime=0;
			fwrite(&resTime,sizeof(UINT16),1,FL);
			fwrite(&resTime,sizeof(UINT16),1,FLSend);
		    //分辨率
			float resolv=0;
			fwrite(&resolv,sizeof(float),1,FL);
			fwrite(&resolv,sizeof(float),1,FLSend);

			UINT32 PRF=(UINT32)GYPars.prf;
			fwrite(&PRF,sizeof(UINT32),1,FL);
			fwrite(&PRF,sizeof(UINT32),1,FLSend);

			UINT16 nullPs=0;
			fwrite(&nullPs,sizeof(UINT16),1,FL);
			fwrite(&nullPs,sizeof(UINT16),1,FLSend);

			fwrite(&aimNms,sizeof(UINT16),1,FL);
			fwrite(&aimNms,sizeof(UINT16),1,FLSend);

			for(int p=0;p<(gmtiAimPt->aimsNum);p++)
			{

			   UINT32 pointCodes=(UINT32)p;
			   fwrite(&pointCodes,sizeof(UINT32),1,FL);
			   fwrite(&pointCodes,sizeof(UINT32),1,FLSend);
               //序号
			   double pointLong=gmtiAimPt->aimLongitude[p];  //经度
			   fwrite(&pointLong,sizeof(double),1,FL);
			   fwrite(&pointLong,sizeof(double),1,FLSend);

			   double pointLat=gmtiAimPt->aimlatitude[p];  //纬度
			   fwrite(&pointLat,sizeof(double),1,FL);
			   fwrite(&pointLat,sizeof(double),1,FLSend);

			   float pointHeight=0;
			   fwrite(&pointHeight,sizeof(float),1,FL);
			   fwrite(&pointHeight,sizeof(float),1,FLSend);

			   float point_P_v=gmtiAimPt->aimV[p];
			   fwrite(&point_P_v,sizeof(float),1,FL);
			   fwrite(&point_P_v,sizeof(float),1,FLSend);

			   UINT32 img_LoopNum=0;
			   fwrite(&img_LoopNum,sizeof(UINT32),1,FL);
			   fwrite(&img_LoopNum,sizeof(UINT32),1,FLSend);

			   UINT32 rg_Num=0;
			   fwrite(&rg_Num,sizeof(UINT32),1,FL);
			   fwrite(&rg_Num,sizeof(UINT32),1,FLSend);


			   UINT32 az_num=0;
			   fwrite(&az_num,sizeof(UINT32),1,FL);
			   fwrite(&az_num,sizeof(UINT32),1,FLSend);
			}

			UINT32 packetTail=0X0D0D0D0D;
			fwrite(&packetTail,sizeof(UINT32),1,FL);
			fwrite(&packetTail,sizeof(UINT32),1,FLSend);

			fclose(FL);
			fclose(FLSend);

			FLSend=fopen(sendFlName,"rb");

			if(FLSend==NULL)
			{
				return -1;
			}

			fseek(FLSend,0, SEEK_END);
			int file_size = ftell(FLSend);
			fseek(FLSend,0,SEEK_SET);

			char * buffer=new char[file_size];			
			fread(buffer,sizeof(char),file_size,FLSend);
			fclose(FLSend);
			
		    int resTemp=sendto(sockfd, buffer,file_size, 0,  
				(struct sockaddr *)&servaddr, sizeof(sockaddr));

			return resTemp;

			//return 0;

		}

		int GMTIModel::outPutGMTIInfo(int loopNum)
		{			
			//融合，对收到的图像进行计算
			static int cntRecvpLoop=0;
			static char * imgAr=NULL;
			static int  tifWidthLast=0;
			int tifWidth;

			static int stTemp=0;
			static char mergePath[4][128];

			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);
			

			if(md!=3)
			{
				//cmFuncs.logRecords("广域GMTI中的sarModel错误",0);
				return ERROR_MODEL;
			}
			//判断是点还是图
			bool ifAimsInfo=cmFuncs.getIfSarGmtiAim(ar);
			string namePicStr=rootPath;
			//拆分后的路径
			string nameStr=rootPath+cmFuncs.getNameByLoopNum(ar,loopNum)+".txt";
			string nameAim=rootPath+"Aims\\"+cmFuncs.getNameByLoopNum(ar,loopNum)+"_M.txt";
			//
			int pathLen=nameStr.length();
	
			char * nameCh=new char[pathLen+1];
			char * nameAimCh=new char[nameAim.length()+1];

			strcpy(nameAimCh,nameAim.c_str());

			for(int i=0;i<pathLen;i++)
			{
				nameCh[i]=nameStr[i];
			}
			nameCh[pathLen]='\0';

			FILE * FL=fopen(nameCh,"a");

			if(FL==NULL)
			{
				
				delete [] nameCh;
				nameCh=NULL;

				delete [] nameAimCh;
				nameAimCh=NULL;

				return ERROR_PATH;
			}			

			taskInfo task(ar);
			task.output(FL);

			sarImageInfo sarImageInfo(ar);
			sarImageInfo.output(FL);

			muInfo mu(ar);
			mu.output(FL);
			fclose(FL);

			if(ifAimsInfo)
			{
				FILE * FLAim=fopen(nameAimCh,"a");
				if(FLAim==NULL)
				{
					return ERROR_PATH;
				}
				sarGMTIAimInfo gmtiAim(ar,lastPlaneLon,lastPlaneLat);
				//sarGMTIAimInfo gmtiAim(ar);
				gmtiAim.output(FLAim);
				fclose(FLAim);
			}

			delete [] nameCh;
			delete [] nameAimCh;
			
			return 0;

		}
		
		GY_GMTIModel::GY_GMTIModel(UINT8 *arIn,string str)
		{
			commonFuncs cmFuncs;
			ar=arIn;
			rootPath=str;
			dataName=cmFuncs.getName(ar);
			sockM=NULL;
			sockfd=NULL;
			gyNewLinePt=NULL;
			gy_Multicast_init();
		}

		GY_GMTIModel::~GY_GMTIModel()
		{
			if(sockfd!=NULL)
			{
				closesocket(sockfd);
			}
			
			if(sockM!=NULL)
			{
				closesocket(sockfd);
			}

			WSACleanup();
		}

		int GY_GMTIModel::output_GY_GMTIInfo()
		{
			static int pint=0;
			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);

			if(md!=4)
			{
				return ERROR_MODEL;
			}
			string rootForGeoMap=rootPath;
			string nameStrAim=rootPath+cmFuncs.getName(ar)+"_M.txt";
			string nameInfo=rootPath+cmFuncs.getName(ar)+".txt";
			//
			int pathAimLen=nameStrAim.length();
			int pathInfoLen=nameInfo.length();
	
			char * nameAimCh=new char[pathAimLen+1];
			char * nameInfoCh=new char[pathInfoLen+1];

			strcpy(nameAimCh,nameStrAim.c_str());
			strcpy(nameInfoCh,nameInfo.c_str());

			FILE * FLAim=fopen(nameAimCh,"a");

			FILE * FLInfo=fopen(nameInfoCh,"a");

			if(FLAim==NULL||FLInfo==NULL)
			{
				return ERROR_PATH;
			}

			pint++;

			//cmFuncs.logRecords("tast",pint);
			taskInfo task(ar);
			task.output(FLInfo);


			//cmFuncs.logRecords("mu",pint);
			muInfo mu(ar);
			mu.output(FLInfo);

			//cmFuncs.logRecords("gypars",pint);
			GYParsInfo GYPars(ar);
			GYPars.output(FLInfo);
			fclose(FLInfo);

			//cmFuncs.logRecords("gyAims",pint);
			GYAimInfo gy_aim(ar);  
			gy_aim.output(FLAim);		
			fclose(FLAim);

			rootForGeoMap.append("tar.dat");
			FILE * flPt=fopen(rootForGeoMap.c_str(),"ab");	
			gy_aim.GeoMapOutPut(flPt);
			fclose(flPt);

			delete []nameAimCh;
			delete []nameInfoCh;
			return 0;		
		}
		
		int GY_GMTIModel::outPut_GY_DatInfo()
		{

			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);
			static int aScanMdAngle=0;

			if(md!=4)
			{
				return ERROR_MODEL;
			}


			string gyDatInfoName=rootPath;
			gyDatInfoName.append("gyGMTI.dat");
			taskInfo task(ar);
			muInfo mu(ar);
			sarImageInfo imgPars(ar);
			GYParsInfo GYPars(ar);
			GYAimInfo gy_aim(ar); 

			UINT16 aimNms=gy_aim.lstHd2.numAll;

			//用于发送
			char * sendFlName="gySend.dat";
			FILE * FLSend=fopen(sendFlName,"wb");

			FILE * FL=fopen(gyDatInfoName.c_str(),"ab");

			//数据包信息
			UINT32 *packetInfo=new UINT32[3];
			packetInfo[0]=0X55AA55AA;
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FLSend);
			packetInfo[1]=1;
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FLSend);
			packetInfo[2]=216+aimNms*28; 
            fwrite(&(packetInfo[2]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[2]),sizeof(UINT32),1,FLSend);

			//fwrite(packetInfo,sizeof(UINT32),3,FL);
			//fwrite(packetInfo,sizeof(UINT32),3,FLSend);

			
			UINT16 taskCode=(UINT16)(task.missionCodes);
            //12
			fwrite(&taskCode,sizeof(UINT16),1,FL);//任务代号
			fwrite(&taskCode,sizeof(UINT16),1,FLSend);//任务代号
			//
			UINT8 planeType=7;

			fwrite(&planeType,sizeof(UINT8),1,FL);//飞行器类型
			fwrite(&planeType,sizeof(UINT8),1,FLSend);//飞行器类型

			UINT8 planePP=0;

			fwrite(&planePP,sizeof(UINT8),1,FL);//飞机批号
			fwrite(&planePP,sizeof(UINT8),1,FLSend);//飞机批号

			UINT16 planeCode=(UINT16)(task.planeNum);
			
			fwrite(&planeCode,sizeof(UINT16),1,FL);//飞机号 
			fwrite(&planeCode,sizeof(UINT16),1,FLSend);//飞机号
             //18
			UINT8 picCompress=0;
			fwrite(&picCompress,sizeof(UINT8),1,FL);//图像压缩比
			fwrite(&picCompress,sizeof(UINT8),1,FLSend);//图像压缩比

			UINT8 transType=(UINT8)task.transType;
			fwrite(&transType,sizeof(UINT8),1,FL);//传输方式
			fwrite(&transType,sizeof(UINT8),1,FLSend);//传输方式

			UINT8 loadType=3;
			fwrite(&loadType,sizeof(UINT8),1,FL);
			fwrite(&loadType,sizeof(UINT8),1,FLSend);

			UINT32 loadCode=0;
			fwrite(&loadCode,sizeof(UINT32),1,FL);
			fwrite(&loadCode,sizeof(UINT32),1,FLSend);
            //25
			UINT16 powerOn=(UINT16)GYPars.powerOnTimes;
			fwrite(&powerOn,sizeof(UINT16),1,FL);
			fwrite(&powerOn,sizeof(UINT16),1,FLSend);

			UINT32 muCode=0;
			fwrite(&muCode,sizeof(UINT32),1,FL);
			fwrite(&muCode,sizeof(UINT32),1,FLSend);
            //31
			UINT16 year=(UINT16)mu.date_year;
			fwrite(&year,sizeof(UINT16),1,FL);
			fwrite(&year,sizeof(UINT16),1,FLSend);
             //33
			UINT8 month=(UINT8)mu.date_month;
			fwrite(&month,sizeof(UINT8),1,FL);
			fwrite(&month,sizeof(UINT8),1,FLSend);

			UINT8 day=(UINT8)mu.date_day;
			fwrite(&day,sizeof(UINT8),1,FL);
			fwrite(&day,sizeof(UINT8),1,FLSend);

			UINT8 hour=(UINT8)mu.time_hour;
			fwrite(&hour,sizeof(UINT8),1,FL);
			fwrite(&hour,sizeof(UINT8),1,FLSend);

			UINT8 minutes=(UINT8)mu.time_minutes;
			fwrite(&minutes,sizeof(UINT8),1,FL);
			fwrite(&minutes,sizeof(UINT8),1,FLSend);

			UINT8 seconds=(UINT8)mu.time_second;
			fwrite(&seconds,sizeof(UINT8),1,FL);
			fwrite(&seconds,sizeof(UINT8),1,FLSend);

			UINT16 mseconds=(UINT16)mu.time_m_second;
			fwrite(&mseconds,sizeof(UINT16),1,FL);
			fwrite(&mseconds,sizeof(UINT16),1,FLSend);
             //40
			double plane_Long=(double)mu.plane_longitude;
			fwrite(&plane_Long,sizeof(double),1,FL);
			fwrite(&plane_Long,sizeof(double),1,FLSend);
			double plane_Lat=(double)mu.plane_latitude;
			fwrite(&plane_Lat,sizeof(double),1,FL);//
			fwrite(&plane_Lat,sizeof(double),1,FLSend);//

			float * flt=new float[22];
             //56
			flt[0]=(float)mu.plane_height;
			fwrite(&(flt[0]),sizeof(float),1,FL);
			fwrite(&(flt[0]),sizeof(float),1,FLSend);

			flt[1]=(float)mu.plane_aim_height;
			fwrite(&(flt[1]),sizeof(float),1,FL);
			fwrite(&(flt[1]),sizeof(float),1,FLSend);

			flt[2]=(float)mu.plane_direction_angle;
			fwrite(&(flt[2]),sizeof(float),1,FL);
			fwrite(&(flt[2]),sizeof(float),1,FLSend);

			//航向角加速率
			flt[3]=(float)mu.plane_departure_angle;
			fwrite(&(flt[3]),sizeof(float),1,FL);
			fwrite(&(flt[3]),sizeof(float),1,FLSend);

			flt[4]=(float)mu.plane_departure_angle;
			fwrite(&(flt[4]),sizeof(float),1,FL);
			fwrite(&(flt[4]),sizeof(float),1,FLSend);

			//俯仰角
			flt[5]=(float)mu.plane_dive_angle;
			fwrite(&(flt[5]),sizeof(float),1,FL);
			fwrite(&(flt[5]),sizeof(float),1,FLSend);

			flt[6]=(float)mu.plane_dive_angle_V;
			fwrite(&(flt[6]),sizeof(float),1,FL);
			fwrite(&(flt[6]),sizeof(float),1,FLSend);

			flt[7]=(float)mu.plane_dive_angle_a;
			fwrite(&(flt[7]),sizeof(float),1,FL);
			fwrite(&(flt[7]),sizeof(float),1,FLSend);

			//横滚角
			flt[8]=(float)mu.plane_hor_angle;
			fwrite(&(flt[8]),sizeof(float),1,FL);
			fwrite(&(flt[8]),sizeof(float),1,FLSend);

            flt[9]=(float)mu.plane_hor_angle_v;
			fwrite(&(flt[9]),sizeof(float),1,FL);
			fwrite(&(flt[9]),sizeof(float),1,FLSend);

			flt[10]=(float)mu.plane_hor_angle_a;
			fwrite(&(flt[10]),sizeof(float),1,FL);
			fwrite(&(flt[10]),sizeof(float),1,FLSend);

			//
			flt[11]=(float)mu.plane_departure_angle;
			fwrite(&(flt[11]),sizeof(float),1,FL);
			fwrite(&(flt[11]),sizeof(float),1,FLSend);

			flt[12]=(float)mu.plane_de_flow_angle;
			fwrite(&(flt[12]),sizeof(float),1,FL);
			fwrite(&(flt[12]),sizeof(float),1,FLSend);

			flt[13]=(float)mu.plane_ground_v;
			fwrite(&(flt[13]),sizeof(float),1,FL);
			fwrite(&(flt[13]),sizeof(float),1,FLSend);

            flt[14]=(float)mu.plane_noair_v;
			fwrite(&(flt[14]),sizeof(float),1,FL);
			fwrite(&(flt[14]),sizeof(float),1,FLSend);

			flt[15]=(float)mu.plane_point_v;
			fwrite(&(flt[15]),sizeof(float),1,FL);
			fwrite(&(flt[15]),sizeof(float),1,FLSend);
			//
			flt[16]=(float)mu.plane_east_v;
			fwrite(&(flt[16]),sizeof(float),1,FL);
			fwrite(&(flt[16]),sizeof(float),1,FLSend);

			flt[17]=(float)mu.plane_north_v;
			fwrite(&(flt[17]),sizeof(float),1,FL);
			fwrite(&(flt[17]),sizeof(float),1,FLSend);

			flt[18]=(float)mu.plane_up_v;
			fwrite(&(flt[18]),sizeof(float),1,FL);
			fwrite(&(flt[18]),sizeof(float),1,FLSend);

			flt[19]=(float)mu.plane_east_a;
			fwrite(&(flt[19]),sizeof(float),1,FL);
			fwrite(&(flt[19]),sizeof(float),1,FLSend);

			flt[20]=(float)mu.plane_north_a;
			fwrite(&(flt[20]),sizeof(float),1,FL);
			fwrite(&(flt[20]),sizeof(float),1,FLSend);

			flt[21]=(float)mu.plane_up_a;
			fwrite(&(flt[21]),sizeof(float),1,FL);
			fwrite(&(flt[21]),sizeof(float),1,FLSend);

			/*fwrite(flt,sizeof(float),22,FL);
			fwrite(flt,sizeof(float),22,FLSend);*/

			if(flt!=NULL)
			{
				delete []flt;
				flt=NULL;
			}
             //22*4+56=144
			//天线帧编号
			UINT32 frameNum=(UINT32)GYPars.frameCodes;
			fwrite(&frameNum,sizeof(UINT32),1,FL);
			fwrite(&frameNum,sizeof(UINT32),1,FLSend);

			//波位数
			UINT16 waveNum=0;
			fwrite(&waveNum,sizeof(UINT16),1,FL);
			fwrite(&waveNum,sizeof(UINT16),1,FLSend);

			//波位号
			UINT16 waveCode=(UINT16)GYPars.waveCodes;
			fwrite(&waveCode,sizeof(UINT16),1,FL);
			fwrite(&waveCode,sizeof(UINT16),1,FLSend);

			//工作频段 侧视方式  工作模式 工作子模式
			UINT8 * FreqLS=new UINT8[4];
			FreqLS[0]=0;
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FLSend);

			FreqLS[1]=0;
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FLSend);

			FreqLS[2]=0;
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FLSend);

			FreqLS[3]=0;
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FLSend);

			/*fwrite(FreqLS,sizeof(UINT8),4,FL);
			fwrite(FreqLS,sizeof(UINT8),4,FLSend);*/

			//156
			UINT32 *fNDistance=new UINT32[2];
			//最小、大作用距离
			fNDistance[1]=(UINT32 )GYPars.RFar;
			fNDistance[0]=(UINT32 )GYPars.RNear;

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FL);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FL);

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FLSend);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FLSend);
			//fwrite(fNDistance,sizeof(UINT32),2,FLSend);

			//cmFuncs.logRecords("GYGMTI最大距离：",GYPars.RFar);
			//cmFuncs.logRecords("GYGMTI最小距离：",GYPars.RNear);

			if(fNDistance!=NULL)
			{
				delete []fNDistance;
				fNDistance=NULL;
			}

			float * scanPar=new float[8];

			//天线帧扫描中心角		
			scanPar[0]=(float)((int)(mu.plane_direction_angle-imgPars.look_Side*90+360)%360);
			//cmFuncs.logRecords("GYGMTI天线帧扫描中心角：",scanPar[0]);
			fwrite(&(scanPar[0]),sizeof(float),1,FL);
			fwrite(&(scanPar[0]),sizeof(float),1,FLSend);
			//天线帧扫描范围
			scanPar[1]=2*(float)GYPars.scanScope;
			//cmFuncs.logRecords("GYGMTI天线帧扫描范围：",scanPar[1]);
			fwrite(&(scanPar[1]),sizeof(float),1,FL);
			fwrite(&(scanPar[1]),sizeof(float),1,FLSend);

			//方位波束中心角
			scanPar[2]=(float)GYPars.azimuthCenterAngle;
			/*scanPar[2]=(aScanMdAngle%76);
			aScanMdAngle+=2;*/

			//cmFuncs.logRecords("GYGMTI方位波束中心角：",scanPar[2]);
			fwrite(&(scanPar[2]),sizeof(float),1,FL);
			fwrite(&(scanPar[2]),sizeof(float),1,FLSend);

			//scanPar[2]=(float)(mu.plane_direction_angle-imgPars.look_Side*90);
            //方位波束宽度 ***************imgPars.beam_horz_width
			scanPar[3]=(float)imgPars.beam_horz_width;
			//cmFuncs.logRecords("GYGMTI方位波束宽度：",scanPar[3]);
			fwrite(&(scanPar[3]),sizeof(float),1,FL);
			fwrite(&(scanPar[3]),sizeof(float),1,FLSend);

			//scanPar[4]=(float)GYPars.azimuthAngle;
			//方位向扫描步进
			//scanPar[4]=(float)GYPars.scanStep;
			scanPar[4]=(int)imgPars.beam_horz_width;
			//cmFuncs.logRecords("GYGMTI方位向扫描步进：",scanPar[4]);
			fwrite(&(scanPar[4]),sizeof(float),1,FL);
			fwrite(&(scanPar[4]),sizeof(float),1,FLSend);
			//俯仰波束中心角
			scanPar[5]=imgPars.R_angle_new;
			//cmFuncs.logRecords("俯仰波束中心角：",imgPars.R_angle_new);
			fwrite(&(scanPar[5]),sizeof(float),1,FL);
			fwrite(&(scanPar[5]),sizeof(float),1,FLSend);
			//俯仰波束宽度
			scanPar[6]=imgPars.beam_R_width;
			//cmFuncs.logRecords("俯仰波束宽度：",imgPars.beam_R_width);
			fwrite(&(scanPar[6]),sizeof(float),1,FL);
			fwrite(&(scanPar[6]),sizeof(float),1,FLSend);
			//俯仰向扫描步进
			scanPar[7]=0;
			//cmFuncs.logRecords("俯仰向扫描步进：",0);
			fwrite(&(scanPar[7]),sizeof(float),1,FL);
			fwrite(&(scanPar[7]),sizeof(float),1,FLSend);
			//fwrite(scanPar,sizeof(float),8,FL);
			//fwrite(scanPar,sizeof(float),8,FLSend);
			if(scanPar!=NULL)
			{
				delete []scanPar;
				scanPar=NULL;
			}		

			UINT16 resPulseNum=(UINT16)GYPars.pulseResident;
			fwrite(&resPulseNum,sizeof(UINT16),1,FL);
			fwrite(&resPulseNum,sizeof(UINT16),1,FLSend);

			UINT16 resTime=0;
			fwrite(&resTime,sizeof(UINT16),1,FL);
			fwrite(&resTime,sizeof(UINT16),1,FLSend);
		    //分辨率
			float resolv=0;
			fwrite(&resolv,sizeof(float),1,FL);
			fwrite(&resolv,sizeof(float),1,FLSend);

			UINT32 PRF=(UINT32)GYPars.prf;
			fwrite(&PRF,sizeof(UINT32),1,FL);
			fwrite(&PRF,sizeof(UINT32),1,FLSend);

			UINT16 nullPs=0;
			fwrite(&nullPs,sizeof(UINT16),1,FL);
			fwrite(&nullPs,sizeof(UINT16),1,FLSend);

			fwrite(&aimNms,sizeof(UINT16),1,FL);
			fwrite(&aimNms,sizeof(UINT16),1,FLSend);

			gyAimInfoList * lstOutPut=gy_aim.lstHd2.gyAimInfoPt;
			int h=0;

			while(lstOutPut!=NULL)
			{

			   UINT32 pointCodes=(UINT32)h;
			   fwrite(&pointCodes,sizeof(UINT32),1,FL);
			   fwrite(&pointCodes,sizeof(UINT32),1,FLSend);
               //序号
			   double pointLong=lstOutPut->aim_longitude;  //经度
			   fwrite(&pointLong,sizeof(double),1,FL);
			   fwrite(&pointLong,sizeof(double),1,FLSend);

			   //cmFuncs.logRecords("经度：",pointLong);

			   double pointLat=lstOutPut->aim_latitude;  //纬度
			   fwrite(&pointLat,sizeof(double),1,FL);
			   fwrite(&pointLat,sizeof(double),1,FLSend);

			   //cmFuncs.logRecords("纬度：",pointLat);

			   float pointHeight=mu.aimH;
			   fwrite(&pointHeight,sizeof(float),1,FL);
			   fwrite(&pointHeight,sizeof(float),1,FLSend);

			   //cmFuncs.logRecords("高度：",pointHeight);

			   float point_P_v=(float)lstOutPut->aim_velocity;
			   fwrite(&point_P_v,sizeof(float),1,FL);
			   fwrite(&point_P_v,sizeof(float),1,FLSend);

			   //cmFuncs.logRecords("速度：",point_P_v);
			   
			   h++;
			   lstOutPut=lstOutPut->next;

			}

			UINT32 packetTail=0X0D0D0D0D;
			fwrite(&packetTail,sizeof(UINT32),1,FL);
			fwrite(&packetTail,sizeof(UINT32),1,FLSend);

			fclose(FL);
			fclose(FLSend);

			FLSend=fopen(sendFlName,"rb");

			if(FLSend==NULL)
			{
				return -1;
			}

			fseek(FLSend,0, SEEK_END);
			int file_size = ftell(FLSend);
			fseek(FLSend,0,SEEK_SET);

			char * buffer=new char[file_size];			
			fread(buffer,sizeof(char),file_size,FLSend);
			fclose(FLSend);
			
		    int resTemp=sendto(sockfd, buffer,file_size, 0,  
				(struct sockaddr *)&servaddr, sizeof(sockaddr));

			return resTemp;
		/*if(scanPar!=NULL)
			{
				delete []scanPar;
				scanPar=NULL;
			}*/
		}
		

		// **********  main functions of WAS-GMTI **************
		int GY_GMTIModel::output_NewGY_TxtInfo()
		{
			static int flNameCnt=0;
			static int pint=0;
			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);

			if(md!=4)  // mode 
			{
				return ERROR_MODEL;
			}
			string rootForGeoMap=rootPath;
			string nameStrAim=rootPath+cmFuncs.getDataName(ar,flNameCnt)+"_M.txt";
			string nameStrDotPath=rootPath+cmFuncs.getDataName(ar,flNameCnt)+"_P.txt";
			string nameInfo=rootPath+cmFuncs.getDataName(ar,flNameCnt)+".txt";
			//
			int pathAimLen=nameStrAim.length();
			int pathInfoLen=nameInfo.length();
	
			char * nameAimCh=new char[pathAimLen+1];
			char * nameInfoCh=new char[pathInfoLen+1];
			char * nameDotPath=new char[1024];

			strcpy(nameAimCh,nameStrAim.c_str());
			strcpy(nameInfoCh,nameInfo.c_str());
			strcpy(nameDotPath,nameStrDotPath.c_str());

			FILE * FLAim=fopen(nameAimCh,"a");

			//FILE * FLPath=fopen(nameDotPath,"a");

			FILE * FLInfo=fopen(nameInfoCh,"a");

			if(FLAim==NULL||FLInfo==NULL)
			{
				return ERROR_PATH;
			}

			pint++;

			taskInfo task(ar);
			task.output(FLInfo);

			muInfo mu(ar);
			mu.output(FLInfo);

			// WAS-GMTI参数输出
			GYParsInfo GYPars(ar);
			GYPars.output(FLInfo);
			fclose(FLInfo);

			// WAS-GMTI点迹和航迹输出
			NewGYAimInfo gyNewAimInfo(ar);
			gyNewAimInfo.outputAimInfo(FLAim);
			fclose(FLAim);

			flNameCnt++;
			return 0;
		}


		// *********  WAS-GMTI 发送数据到电子地图 2015/12/17 ***********
		int GY_GMTIModel::outPut_NewGY_DatInfo()
		{// 2015/12/17 V1.0

			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);
			static int aScanMdAngle=0;
			static string dataName=cmFuncs.getDataName(ar);

			if(md!=4)
			{
				return ERROR_MODEL;
			}

			string gyDatInfoName=rootPath;
			gyDatInfoName.append(dataName+".dat");
			taskInfo task(ar);
			muInfo mu(ar);
			sarImageInfo imgPars(ar);
			GYParsInfo GYPars(ar);
			NewGYAimInfo gyNewAim(ar);
			UINT16 aimNms=gyNewAim.aimsNum;
			
			//用于发送  /***gySend1--gySend/
			char * sendFlName="gySend.dat";
			//FILE * FLSend=fopen(sendFlName,"w");
			FILE * FLSend=fopen(sendFlName,"wb");
			FILE * FL=fopen(gyDatInfoName.c_str(),"ab");

			if(FLSend==NULL || FL == NULL) return ERROR_MODEL;

			//char * bufferSend=new char[];
			//数据包信息
			UINT32 *packetInfo=new UINT32[3];
			packetInfo[0]=0X55AA55AA;
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FLSend);
			
			packetInfo[1]=1;
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FLSend);
			packetInfo[2]=216+aimNms*28; 
            fwrite(&(packetInfo[2]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[2]),sizeof(UINT32),1,FLSend);

			//cmFuncs.logRecords("calculate file_size：",(double)216+aimNms*28);
			//fwrite(packetInfo,sizeof(UINT32),3,FL);
			//fwrite(packetInfo,sizeof(UINT32),3,FLSend);

			
			UINT16 taskCode=(UINT16)(task.missionCodes);
            //12
			fwrite(&taskCode,sizeof(UINT16),1,FL);//任务代号
			fwrite(&taskCode,sizeof(UINT16),1,FLSend);//任务代号
			//
			UINT8 planeType=7;

			fwrite(&planeType,sizeof(UINT8),1,FL);//飞行器类型
			fwrite(&planeType,sizeof(UINT8),1,FLSend);//飞行器类型

			UINT8 planePP=0;

			fwrite(&planePP,sizeof(UINT8),1,FL);//飞机批号
			fwrite(&planePP,sizeof(UINT8),1,FLSend);//飞机批号

			UINT16 planeCode=(UINT16)(task.planeNum);
			
			fwrite(&planeCode,sizeof(UINT16),1,FL);//飞机号 
			fwrite(&planeCode,sizeof(UINT16),1,FLSend);//飞机号
             //18
			UINT8 picCompress=0;
			fwrite(&picCompress,sizeof(UINT8),1,FL);//图像压缩比
			fwrite(&picCompress,sizeof(UINT8),1,FLSend);//图像压缩比

			UINT8 transType=(UINT8)task.transType;
			fwrite(&transType,sizeof(UINT8),1,FL);//传输方式
			fwrite(&transType,sizeof(UINT8),1,FLSend);//传输方式

			UINT8 loadType=3;
			fwrite(&loadType,sizeof(UINT8),1,FL);
			fwrite(&loadType,sizeof(UINT8),1,FLSend);

			UINT32 loadCode=0;
			fwrite(&loadCode,sizeof(UINT32),1,FL);
			fwrite(&loadCode,sizeof(UINT32),1,FLSend);
            //25
			UINT16 powerOn=(UINT16)GYPars.powerOnTimes;
			fwrite(&powerOn,sizeof(UINT16),1,FL);
			fwrite(&powerOn,sizeof(UINT16),1,FLSend);

			UINT32 muCode=0;
			fwrite(&muCode,sizeof(UINT32),1,FL);
			fwrite(&muCode,sizeof(UINT32),1,FLSend);
            //31
			UINT16 year=(UINT16)mu.date_year;
			fwrite(&year,sizeof(UINT16),1,FL);
			fwrite(&year,sizeof(UINT16),1,FLSend);
             //33
			UINT8 month=(UINT8)mu.date_month;
			fwrite(&month,sizeof(UINT8),1,FL);
			fwrite(&month,sizeof(UINT8),1,FLSend);

			UINT8 day=(UINT8)mu.date_day;
			fwrite(&day,sizeof(UINT8),1,FL);
			fwrite(&day,sizeof(UINT8),1,FLSend);

			UINT8 hour=(UINT8)mu.time_hour;
			fwrite(&hour,sizeof(UINT8),1,FL);
			fwrite(&hour,sizeof(UINT8),1,FLSend);

			UINT8 minutes=(UINT8)mu.time_minutes;
			fwrite(&minutes,sizeof(UINT8),1,FL);
			fwrite(&minutes,sizeof(UINT8),1,FLSend);

			UINT8 seconds=(UINT8)mu.time_second;
			fwrite(&seconds,sizeof(UINT8),1,FL);
			fwrite(&seconds,sizeof(UINT8),1,FLSend);

			UINT16 mseconds=(UINT16)mu.time_m_second;
			fwrite(&mseconds,sizeof(UINT16),1,FL);
			fwrite(&mseconds,sizeof(UINT16),1,FLSend);
             //40
			double plane_Long=(double)mu.plane_longitude;
			fwrite(&plane_Long,sizeof(double),1,FL);
			fwrite(&plane_Long,sizeof(double),1,FLSend);
			double plane_Lat=(double)mu.plane_latitude;
			fwrite(&plane_Lat,sizeof(double),1,FL);//
			fwrite(&plane_Lat,sizeof(double),1,FLSend);//

			//cmFuncs.logRecords("was载机经度：",plane_Long);
			//cmFuncs.logRecords("was载机纬度：",plane_Lat);

			float * flt=new float[22];
             //56
			flt[0]=(float)mu.plane_height;
			fwrite(&(flt[0]),sizeof(float),1,FL);
			fwrite(&(flt[0]),sizeof(float),1,FLSend);

			flt[1]=(float)mu.plane_aim_height;
			fwrite(&(flt[1]),sizeof(float),1,FL);
			fwrite(&(flt[1]),sizeof(float),1,FLSend);

			flt[2]=(float)mu.plane_direction_angle;
			fwrite(&(flt[2]),sizeof(float),1,FL);
			fwrite(&(flt[2]),sizeof(float),1,FLSend);

			//航向角加速率
			flt[3]=(float)mu.plane_departure_angle;
			fwrite(&(flt[3]),sizeof(float),1,FL);
			fwrite(&(flt[3]),sizeof(float),1,FLSend);

			flt[4]=(float)mu.plane_departure_angle;
			fwrite(&(flt[4]),sizeof(float),1,FL);
			fwrite(&(flt[4]),sizeof(float),1,FLSend);

			//俯仰角
			flt[5]=(float)mu.plane_dive_angle;
			fwrite(&(flt[5]),sizeof(float),1,FL);
			fwrite(&(flt[5]),sizeof(float),1,FLSend);

			flt[6]=(float)mu.plane_dive_angle_V;
			fwrite(&(flt[6]),sizeof(float),1,FL);
			fwrite(&(flt[6]),sizeof(float),1,FLSend);

			flt[7]=(float)mu.plane_dive_angle_a;
			fwrite(&(flt[7]),sizeof(float),1,FL);
			fwrite(&(flt[7]),sizeof(float),1,FLSend);

			//横滚角
			flt[8]=(float)mu.plane_hor_angle;
			fwrite(&(flt[8]),sizeof(float),1,FL);
			fwrite(&(flt[8]),sizeof(float),1,FLSend);

            flt[9]=(float)mu.plane_hor_angle_v;
			fwrite(&(flt[9]),sizeof(float),1,FL);
			fwrite(&(flt[9]),sizeof(float),1,FLSend);

			flt[10]=(float)mu.plane_hor_angle_a;
			fwrite(&(flt[10]),sizeof(float),1,FL);
			fwrite(&(flt[10]),sizeof(float),1,FLSend);

			//
			flt[11]=(float)mu.plane_departure_angle;
			fwrite(&(flt[11]),sizeof(float),1,FL);
			fwrite(&(flt[11]),sizeof(float),1,FLSend);

			flt[12]=(float)mu.plane_de_flow_angle;
			fwrite(&(flt[12]),sizeof(float),1,FL);
			fwrite(&(flt[12]),sizeof(float),1,FLSend);

			flt[13]=(float)mu.plane_ground_v;
			fwrite(&(flt[13]),sizeof(float),1,FL);
			fwrite(&(flt[13]),sizeof(float),1,FLSend);

            flt[14]=(float)mu.plane_noair_v;
			fwrite(&(flt[14]),sizeof(float),1,FL);
			fwrite(&(flt[14]),sizeof(float),1,FLSend);

			flt[15]=(float)mu.plane_point_v;
			fwrite(&(flt[15]),sizeof(float),1,FL);
			fwrite(&(flt[15]),sizeof(float),1,FLSend);
			//
			flt[16]=(float)mu.plane_east_v;
			fwrite(&(flt[16]),sizeof(float),1,FL);
			fwrite(&(flt[16]),sizeof(float),1,FLSend);

			flt[17]=(float)mu.plane_north_v;
			fwrite(&(flt[17]),sizeof(float),1,FL);
			fwrite(&(flt[17]),sizeof(float),1,FLSend);

			flt[18]=(float)mu.plane_up_v;
			fwrite(&(flt[18]),sizeof(float),1,FL);
			fwrite(&(flt[18]),sizeof(float),1,FLSend);

			flt[19]=(float)mu.plane_east_a;
			fwrite(&(flt[19]),sizeof(float),1,FL);
			fwrite(&(flt[19]),sizeof(float),1,FLSend);

			flt[20]=(float)mu.plane_north_a;
			fwrite(&(flt[20]),sizeof(float),1,FL);
			fwrite(&(flt[20]),sizeof(float),1,FLSend);

			flt[21]=(float)mu.plane_up_a;
			fwrite(&(flt[21]),sizeof(float),1,FL);
			fwrite(&(flt[21]),sizeof(float),1,FLSend);

			/*fwrite(flt,sizeof(float),22,FL);
			fwrite(flt,sizeof(float),22,FLSend);*/

			if(flt!=NULL)
			{
				delete []flt;
				flt=NULL;
			}
             //22*4+56=144
			//天线帧编号
			UINT32 frameNum=(UINT32)GYPars.frameCodes;
			fwrite(&frameNum,sizeof(UINT32),1,FL);
			fwrite(&frameNum,sizeof(UINT32),1,FLSend);

			//波位数
			UINT16 waveNum=0;
			fwrite(&waveNum,sizeof(UINT16),1,FL);
			fwrite(&waveNum,sizeof(UINT16),1,FLSend);

			//波位号
			UINT16 waveCode=(UINT16)GYPars.waveCodes;
			fwrite(&waveCode,sizeof(UINT16),1,FL);
			fwrite(&waveCode,sizeof(UINT16),1,FLSend);

			//工作频段 侧视方式  工作模式 工作子模式
			UINT8 * FreqLS=new UINT8[4];
			FreqLS[0]=0;
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FLSend);

			if(mu.rAngle<0) // 右侧视
			{
				FreqLS[1] = 1;
			}else           // 左侧视
			{
				FreqLS[1] = 0;
			}
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FLSend);

			FreqLS[2]=0;
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FLSend);

			FreqLS[3]=0;
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FLSend);

			/*fwrite(FreqLS,sizeof(UINT8),4,FL);
			fwrite(FreqLS,sizeof(UINT8),4,FLSend);*/

			//156
			UINT32 *fNDistance=new UINT32[2];

			//cmFuncs.logRecords("GYGMTI最大距离：",GYPars.RFar);
			//cmFuncs.logRecords("GYGMTI最小距离：",GYPars.RNear);
			//最小、大作用距离
			//if(abs(GYPars.RNear)>200.0e3 || abs(GYPars.RNear)<70.0e3)
			if(abs(GYPars.RFar)>400.0e3 || abs(GYPars.RNear)<30.0e3 || abs(GYPars.RNear)>200.0e3 )
			{
				fNDistance[1]=(UINT32)150.0e3; // should be improved ;
			    fNDistance[0]=(UINT32)80.0e3;;//dbRNear
				//return -1;
			}
			else
			{
				fNDistance[1]=(UINT32)GYPars.RFar;
			    fNDistance[0]=(UINT32)GYPars.RNear;//dbRNear
			}

			//fNDistance[1]=(UINT32 )GYPars.RFar;
			//fNDistance[0]=(UINT32 )GYPars.RNear;//dbRNear

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FL);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FL);

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FLSend);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FLSend);
			//fwrite(fNDistance,sizeof(UINT32),2,FLSend);

			//cmFuncs.logRecords("GYGMTI最大距离：",GYPars.RFar);
			//cmFuncs.logRecords("GYGMTI最小距离：",GYPars.RNear);

			if(fNDistance!=NULL)
			{
				delete []fNDistance;
				fNDistance=NULL;
			}

			float * scanPar=new float[8];

			//天线帧扫描中心角		
			scanPar[0]=(float)((int)(mu.plane_direction_angle-imgPars.look_Side*90+360)%360);//OK
			//cmFuncs.logRecords("GYGMTI天线帧扫描中心角：",scanPar[0]);
			fwrite(&(scanPar[0]),sizeof(float),1,FL);
			fwrite(&(scanPar[0]),sizeof(float),1,FLSend);

			//天线帧扫描范围
			scanPar[1]=2*(float)GYPars.scanScope;
			//cmFuncs.logRecords("GYGMTI天线帧扫描范围：",scanPar[1]);
			fwrite(&(scanPar[1]),sizeof(float),1,FL);
			fwrite(&(scanPar[1]),sizeof(float),1,FLSend);

			//方位波束中心角
			scanPar[2]=(float)GYPars.azimuthCenterAngle;
			/*scanPar[2]=(aScanMdAngle%76);
			aScanMdAngle+=2;*/

			//cmFuncs.logRecords("GYGMTI方位波束中心角：",scanPar[2]);
			fwrite(&(scanPar[2]),sizeof(float),1,FL);
			fwrite(&(scanPar[2]),sizeof(float),1,FLSend);

			//scanPar[2]=(float)(mu.plane_direction_angle-imgPars.look_Side*90);
            //方位波束宽度 ***************imgPars.beam_horz_width
			scanPar[3]=(float)imgPars.beam_horz_width;
			//cmFuncs.logRecords("GYGMTI方位波束宽度：",scanPar[3]);
			fwrite(&(scanPar[3]),sizeof(float),1,FL);
			fwrite(&(scanPar[3]),sizeof(float),1,FLSend);

			//scanPar[4]=(float)GYPars.azimuthAngle;
			//方位向扫描步进
			//scanPar[4]=(float)GYPars.scanStep;
			scanPar[4]=(int)imgPars.beam_horz_width;
			//cmFuncs.logRecords("GYGMTI方位向扫描步进：",scanPar[4]);
			fwrite(&(scanPar[4]),sizeof(float),1,FL);
			fwrite(&(scanPar[4]),sizeof(float),1,FLSend);
			//俯仰波束中心角
			scanPar[5]=imgPars.R_angle_new;
			//cmFuncs.logRecords("俯仰波束中心角：",imgPars.R_angle_new);
			fwrite(&(scanPar[5]),sizeof(float),1,FL);
			fwrite(&(scanPar[5]),sizeof(float),1,FLSend);
			//俯仰波束宽度
			scanPar[6]=imgPars.beam_R_width;
			//cmFuncs.logRecords("俯仰波束宽度：",imgPars.beam_R_width);
			fwrite(&(scanPar[6]),sizeof(float),1,FL);
			fwrite(&(scanPar[6]),sizeof(float),1,FLSend);
			//俯仰向扫描步进
			scanPar[7]=0;
			//cmFuncs.logRecords("俯仰向扫描步进：",0);
			fwrite(&(scanPar[7]),sizeof(float),1,FL);
			fwrite(&(scanPar[7]),sizeof(float),1,FLSend);
			//fwrite(scanPar,sizeof(float),8,FL);
			//fwrite(scanPar,sizeof(float),8,FLSend);
			if(scanPar!=NULL)
			{
				delete []scanPar;
				scanPar=NULL;
			}		

			UINT16 resPulseNum=(UINT16)GYPars.pulseResident;
			fwrite(&resPulseNum,sizeof(UINT16),1,FL);
			fwrite(&resPulseNum,sizeof(UINT16),1,FLSend);

			UINT16 resTime=0;
			fwrite(&resTime,sizeof(UINT16),1,FL);
			fwrite(&resTime,sizeof(UINT16),1,FLSend);
		    //分辨率
			float resolv=0;
			fwrite(&resolv,sizeof(float),1,FL);
			fwrite(&resolv,sizeof(float),1,FLSend);

			UINT32 PRF=(UINT32)GYPars.prf;
			fwrite(&PRF,sizeof(UINT32),1,FL);
			fwrite(&PRF,sizeof(UINT32),1,FLSend);

			UINT16 nullPs=0;
			fwrite(&nullPs,sizeof(UINT16),1,FL);
			fwrite(&nullPs,sizeof(UINT16),1,FLSend);

			fwrite(&aimNms,sizeof(UINT16),1,FL);
			fwrite(&aimNms,sizeof(UINT16),1,FLSend);

			gyAimInfoList * lstOutPut=gyNewAim.lstHeader.gyAimInfoPt;

			int h=0;

			while(lstOutPut!=NULL)
			{

			   UINT32 pointCodes=(UINT32)h;
			   fwrite(&pointCodes,sizeof(UINT32),1,FL);
			   fwrite(&pointCodes,sizeof(UINT32),1,FLSend);
               //序号
			   double pointLong=lstOutPut->aim_longitude;  //经度
			   fwrite(&pointLong,sizeof(double),1,FL);
			   fwrite(&pointLong,sizeof(double),1,FLSend);

			   //cmFuncs.logRecords("经度：",pointLong);

			   double pointLat=lstOutPut->aim_latitude;  //纬度
			   fwrite(&pointLat,sizeof(double),1,FL);
			   fwrite(&pointLat,sizeof(double),1,FLSend);

			   float pointHeight=0;
			   fwrite(&pointHeight,sizeof(float),1,FL);
			   fwrite(&pointHeight,sizeof(float),1,FLSend);

			   float point_P_v=(float)lstOutPut->aim_velocity;
			   fwrite(&point_P_v,sizeof(float),1,FL);
			   fwrite(&point_P_v,sizeof(float),1,FLSend);
			   
			   h++;
			   lstOutPut=lstOutPut->next;

			}

			UINT32 packetTail=0X0D0D0D0D;
			fwrite(&packetTail,sizeof(UINT32),1,FL);
			fwrite(&packetTail,sizeof(UINT32),1,FLSend);

			fclose(FL);
			fclose(FLSend);

			FLSend=fopen(sendFlName,"rb");

			if(FLSend==NULL)
			{
				//cmFuncs.logRecords("GY发送的Data打开失败。",8);
				return -1;
			}

			fseek(FLSend,0, SEEK_END);
			int file_size = ftell(FLSend);
			fseek(FLSend,0,SEEK_SET);

			//cmFuncs.logRecords("ftell(FLSend) file_size：",(double)file_size);

			char * buffer=new char[file_size];	

			fread(buffer,sizeof(char),file_size,FLSend);
			fclose(FLSend);
			
		    int resTemp=sendto(sockfd, buffer,file_size, 0,  
				(struct sockaddr *)&servaddr, sizeof(sockaddr));

			if(buffer!=NULL)
			{
				delete [] buffer;
				buffer=NULL;
			}

			//cmFuncs.logRecords("广域点迹GMTI发送,发送结果为：",(double)resTemp);
			return resTemp;

			//return 0;
		}

		int GY_GMTIModel::outPut_NewGY_LineInfo(stGMTIProcContent prcCont)
		{
			NewGYLineInfo GYLine(ar);
			GYLine.flightPathCon();

			if(prcCont.blDat)
			{
				outPut_NewGY_Line_DatInfo(GYLine);
			}
			
			return 0;
		}
		
		// ******* WAS-GMTI 目标关联及发送至电子地图 2015/12/25 ********
		int GY_GMTIModel::outPut_NewGY_LineInfo()
		{

			commonFuncs cmFuncs;
			string rootForGeoMap = rootPath;
			string nameStrDotPath= rootPath+"0000_DZS_XL_ALL_HJ.txt"; // 航迹txt文件路径
			
			NewGYLineInfo GYLine(ar);
			
			strcpy(GYLine.HJ_filePath,nameStrDotPath.c_str());
			GYLine.flightPathCon();

			outPut_NewGY_Line_DatInfo(GYLine);

			//outPut_NewGY_Line_TxtInfo(GYLine);
			
			return 0;
		}

		int GY_GMTIModel::outPut_NewGY_Line_DatInfo(NewGYLineInfo GYLine)
		{

            commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);
			static int aScanMdAngle=0;
			static string dataName=cmFuncs.getDataName(ar);

			if(md!=4)
			{
				return ERROR_MODEL;
			}

			string gyDatInfoName=rootPath;
			gyDatInfoName.append(dataName+"_F.dat");
			taskInfo task(ar);
			muInfo mu(ar);
			sarImageInfo imgPars(ar);
			GYParsInfo GYPars(ar);
			
			UINT16 aimNms=GYLine.dotPathNum;
			
			//用于发送
			char * sendFlName="gyLineSend.dat";
			FILE * FLSend=fopen(sendFlName,"wb");

			FILE * FL=fopen(gyDatInfoName.c_str(),"ab");
			if(FLSend==NULL || FL == NULL) return ERROR_MODEL;

			//数据包信息
			UINT32 *packetInfo=new UINT32[3];
			packetInfo[0]=0X55AA55AA;
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[0]),sizeof(UINT32),1,FLSend);
			packetInfo[1]=2;
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[1]),sizeof(UINT32),1,FLSend);
			packetInfo[2]=216+aimNms*36; 
            fwrite(&(packetInfo[2]),sizeof(UINT32),1,FL);
			fwrite(&(packetInfo[2]),sizeof(UINT32),1,FLSend);

			//fwrite(packetInfo,sizeof(UINT32),3,FL);
			//fwrite(packetInfo,sizeof(UINT32),3,FLSend);

			
			UINT16 taskCode=(UINT16)(task.missionCodes);
            //12
			fwrite(&taskCode,sizeof(UINT16),1,FL);//任务代号
			fwrite(&taskCode,sizeof(UINT16),1,FLSend);//任务代号
			//
			UINT8 planeType=7;

			fwrite(&planeType,sizeof(UINT8),1,FL);//飞行器类型
			fwrite(&planeType,sizeof(UINT8),1,FLSend);//飞行器类型

			UINT8 planePP=0;

			fwrite(&planePP,sizeof(UINT8),1,FL);//飞机批号
			fwrite(&planePP,sizeof(UINT8),1,FLSend);//飞机批号

			UINT16 planeCode=(UINT16)(task.planeNum);
			
			fwrite(&planeCode,sizeof(UINT16),1,FL);//飞机号 
			fwrite(&planeCode,sizeof(UINT16),1,FLSend);//飞机号
             //18
			UINT8 picCompress=0;
			fwrite(&picCompress,sizeof(UINT8),1,FL);//图像压缩比
			fwrite(&picCompress,sizeof(UINT8),1,FLSend);//图像压缩比

			UINT8 transType=(UINT8)task.transType;
			fwrite(&transType,sizeof(UINT8),1,FL);//传输方式
			fwrite(&transType,sizeof(UINT8),1,FLSend);//传输方式

			UINT8 loadType=3;
			fwrite(&loadType,sizeof(UINT8),1,FL);
			fwrite(&loadType,sizeof(UINT8),1,FLSend);

			UINT32 loadCode=0;
			fwrite(&loadCode,sizeof(UINT32),1,FL);
			fwrite(&loadCode,sizeof(UINT32),1,FLSend);
            //25
			UINT16 powerOn=(UINT16)GYPars.powerOnTimes;
			fwrite(&powerOn,sizeof(UINT16),1,FL);
			fwrite(&powerOn,sizeof(UINT16),1,FLSend);

			UINT32 muCode=0;
			fwrite(&muCode,sizeof(UINT32),1,FL);
			fwrite(&muCode,sizeof(UINT32),1,FLSend);
            //31
			UINT16 year=(UINT16)mu.date_year;
			fwrite(&year,sizeof(UINT16),1,FL);
			fwrite(&year,sizeof(UINT16),1,FLSend);
             //33
			UINT8 month=(UINT8)mu.date_month;
			fwrite(&month,sizeof(UINT8),1,FL);
			fwrite(&month,sizeof(UINT8),1,FLSend);

			UINT8 day=(UINT8)mu.date_day;
			fwrite(&day,sizeof(UINT8),1,FL);
			fwrite(&day,sizeof(UINT8),1,FLSend);

			UINT8 hour=(UINT8)mu.time_hour;
			fwrite(&hour,sizeof(UINT8),1,FL);
			fwrite(&hour,sizeof(UINT8),1,FLSend);

			UINT8 minutes=(UINT8)mu.time_minutes;
			fwrite(&minutes,sizeof(UINT8),1,FL);
			fwrite(&minutes,sizeof(UINT8),1,FLSend);

			UINT8 seconds=(UINT8)mu.time_second;
			fwrite(&seconds,sizeof(UINT8),1,FL);
			fwrite(&seconds,sizeof(UINT8),1,FLSend);

			UINT16 mseconds=(UINT16)mu.time_m_second;
			fwrite(&mseconds,sizeof(UINT16),1,FL);
			fwrite(&mseconds,sizeof(UINT16),1,FLSend);
             //40
			double plane_Long=(double)mu.plane_longitude;
			fwrite(&plane_Long,sizeof(double),1,FL);
			fwrite(&plane_Long,sizeof(double),1,FLSend);
			double plane_Lat=(double)mu.plane_latitude;
			fwrite(&plane_Lat,sizeof(double),1,FL);//
			fwrite(&plane_Lat,sizeof(double),1,FLSend);//

			float * flt=new float[22];
             //56
			flt[0]=(float)mu.plane_height;
			fwrite(&(flt[0]),sizeof(float),1,FL);
			fwrite(&(flt[0]),sizeof(float),1,FLSend);

			flt[1]=(float)mu.plane_aim_height;
			fwrite(&(flt[1]),sizeof(float),1,FL);
			fwrite(&(flt[1]),sizeof(float),1,FLSend);

			flt[2]=(float)mu.plane_direction_angle;
			fwrite(&(flt[2]),sizeof(float),1,FL);
			fwrite(&(flt[2]),sizeof(float),1,FLSend);

			//航向角加速率
			flt[3]=(float)mu.plane_departure_angle;
			fwrite(&(flt[3]),sizeof(float),1,FL);
			fwrite(&(flt[3]),sizeof(float),1,FLSend);

			flt[4]=(float)mu.plane_departure_angle;
			fwrite(&(flt[4]),sizeof(float),1,FL);
			fwrite(&(flt[4]),sizeof(float),1,FLSend);

			//俯仰角
			flt[5]=(float)mu.plane_dive_angle;
			fwrite(&(flt[5]),sizeof(float),1,FL);
			fwrite(&(flt[5]),sizeof(float),1,FLSend);

			flt[6]=(float)mu.plane_dive_angle_V;
			fwrite(&(flt[6]),sizeof(float),1,FL);
			fwrite(&(flt[6]),sizeof(float),1,FLSend);

			flt[7]=(float)mu.plane_dive_angle_a;
			fwrite(&(flt[7]),sizeof(float),1,FL);
			fwrite(&(flt[7]),sizeof(float),1,FLSend);

			//横滚角
			flt[8]=(float)mu.plane_hor_angle;
			fwrite(&(flt[8]),sizeof(float),1,FL);
			fwrite(&(flt[8]),sizeof(float),1,FLSend);

            flt[9]=(float)mu.plane_hor_angle_v;
			fwrite(&(flt[9]),sizeof(float),1,FL);
			fwrite(&(flt[9]),sizeof(float),1,FLSend);

			flt[10]=(float)mu.plane_hor_angle_a;
			fwrite(&(flt[10]),sizeof(float),1,FL);
			fwrite(&(flt[10]),sizeof(float),1,FLSend);

			//
			flt[11]=(float)mu.plane_departure_angle;
			fwrite(&(flt[11]),sizeof(float),1,FL);
			fwrite(&(flt[11]),sizeof(float),1,FLSend);

			flt[12]=(float)mu.plane_de_flow_angle;
			fwrite(&(flt[12]),sizeof(float),1,FL);
			fwrite(&(flt[12]),sizeof(float),1,FLSend);

			flt[13]=(float)mu.plane_ground_v;
			fwrite(&(flt[13]),sizeof(float),1,FL);
			fwrite(&(flt[13]),sizeof(float),1,FLSend);

            flt[14]=(float)mu.plane_noair_v;
			fwrite(&(flt[14]),sizeof(float),1,FL);
			fwrite(&(flt[14]),sizeof(float),1,FLSend);

			flt[15]=(float)mu.plane_point_v;
			fwrite(&(flt[15]),sizeof(float),1,FL);
			fwrite(&(flt[15]),sizeof(float),1,FLSend);
			//
			flt[16]=(float)mu.plane_east_v;
			fwrite(&(flt[16]),sizeof(float),1,FL);
			fwrite(&(flt[16]),sizeof(float),1,FLSend);

			flt[17]=(float)mu.plane_north_v;
			fwrite(&(flt[17]),sizeof(float),1,FL);
			fwrite(&(flt[17]),sizeof(float),1,FLSend);

			flt[18]=(float)mu.plane_up_v;
			fwrite(&(flt[18]),sizeof(float),1,FL);
			fwrite(&(flt[18]),sizeof(float),1,FLSend);

			flt[19]=(float)mu.plane_east_a;
			fwrite(&(flt[19]),sizeof(float),1,FL);
			fwrite(&(flt[19]),sizeof(float),1,FLSend);

			flt[20]=(float)mu.plane_north_a;
			fwrite(&(flt[20]),sizeof(float),1,FL);
			fwrite(&(flt[20]),sizeof(float),1,FLSend);

			flt[21]=(float)mu.plane_up_a;
			fwrite(&(flt[21]),sizeof(float),1,FL);
			fwrite(&(flt[21]),sizeof(float),1,FLSend);

			/*fwrite(flt,sizeof(float),22,FL);
			fwrite(flt,sizeof(float),22,FLSend);*/

			if(flt!=NULL)
			{
				delete []flt;
				flt=NULL;
			}
             //22*4+56=144
			//天线帧编号
			UINT32 frameNum=(UINT32)GYPars.frameCodes;
			fwrite(&frameNum,sizeof(UINT32),1,FL);
			fwrite(&frameNum,sizeof(UINT32),1,FLSend);

			//波位数
			UINT16 waveNum=0;
			fwrite(&waveNum,sizeof(UINT16),1,FL);
			fwrite(&waveNum,sizeof(UINT16),1,FLSend);

			//波位号
			UINT16 waveCode=(UINT16)GYPars.waveCodes;
			fwrite(&waveCode,sizeof(UINT16),1,FL);
			fwrite(&waveCode,sizeof(UINT16),1,FLSend);

			//工作频段 侧视方式  工作模式 工作子模式
			UINT8 * FreqLS=new UINT8[4];
			FreqLS[0]=0;
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[0]),sizeof(UINT8),1,FLSend);

			FreqLS[1]=0;
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[1]),sizeof(UINT8),1,FLSend);

			FreqLS[2]=0;
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[2]),sizeof(UINT8),1,FLSend);

			FreqLS[3]=0;
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FL);
			fwrite(&(FreqLS[3]),sizeof(UINT8),1,FLSend);

			/*fwrite(FreqLS,sizeof(UINT8),4,FL);
			fwrite(FreqLS,sizeof(UINT8),4,FLSend);*/

			//156
			UINT32 *fNDistance=new UINT32[2];

			//cmFuncs.logRecords("GYGMTI原始最大距离11：",GYPars.RFar);
			//cmFuncs.logRecords("GYGMTI原始最小距离11：",GYPars.RNear);
			//最小、大作用距离
			//if(abs(GYPars.RNear)>200.0e3 || abs(GYPars.RNear)<70.0e3)
			if(abs(GYPars.RNear)>600.0e3 || abs(GYPars.RNear)<70.0e3)
			{
				/*GYPars.RNear = 120.0e3;
				//GYPars.RFar = 180.0e3;*/
				fNDistance[1]=(UINT32 )250.0e3;
			    fNDistance[0]=(UINT32 )120.0e3;;//dbRNear

				//return -1;
			}
			else
			{
				fNDistance[1]=(UINT32 )GYPars.RFar;
			    fNDistance[0]=(UINT32 )GYPars.RNear;//dbRNear
			}
			//cmFuncs.logRecords("GYGMTI最大距离：",(double)fNDistance[1]);
			//cmFuncs.logRecords("GYGMTI最小距离：",(double)fNDistance[0]);
			//fNDistance[1]=(UINT32 )GYPars.RFar;
			//fNDistance[0]=(UINT32 )GYPars.RNear;//dbRNear

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FL);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FL);

			fwrite(&(fNDistance[1]),sizeof(UINT32),1,FLSend);
			fwrite(&(fNDistance[0]),sizeof(UINT32),1,FLSend);
			//fwrite(fNDistance,sizeof(UINT32),2,FLSend);

			//cmFuncs.logRecords("GYGMTI最大距离：",GYPars.RFar);
			//cmFuncs.logRecords("GYGMTI最小距离：",GYPars.RNear);

			if(fNDistance!=NULL)
			{
				delete []fNDistance;
				fNDistance=NULL;
			}

			float * scanPar=new float[8];

			//天线帧扫描中心角		
			scanPar[0]=(float)((int)(mu.plane_direction_angle-imgPars.look_Side*90+360)%360);
			//cmFuncs.logRecords("GYGMTI天线帧扫描中心角：",scanPar[0]);
			fwrite(&(scanPar[0]),sizeof(float),1,FL);
			fwrite(&(scanPar[0]),sizeof(float),1,FLSend);
			//天线帧扫描范围
			scanPar[1]=2*(float)GYPars.scanScope;
			//cmFuncs.logRecords("GYGMTI天线帧扫描范围：",scanPar[1]);
			fwrite(&(scanPar[1]),sizeof(float),1,FL);
			fwrite(&(scanPar[1]),sizeof(float),1,FLSend);

			//方位波束中心角
			scanPar[2]=(float)GYPars.azimuthCenterAngle;
			/*scanPar[2]=(aScanMdAngle%76);
			aScanMdAngle+=2;*/

			//cmFuncs.logRecords("GYGMTI方位波束中心角：",scanPar[2]);
			fwrite(&(scanPar[2]),sizeof(float),1,FL);
			fwrite(&(scanPar[2]),sizeof(float),1,FLSend);

			//scanPar[2]=(float)(mu.plane_direction_angle-imgPars.look_Side*90);
            //方位波束宽度 ***************imgPars.beam_horz_width
			scanPar[3]=(float)imgPars.beam_horz_width;
			//cmFuncs.logRecords("GYGMTI方位波束宽度：",scanPar[3]);
			fwrite(&(scanPar[3]),sizeof(float),1,FL);
			fwrite(&(scanPar[3]),sizeof(float),1,FLSend);

			//scanPar[4]=(float)GYPars.azimuthAngle;
			//方位向扫描步进
			//scanPar[4]=(float)GYPars.scanStep;
			scanPar[4]=(int)imgPars.beam_horz_width;
			//cmFuncs.logRecords("GYGMTI方位向扫描步进：",scanPar[4]);
			fwrite(&(scanPar[4]),sizeof(float),1,FL);
			fwrite(&(scanPar[4]),sizeof(float),1,FLSend);
			//俯仰波束中心角
			scanPar[5]=imgPars.R_angle_new;
			//cmFuncs.logRecords("俯仰波束中心角：",imgPars.R_angle_new);
			fwrite(&(scanPar[5]),sizeof(float),1,FL);
			fwrite(&(scanPar[5]),sizeof(float),1,FLSend);
			//俯仰波束宽度
			scanPar[6]=imgPars.beam_R_width;
			//cmFuncs.logRecords("俯仰波束宽度：",imgPars.beam_R_width);
			fwrite(&(scanPar[6]),sizeof(float),1,FL);
			fwrite(&(scanPar[6]),sizeof(float),1,FLSend);
			//俯仰向扫描步进
			scanPar[7]=0;
			//cmFuncs.logRecords("俯仰向扫描步进：",0);
			fwrite(&(scanPar[7]),sizeof(float),1,FL);
			fwrite(&(scanPar[7]),sizeof(float),1,FLSend);
			//fwrite(scanPar,sizeof(float),8,FL);
			//fwrite(scanPar,sizeof(float),8,FLSend);
			if(scanPar!=NULL)
			{
				delete []scanPar;
				scanPar=NULL;
			}		

			UINT16 resPulseNum=(UINT16)GYPars.pulseResident;
			fwrite(&resPulseNum,sizeof(UINT16),1,FL);
			fwrite(&resPulseNum,sizeof(UINT16),1,FLSend);

			UINT16 resTime=0;
			fwrite(&resTime,sizeof(UINT16),1,FL);
			fwrite(&resTime,sizeof(UINT16),1,FLSend);
		    //分辨率
			float resolv=0;
			fwrite(&resolv,sizeof(float),1,FL);
			fwrite(&resolv,sizeof(float),1,FLSend);

			UINT32 PRF=(UINT32)GYPars.prf;
			fwrite(&PRF,sizeof(UINT32),1,FL);
			fwrite(&PRF,sizeof(UINT32),1,FLSend);

			UINT16 nullPs=0;
			fwrite(&nullPs,sizeof(UINT16),1,FL);
			fwrite(&nullPs,sizeof(UINT16),1,FLSend);


			// ********* WAS-GMTI HJ OUTPUT ********
			UINT16 hj_num = (UINT16)GYLine.dotPathNum;
			fwrite(&hj_num,sizeof(UINT16),1,FL);
			fwrite(&hj_num,sizeof(UINT16),1,FLSend);

			//gyPathList * lstOutPut = GYLine.linePathHeader.gyPathPt;	
			//while(lstOutPut!=NULL)

			double info[10];
			FILE *fid_hj;
			char *outfile_dat = "d:\\DZS_HJ_XL.dat";
			if(hj_num < 3) return -1;
			if((fid_hj = fopen(outfile_dat,"rb"))==NULL) return -1;
			
			//cmFuncs.logRecords("hj_num:",(double)hj_num);

			int h=0;
			for(h=0; h<hj_num; h++)
			{
			   fread(info,sizeof(double),7,fid_hj);

			   UINT32 pointCodes=(UINT32)info[0];
			   fwrite(&pointCodes,sizeof(UINT32),1,FL);
			   fwrite(&pointCodes,sizeof(UINT32),1,FLSend);
               //序号
			   double pointLong=info[1];  //经度
			   fwrite(&pointLong,sizeof(double),1,FL);
			   fwrite(&pointLong,sizeof(double),1,FLSend);

			   //cmFuncs.logRecords("经度：",pointLong);

			   double pointLat=info[2];  //纬度
			   fwrite(&pointLat,sizeof(double),1,FL);
			   fwrite(&pointLat,sizeof(double),1,FLSend);

			   float pointHeight=info[3];
			   fwrite(&pointHeight,sizeof(float),1,FL);
			   fwrite(&pointHeight,sizeof(float),1,FLSend);

			   float point_P_v=(float)info[4];
			   fwrite(&point_P_v,sizeof(float),1,FL);
			   fwrite(&point_P_v,sizeof(float),1,FLSend);

			   float point_direction=(float)info[5];
			   fwrite(&point_direction,sizeof(float),1,FL);
			   fwrite(&point_direction,sizeof(float),1,FLSend);

			   UINT8 If_New=(UINT8)info[6];
			   fwrite(&If_New,sizeof(UINT8),1,FL);
			   fwrite(&If_New,sizeof(UINT8),1,FLSend);

			   UINT8 aim_prop=(UINT8)2;
			   fwrite(&aim_prop,sizeof(UINT8),1,FL);
			   fwrite(&aim_prop,sizeof(UINT8),1,FLSend);

			   //预留
			   UINT16 non_null=(UINT16)0;
			   fwrite(&non_null,sizeof(UINT16),1,FL);
			   fwrite(&non_null,sizeof(UINT16),1,FLSend);

			   //cmFuncs.logRecords("lati_out",pointLat);
			   //cmFuncs.logRecords("logn_out",pointLong);

			   //h++;
			   //lstOutPut=lstOutPut->Next;

			}
			fclose(fid_hj);


			UINT32 packetTail=0X0D0D0D0D;
			fwrite(&packetTail,sizeof(UINT32),1,FL);
			fwrite(&packetTail,sizeof(UINT32),1,FLSend);

			fclose(FL);
			fclose(FLSend);

			FLSend=fopen(sendFlName,"rb");

			if(FLSend==NULL)
			{
				return -1;
			}

			fseek(FLSend,0, SEEK_END);
			int file_size = ftell(FLSend);
			fseek(FLSend,0,SEEK_SET);

			char * buffer=new char[file_size];			
			fread(buffer,sizeof(char),file_size,FLSend);
			fclose(FLSend);
			
		    int resTemp=sendto(sockfd, buffer,file_size, 0,  
				(struct sockaddr *)&servaddr, sizeof(sockaddr));

			//cmFuncs.logRecords("广域GMTI Line 发送,发送结果为：",(double)resTemp);
			return resTemp;

			//return 0;
		}
		
		int GY_GMTIModel::outPut_NewGY_Line_TxtInfo(NewGYLineInfo GYLine)
		{// OK

			static int flNameCnt=0;
			static int pint=0;
			commonFuncs cmFuncs;
			int md=cmFuncs.getSarModel(ar);

			/*NewGYLineInfo GYLine(ar);
			GYLine.flightPathCon();
            */
			if(md!=4)
			{
				return ERROR_MODEL;
			}
			string rootForGeoMap=rootPath;
			string nameStrDotPath=rootPath+cmFuncs.getDataName(ar,flNameCnt)+"_P.txt";
			//
			char * nameDotPath=new char[1024];
            strcpy(nameDotPath,nameStrDotPath.c_str());

			FILE * FLPath=fopen(nameDotPath,"a");

			if(FLPath==NULL)
			{
				return ERROR_PATH;
			}

			pint++;
			GYLine.outPutLineTxt(FLPath);
			fclose(FLPath);

			flNameCnt++;
			return 0;

		}


		// ************* 组播实现函数 ***************
		int GY_GMTIModel::gy_Multicast_init()
		{
			
			//获取组播IP
			std::ifstream fin("iniDzs.txt",std::ios::in);
			if(!fin)
			{
				return -1;
			}
			
			char ipAr[64]={0};
			char portAr[8]={0};
			fin.getline(ipAr, sizeof(ipAr));
			fin.getline(portAr,sizeof(portAr));
			int lenPortAr=strlen(portAr);
			int portNum=portAr[0]-'0';
			for(int i=1;i<lenPortAr;i++)
			{
				int iTemp=portAr[i]-'0';
				portNum=10*portNum+iTemp;
			}

			if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0)
				{
				return -1;
				}
         
				sockfd=WSASocket(AF_INET,SOCK_DGRAM,0,NULL,
					0,WSA_FLAG_MULTIPOINT_C_LEAF|WSA_FLAG_MULTIPOINT_D_LEAF|WSA_FLAG_OVERLAPPED);
				
				if(sockfd==INVALID_SOCKET)
				{
				  return -1;
				}   
  
				memset(&servaddr,0, sizeof(servaddr));  
				servaddr.sin_family = AF_INET;  
				servaddr.sin_addr.s_addr = inet_addr(ipAr);  
				servaddr.sin_port=htons(portNum);
				sockM=WSAJoinLeaf(sockfd,(SOCKADDR*)&servaddr,sizeof(servaddr),NULL,NULL,NULL,NULL,JL_BOTH);
				if(sockM==INVALID_SOCKET)
				{
				  return -1;
				} 

			return 0;		
		}
		
		int GY_GMTIModel::gy_Multicast_init0()
		{
			//获取组播IP
			std::ifstream fin("iniDzs.txt",std::ios::in);
			if(!fin)
			{
				return -1;
			}
			
			char ipAr[64]={0};
			char portAr[8]={0};
			fin.getline(ipAr, sizeof(ipAr));
			fin.getline(portAr,sizeof(portAr));
			int lenPortAr=strlen(portAr);
			int portNum=portAr[0]-'0';
			for(int i=1;i<lenPortAr;i++)
			{
				int iTemp=portAr[i]-'0';
				portNum=10*portNum+iTemp;
			}

			if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0)
				{
				  return -1;
				}
         
				sockfd= socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
				
				if(sockfd==INVALID_SOCKET)
				{
				  return -1;
				}   
  
				memset(&servaddr,0, sizeof(servaddr));  
				servaddr.sin_family = AF_INET;  
				servaddr.sin_addr.s_addr = inet_addr(ipAr);  
				servaddr.sin_port=htons(portNum);
				bool bOpt = true;
				setsockopt(sockfd,SOL_SOCKET,SO_BROADCAST, (char*)&bOpt, sizeof(bOpt));
				if(sockM==INVALID_SOCKET)
				{
				  return -1;
				} 

			return 0;		
		}
	

	    // ***** 链表类操作 DEV BY Yunhua-Luo 2015/12/25 check 2016/1/15 *****
		// Create list
		bool list::CreateNodeList(Node* node_init)
		{// OK

			if(head == NULL) head = (Node* )malloc(sizeof(Node));
		
			if(NULL == head)
			{
				return false;

			}else
			{
				head = node_init;
				tail = node_init;
				node_init->next = NULL;
				head->next = NULL;
				list_len = 1;

				return true;
			}
		}

		list::list()
		{
			head = NULL;
			tail = NULL;
			list_len = 0;
			next_tail = NULL;
		}

		bool list::AddNode(Node* node)
		{
			if(NULL==head) return false;
	
			Node* p = head->next;
			Node* q = head;
			while(NULL!=p)
			{
				q = p;
				p = p->next;
			}

			q->next = node;
			tail = node;
			node->next = NULL;

			return true;
		}

		bool list::DeleteNode(int index)
		{
			if(NULL==head) return false;
			Node* p = head->next;

			int length = 1;
			while(NULL != p)
			{
				length++;
				p = p->next;
			}

			if(length < index) 
			{
				return false;

			}else
			{
				Node* q = head;
				p = head;
				for(int i=0; i<index; i++)
				{
					q = p;
					p = p->next;
				}
				Node* t = p->next;
				q->next = t;
				free(p);
		
				return true;
			}
		}

		bool list::GetPreTail(Node* node)
		{
			if(NULL==head) return false;
			Node* p = head->next;

			int length = 1;  // modified 1/11 8:50
			while(NULL != p)
			{
				length++;
				p = p->next;
			}

			p = head;
			for(int i=0; i<length-2; i++) // notice length-2;
			{
				p = p->next;
			}
			node = p;

			return true;
		}

		void list::ListDestroy()
		{
			head = NULL;
			tail = NULL;
			next_tail = NULL;
			list_len = 0;
		}

		int list::GetLength()
		{// ok

			if(NULL==head) return 0;
			Node* p = head->next;

			int length = 1;
			while(NULL != p)
			{
				length++;
				p = p->next;
			}
			list_len = length;
			return length;
		}

		int list::CalListWeight()
		{
			long k = 0;
			if(NULL==head) return 0;
			Node* p = head->next;

			int weigh = 0;//int(p->is_real);
	
			while(NULL != p)
			{
				if(int(p->is_real)==1) 
				{
					weigh = 0;
					p = p->next;  // added 2016/1/11
					continue;
				}
				weigh++;
				//weigh += int(p->is_real);
				p = p->next;
			}

			return weigh;	
		}

		void list::PredictNext()
		{//OK

			double lati[2];
			double logn[2];

			Node* preTail = (Node *)malloc(sizeof(Node));
			GetPreTail(preTail);
			lati[0] = preTail->lati;
			logn[0] = preTail->logn;
			free(preTail);

			lati[1] = tail->lati;
			logn[1] = tail->logn;

			next_tail = (Node *)malloc(sizeof(Node));
			next_tail->frame_no = tail->frame_no+1; // ok
			next_tail->is_real = false;
			next_tail->is_related = false;
			next_tail->tar_ampl = tail->tar_ampl;
			next_tail->tar_azi = tail->tar_azi;
			next_tail->tar_direction = tail->tar_direction;
			next_tail->tar_h = tail->tar_h;
			next_tail->tar_r0 = tail->tar_r0;
			next_tail->tar_vr = tail->tar_vr;
			next_tail->wave_no = tail->wave_no;

			next_tail->lati = lati[1] + (lati[1]-lati[0]);  
			next_tail->logn = logn[1] + (logn[1]-logn[0]); // linear predict 

		}

		void list::KalmanPredict()
		{
			// Calculate input value 
			AxisCal ax;
			double Pos[3];

			if(list_len==2)
			{
				double lati = tail->lati;
				double logn = tail->logn;
				double href = tail->tar_h;

				ax.WGS84ToENV(lati,logn,href,Pos);
				double Px = Pos[0];
				double Py = Pos[1];
				lati_ref = lati;
				logn_ref = logn;
				Pz_ref = Pos[2];

				Node* preTail = (Node *)malloc(sizeof(Node));
				GetPreTail(preTail);
				lati = preTail->lati;
				logn = preTail->logn;
				free(preTail);
				ax.WGS84ToENV(lati,logn,href,Pos);
				double Vx = (Px-Pos[0])/T_SCAN;
				double Vy = (Py-Pos[1])/T_SCAN;
				
				double X0_TEMP[] = {Px,Py,Vx,Vy};
				double P0_TEMP[] =  {var_xy,0,var_xy/T_SCAN,0,0,var_xy,0,var_xy/T_SCAN,var_xy/T_SCAN,
									 0,2*var_xy/T_SCAN/T_SCAN,0,0,var_xy/T_SCAN,0,2*var_xy/T_SCAN/T_SCAN};
				// Initial value 
				memcpy(X0_INPUT,X0_TEMP,sizeof(double)*4);
				memcpy(P0_INPUT,P0_TEMP,sizeof(double)*16);

			}

			// Kalman predict val 
			MathOP op;
			double F_M[] = {1,0,T_SCAN,0,0,1,0,T_SCAN,0,0,1,0,0,0,0,1};
			double T_M[] = {0.5*T_SCAN*T_SCAN,0,0,0.5*T_SCAN*T_SCAN,T_SCAN,0,0,T_SCAN};
			double Q_M[] = {0.1,0,0,0.1}; // accelerate noise

			double TEMP_M[16];
			double X1_M[4];
			double Q1_M[16];

			op.MtrixClear(TEMP_M,16);
			op.MtrixClear(X1_M,4);
			op.MtrixClear(Q1_M,16);

			op.MtrixPuls(T_M,Q_M,4,2,2,TEMP_M);//乘法前将结果集赋空，因为有累加。
			op.MtrixTrans(T_M,4,2);
			op.MtrixPuls(TEMP_M,T_M,4,2,4,Q1_M); // Q1_M 4*4

			op.MtrixPuls(F_M,X0_INPUT,4,4,1,X1_M); // X0_INPUT 4*1
			op.MtrixEqual(X0_INPUT,X1_M,4);

			op.MtrixPuls(F_M,P0_INPUT,4,4,4,TEMP_M);
			op.MtrixTrans(F_M,4,4);
			op.MtrixPuls(TEMP_M,F_M,4,4,4,P0_INPUT);
			op.MtrixAdd(P0_INPUT,Q1_M,16);  //P0_INPUT 4*4 ;;

			// -------------
			double latlogn[2];
			Pos[0] = X0_INPUT[0]; // PE;
			Pos[1] = X0_INPUT[1]; // PN;
			Pos[2] = Pz_ref;
			ax.ENVToWGS84(lati_ref,logn_ref,Pos,latlogn);

			// next tail
			next_tail = (Node *)malloc(sizeof(Node));
			next_tail->frame_no = tail->frame_no+1; // ok
			next_tail->is_real = false;
			next_tail->is_related = false;
			next_tail->tar_ampl = tail->tar_ampl;
			next_tail->tar_azi = tail->tar_azi;
			next_tail->tar_direction = tail->tar_direction;
			next_tail->tar_h = tail->tar_h;
			next_tail->tar_r0 = tail->tar_r0;
			next_tail->tar_vr = tail->tar_vr;
			next_tail->wave_no = tail->wave_no;

			next_tail->lati = latlogn[0];  
			next_tail->logn = latlogn[1]; // Kalman predict 
			
		}

		void list::KalmanFilter(double var_x, double var_y, Node* node)
		{
			AxisCal ax;
			double lati = node->lati;
			double logn = node->logn;
			double href = node->tar_h;
			
			double Pos[3];
			ax.WGS84ToENV(lati,logn,href,Pos);
			double Px = Pos[0];
			double Py = Pos[1];
			double Pz = Pos[2];

			double MEASURE[2] = {Px,Py};
			
			double F_M[] = {1,0,T_SCAN,0,0,1,0,T_SCAN,0,0,1,0,0,0,0,1};
			double T_M[] = {0.5*T_SCAN*T_SCAN,0,0,0.5*T_SCAN*T_SCAN,T_SCAN,0,0,T_SCAN};
			double H_M[] = {1,0,0,0,0,1,0,0};
			double Q_M[] = {0.1,0,0,0.1};
			double R_M[] = {var_x,0,0,var_y};
			double EYE[] = {1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1};

			double TEMP_M[16];
			double TEMP1_M[16];
			double TEMP2_M[16];
			double TEMP3_M[16];

			double X0_M[16];
			double X1_M[16];
			double Q1_M[16];
			double Y1_M[2];

			double P1_M[16];
			double S_M[4];
			double INV_S_M[4];
			double W_M[8];
			
			double NEW_P0[16];
			double NEW_X0[16];

			MathOP op;
			op.MtrixPuls(T_M,Q_M,4,2,2,TEMP_M);
			op.MtrixTrans(T_M,4,2);
			op.MtrixPuls(TEMP_M,T_M,4,2,4,Q1_M);

			op.MtrixPuls(F_M,X0_INPUT,4,4,1,X1_M);
			op.MtrixPuls(H_M,X1_M,2,4,1,Y1_M);

			op.MtrixPuls(F_M,P0_INPUT,4,4,4,TEMP_M);
			op.MtrixTrans(F_M,4,4);
			op.MtrixPuls(TEMP_M,F_M,4,4,4,P1_M);
			op.MtrixAdd(P1_M,Q1_M,16);

            op.MtrixPuls(H_M,P1_M,2,4,4,TEMP_M);
            op.MtrixTrans(H_M,2,4);
            op.MtrixPuls(TEMP_M,H_M,2,4,2,S_M);
			op.MtrixAdd(S_M,R_M,4);

            op.MtrixPuls(P1_M,H_M,4,4,2,TEMP_M);
			op.InvMtrix22(S_M,INV_S_M);
            op.MtrixPuls(TEMP_M,INV_S_M,4,2,2,W_M);

			// NEW-P0
            op.MtrixTrans(H_M,4,2);        
			op.MtrixPuls(W_M,H_M,4,2,4,TEMP_M);
			op.MtrixEqual(TEMP1_M,EYE,16);
			op.MtrixSub(TEMP1_M,TEMP_M,16);
			op.MtrixPuls(TEMP1_M,P1_M,4,4,4,TEMP3_M);
			
			op.MtrixPuls(W_M,H_M,4,2,4,TEMP_M);
			op.MtrixAdd(TEMP_M,EYE,16);
			op.MtrixTrans(TEMP_M,4,4);

			op.MtrixPuls(TEMP3_M,TEMP_M,4,4,4,TEMP1_M);
			// WRW';
			op.MtrixPuls(W_M,R_M,4,2,2,TEMP_M);
			op.MtrixTrans(W_M,4,2);
			op.MtrixPuls(TEMP_M,W_M,4,2,4,TEMP3_M);
			op.MtrixSub(TEMP1_M,TEMP3_M,16);

			op.MtrixEqual(P0_INPUT,TEMP1_M,16);

            op.MtrixSub(MEASURE,Y1_M,2);
			op.MtrixTrans(W_M,2,4);
            op.MtrixPuls(W_M,MEASURE,4,2,1,TEMP_M);
			op.MtrixAdd(X1_M,TEMP_M,4);
			op.MtrixEqual(X0_INPUT,X1_M,4);

			// ----------------
			// -------------
			double latlogn[2];
			Pos[0] = X0_INPUT[0]; // PE;
			Pos[1] = X0_INPUT[1]; // PN;
			Pos[2] = Pz;
			ax.ENVToWGS84(lati,logn,Pos,latlogn);

			// next tail
			next_tail = (Node *)malloc(sizeof(Node));
			next_tail->frame_no = tail->frame_no+1; // ok
			next_tail->is_real = true;
			next_tail->is_related = true;
			next_tail->tar_ampl = tail->tar_ampl;
			next_tail->tar_azi = tail->tar_azi;
			next_tail->tar_direction = tail->tar_direction;
			next_tail->tar_h = tail->tar_h;
			next_tail->tar_r0 = tail->tar_r0;
			next_tail->tar_vr = tail->tar_vr;
			next_tail->wave_no = tail->wave_no;

			next_tail->lati = latlogn[0];  
			next_tail->logn = latlogn[1]; // Kalman predict 
		}

		void list::Output(FILE *fid_txt, FILE* fid_dat,long hj_no,long len)
		{
			if(NULL==head) return;
			Node* p = head->next;

			//fprintf(fid_txt,"\n\nTrace %d ->",hj_no);
			double info[10];
			long cnt = 0;
			int new_flag = int(is_update);
			int tar_flag = 2;
			
			while(NULL != p && (p->frame_no >= 0) && (p->frame_no <= 100)&& cnt < len-1)
			{
				// ******** Write into txtfile ********
				//fprintf(fid_txt,"node(%.7f,%.7f,%d,%d)->",p->logn,p->lati,p->frame_no,int(p->is_real));
				fprintf(fid_txt,"航迹批号：%04d\n",hj_no);
				fprintf(fid_txt,"目标经度：%.7f°\n",p->logn);
				fprintf(fid_txt,"目标纬度：%.7f°\n",p->lati);
				fprintf(fid_txt,"目标高度：%.3f(m)\n",p->tar_h);
				fprintf(fid_txt,"目标速度：%.3f(m/s)\n",p->tar_vr);
				fprintf(fid_txt,"目标方向：%.4f°\n",p->tar_direction);
				fprintf(fid_txt,"新批标识：%d\n",new_flag);
				fprintf(fid_txt,"目标属性：%d\n\n",tar_flag);
				
			    // ******** Write into datfile **********
				info[0] = double(hj_no);
				info[1] = p->logn;
				info[2] = p->lati;
				info[3] = p->tar_h;
				info[4] = p->tar_vr;
				info[5] = p->tar_direction; 
				info[6] = new_flag;
				fwrite(info,sizeof(double),7,fid_dat);
				cnt++;
				p = p->next;

			}
		}

		void list::Print()
		{

		}

	
		// ************** Matrix operation class ***************

		void MathOP::MtrixTrans(double* A, int m, int n)
		{// check 1/15

			long N = m*n;
			double* B_Mtrix = new double[N];

			int h,k;
			for(h=0; h<m; h++)
				for(k=0; k<n; k++)
				{
					B_Mtrix[m*k+h] = A[h*n+k];
				}
			memcpy(A,B_Mtrix,sizeof(double)*N);

			delete [] B_Mtrix;
		}

		void MathOP::MtrixPuls(double* A, double* B, int m, int s, int n,double* res)
		{// A -- m*s B s*n  res m*n
			
			memset(res,0,sizeof(double)*m*n);
			int i,j,k;
			for(i=0;i<m;i++)
				for(j=0;j<n;j++)
					for(k=0;k<s;k++)
						res[i*n+j] += A[i*s+k]*B[k*n+j];
		}

		void MathOP::MtrixAdd(double* A, double* B, int LEN)
		{
			int h;
			for(h=0; h<LEN; h++)
			{
				A[h] += B[h];
			}
		}

		void MathOP::MtrixSub(double* A, double* B, int LEN)
		{
			int h;
			for(h=0; h<LEN; h++)
			{
				A[h] -= B[h];
			}
		}

		void MathOP::MtrixEqual(double* A, double* B, int LEN)
		{
			memcpy(A,B,sizeof(double)*LEN);
		}

		void MathOP::InvMtrix22(double* A, double* B)
		{
			double a = A[0];
			double b = A[1];
			double c = A[2];
			double d = A[3];

			double coef = 1/(a*d-b*c);
			B[0] = coef*d;
			B[1] = -coef*b;
			B[2] = -coef*c;
			B[3] = coef*a;
		}

		void MathOP::MtrixClear(double* A, int LEN)
		{
			memset(A,0,sizeof(double)*LEN);
		}


		// ************** Axis calculation class *************

		double AxisCal::RangeCalByGPS(double lati0,double logn0, double lati1, double logn1)
		{
			double X_lati = abs(lati0-lati1)*double(111693.1);
			double X_logn = abs(logn0-logn1)*double(111693.1)*cos(lati0*PI/180.0);

			double range = sqrt(X_lati*X_lati+X_logn*X_logn);

			return range;
		}

		void AxisCal::WGS84ToENV(double lati, double logn, double href, double* Pos)
		{
			const double a = double(6378136.49);
			const double b = double(6356755.00);
			const double C45 = 180.0/PI;
			double lat = lati/C45;
			double lon = logn/C45;
			double Px,Py,Pz;
	
			double e2 = (a*a-b*b)/a/a;
			double N = a/sqrt(1-e2*sin(lat)*sin(lat));

			Px = (N+href)*cos(lat)*cos(lon);
			Py = (N+href)*cos(lat)*sin(lon);
			Pz = (N*(1-e2)+href)*sin(lat);

			// ECEF to ENV;
			Pos[0] = -Px*sin(lon)+Py*cos(lon);
			Pos[1] = -Px*sin(lat)*cos(lon)-Py*sin(lat)*sin(lon)+Pz*cos(lat);
			Pos[2] =  Px*cos(lat)*cos(lon)+Py*cos(lat)*sin(lon)+Pz*sin(lat);
		}

		void AxisCal::ENVToWGS84(double lati, double logn, double* Pos, double* latlogn)
		{// Pos -- Position in ENV 

			// ENV TO ECEF 
			const double C45=180.0/PI;
			double lon=logn/C45;
			double lat=lati/C45;
			double Px,Py,Pz;
			double PE = Pos[0];
			double PN = Pos[1];
			double PU = Pos[2];

			Px = -PE*sin(lon)-PN*sin(lat)*cos(lon)+PU*cos(lat)*cos(lon);
			Py =  PE*cos(lon)-PN*sin(lat)*sin(lon)+PU*cos(lat)*sin(lon);
			Pz =  PN*cos(lat)+PU*sin(lat);

			// ECEF TO WGS84 
			const double a = double(6378136.49);
			const double b = double(6356755.00);
			double e2 = (a*a-b*b)/a/a;
			double logn0 = atan(Py/Px);
			double lati_ref = lati;

			double N = a/sqrt(1-e2*sin(lati_ref*PI/180.0)*sin(lati_ref*PI/180.0));
			double lati0 = atan((Pz+N*e2*sin(lati_ref*PI/180.0))/sqrt(Px*Px+Py*Py));

			latlogn[0] = lati0*C45;
			latlogn[1] = logn0*C45;

		}

		double AxisCal::CalDirection(double lat_s,double lon_s, double lat_e, double lon_e)
		{
		
			double WD_L = (lat_e - lat_s)*double(111693.1);
			double JD_L = (lon_e - lon_s)*double(111693.1)*cos(lat_e*PI/180.0);
			
			if(WD_L == 0) return 0;

			double angle = atan(JD_L/WD_L)*180.0/PI;

			if(lat_e < lat_s) angle = angle + 180.0;

			return angle;

		}
